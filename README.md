

# leetcode
## Overview
* [1 Two Sum](#1-two-sum)
* [2 Add Two Numbers](#2-add-two-numbers)
* [3 Longest Substring without Repeating Characters](#3-longest-substring-without-repeating-characters))
* [4 Median of Two Sorted Arrays](#4-median-of-two-sorted-arrays)
* [5 Longest Palindromic Substring](#5-longest-palindromic-substring)
* [6 Zigzag Conversion](#6-zigzag-conversion)
* [7 Reverse Integer](#7-reverse-integer)
* [8 String to Integer atoi](#8-string-to-integer-atoi)
* [9 Palindrome Number](#9-palindrome-number)
* [10 Regular Expression Matching](#10-regular-expression-matching)
* [11 Container with Most Water](#11-container-with-most-water)
* [12 Integer to Roman](#12-integer-to-roman)
* [13 Roman to Integer](#13-roman-to-integer)
* [14 Longest Common Prefix](#14-longest-common-prefix)
* [15 3Sum](#15-3sum)
* [16 3Sum Closest](#16-3sum-closest)
* [17 Number Combinations of a Phone Number](#17-number-combinations-of-a-phone-number)
* [18 4Sum](#18-4sum)
* [19 Remove Nth Node From End of List](#19-remove-nth-node-from-end-of-list)
* [20 Valid Parentheses](#20-valid-parentheses)
* [21 Merge Two Sorted Lists](#21-merge-two-sorted-lists)
* [22 Generate Parentheses](#22-generate-parentheses)
* [23 Merge k Sorted Lists](#23-merge-k-sorted-lists)
* [24 Swap Nodes in Pairs](#24-swap-nodes-in-pairs)
* [25 Reverse Nodes in kGroup](#25-reverse-nodes-in-kgroup)
* [26 Remove Duplicates from Sorted Array](#26-remove-duplicates-from-sorted-array)
* [27 Remove Element](#27-remove-element)
* [28 Implement strStr](#28-implement-strstr)
* [29 Divide Two Integers](#29-divide-two-integers)
* [30 Substring with Concatenation of All Words](#30-substring-with-concatenation-of-all-words)
* [31 Next Permutation](#31-next-permutation)
* [32 Longest Valid Parentheses](#32-longest-valid-parentheses)
* [33 Search in Rotated Sorted Array](#33-search-in-rotated-sorted-array)
* [34 Search for a Range](#34-search-for-a-range)
* [35 Search Insert Position](#35-search-insert-position)
* [36 Valid Sudoku](#36-valid-sudoku)
* [37 Sudoku Solver](#37-sudoku-solver)
* [38 Count and Say](#38-count-and-say)
* [39 Combination Sum](#39-combination-sum)
* [40 Combination Sum II](#40-combination-sum-ii)
* [41 First Missing Positive](#41-first-missing-positive)
* [42 Trapping Rain Water](#42-trapping-rain-water)
* [43 Multiply Strings](#43-multiply-strings)
* [44 Wildcard Matching](#44-wildcard-matching)
* [45 Jump Game II](#45-jump-game-ii)
* [46 Permutations](#46-permutations)
* [47 Permutations II](#47-permutations-ii)
* [48 Rotate Image](#48-rotate-image)
* [49 Anagrams](#49-anagrams)
* [50 Pow](#50-pow)
* [51 N Queens](#51-n-queens)
* [53 Maximum Subarray](#53-maximum-subarray)
* [54 Spiral Matrix](#54-spiral-matrix)
* [55 Jump Game](#55-jump-game)
* [56 Merge Intervals](#56-merge-intervals)
* [57 Insert Interval](#57-insert-interval)
* [59 Spiral Matrix II](#59-spiral-matrix-ii)
* [61 Rotate List](#61-rotate-list)
* [69 Sqrt](#69-sqrt)
* [70 Climbing Stairs](#70-climbing-stairs)
* [73 Set Matrix Zeroes](#73-set-matrix-zeroes)
* [74 Search a 2D Matrix](#74-search-a-2d-matrix)
* [75 Sort Colors](#75-sort-colors)
* [80 Remove Duplicates from Sorted Array II](#80-remove-duplicates-from-sorted-array)
* [82 Remove Duplicates from Sorted List](#82-remove-duplicates-from-sorted-list)
* [83 Remove Duplicates from Sorted List II](#83-remove-duplicates-from-sorted-list-ii)
* [86 Partition List](#86-partition-list)
* [89 Gray Code](#89-gray-code)
* [92 Reverse Linked List II](#92-reverse-linked-list-ii)
* [94 Binary Tree Inorder Traversal](#94-binary-tree-inorder-traversal)
* [95 Unique Binary Search Trees](#95-unique-binary-search-trees)
* [96 Unique Binary Search Trees II](#96-unique-binary-search-trees)
* [98 Validate Binary Search Tree](#98-validate-binary-search-tree)
* [99 Recover Binary Search Tree](#99-recover-binary-search-tree)
* [100 Same Tree](#100-same-tree)
* [103 Binary Tree Zigzag Level Order Traversal](#103-binary-tree-zigzag-level-order-traversal)
* [108 Convert Sorted Array to Binary Search Tree](#108-convert-sorted-array-to-binary-search-tree)
* [109 Convert Sorted List to Binary Search Tree](#109-convert-sorted-list-to-binary-search-tree)
* [114 Flatten Binary Tree to Linked List](#114-flatten-binary-tree-to-linked-list)
* [118 Pascal Triangle](#118-pascal-triangle)
* [119 Pascal Triangle II](#119-pascal-triangle-ii)
* [120 Triangle](#120-triangle)
* [121 Best Time to Buy and Sell Stock](#121-best-time-to-buy-and-sell-stock)
* [122 Best Time to Buy and Sell Stock II](#122-best-time-to-buy-and-sell-stock-ii)
* [123 Best Time to Buy and Sell Stock III](#123-best-time-to-buy-and-sell-stock-iii)
* [126 Word Ladder](#126-word-ladder)
* [127 Word Ladder II](#127-word-ladder-ii)
* [135 Candy](#135-candy)
* [138 Copy List With Random Pointer](#138-copy-list-with-random-pointer)
* [141 Linked List Cycle](#141-linked-list-cycle)
* [142 Linked List Cycle II](#142-linked-list-cycle-ii)
* [143 Reorder List](#143-reorder-list)
* [147 Insertion Sort List](#147-insertion-sort-list)
* [148 Sort List](#148-sort-list)
* [155 Min Stack](#155-min-stack)
* [156 Binary Tree Upside Down](#156-binary-tree-upside-down)
* [157 Read N Characters Given Read4](#157-read-n-characters-given-read4)
* [158 Read N Characters Given Read4 II - Call multiple times](#158-read-n-characters-given-read4-ii-call-multiple-times) 
* [159 Longest String with At Most Two Distinct Characters](#159-longest-string-with-at-most-two-distinct-characters)
* [160 Intersection of Two Linked Lists](160-intersection-of-two-linked-lists)
* [166 Fraction to Recurring Decimal](#166-fraction-to-recurring-decimal)
* [167 Two Sum II Input array is sorted](#167-two-sum-ii-input-array-is-sorted)
* [170 Two Sum III Data Structure Design](#170-two-sum-iii-data-structure-design)
* [188 Best Time to Buy and Sell Stock IV](#188-best-time-to-buy-and-sell-stock-iv)
* [189 Rotate Array](#189-rotate-array)
* [190 Reverse Bits](#190-reverse-bits)
* [191 Number of 1 Bits](#191-number-of-1-bits)
* [198 House Robber](#198-house-robber)
* [199 Binary Tree Right Side View](#199-binary-tree-right-side-view)
* [200 Number of Islands](#200-number-of-islands)
* [201 Bitwise AND of Numbers Range](#201-bitwise-and-of-numbers-range)






<br>


### 1 Two Sum
>Given an array of integers, find two numbers such that they add up to a specific target number.

>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.

>You may assume that each input would have exactly one solution.

>Input: numbers={2, 7, 11, 15}, target=9

>Output: index1=1, index2=2

**Solution1**: Use hashmap to record the number and its index, each time check if map containsKey target - num[i].

**Time complexity** O(n)

**Space** O(n)

```java
   public int[] twoSum(int[] numbers, int target) {
        //use hashmap
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        int[] result = new int[2];
        if(numbers == null || numbers.length == 0) return result;
        
        for(int i = 0; i < numbers.length; i++){
            if(map.containsKey(target - numbers[i])){
                result[0] = map.get(target - numbers[i]) + 1;
                result[1] = i + 1;
                return result;
            }
            map.put(numbers[i], i);
        }
        return result;
    }
```    
	
**Solution2**: We can first sort the numbers. Then use two pointers, the first pointer points to the begining and the second points to the end. Each time compares the target and num[p1]+num[p2], if target is bigger, p1++, else p2--. But it doesn't work for this problem, because we need to return the index. If we are requested to return the nunbers, we can use the following way.

**Time**: O(nlgn)

**Space**: O(1)

```java
    //this function returns the numbers, not the index
    public int[] twoSum(int[] numbers, int target) {
        //First sort, then use two pointers
        int[] res = new int[2];
        if(numbers == null || numbers.length <= 1) return res;
        Arrays.sort(numbers);
        int l = 0;
        int r = numbers.length -1;
        while(l < r){
            if(numbers[l] + numbers[r] == target){
                res[0] = numbers[l];
                res[1] = numbers[r];
                return res;
            }else if(numbers[l] + numbers[r] > target)
                r--;
            else l++;
        }
        return res;
    }

```
Related problem: 

* [1 Two Sum](#1-two-sum)
* [15 3Sum](#15-3sum)
* [16 3Sum Closest](#16-3sum-closest)
* [18 4Sum](#18-4sum)
* [167 Two Sum II Input array is sorted](#167-two-sum-ii-input-array-is-sorted)
* [170 Two Sum III Data Structure Design](#170-two-sum-iii-data-structure-design)

<br>
<br>

### 2 Add Two Numbers

> You are given two linked lists representing two non-negative numbers.
> The digits are stored in reverse order and each of their nodes contain a single digit.
> Add the two numbers and return it as a linked list.
>
> **`Input:`** `(2 -> 4 -> 3) + (5 -> 6 -> 4)`
>
> **`Output`** `(7 -> 0 -> 8)`

**Idea**: 

Digits are stored in reverse order, that means `(2 -> 4 -> 3)` is `342`. When it reaches 10 after addition, the next node shall add 1 and current node shall only keep the unit number: `(3 -> 2) + (9 -> 1) = (2 -> 4)`; if one integer doesn't have more numbers, add the remaining digits to  result.


**Attention**: After both l1 and l2 reach to the end, check the carry. If carry != 0, add an additional node to the result. 

**More**: What if the numbers are store in order? It's a little complicated than the question above. One way is add the corresponding digits, notice that the numbers might have different number of bits, so we can not add from beginning. The other stupid method is first reverse the linkedlist, then use the method above. 

**java code**:

```java

    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        if(l1 == null) return l2;
        if(l2 == null) return l1;
        ListNode fakeHead = new ListNode(-1);
        ListNode res = fakeHead;
        int carry = 0;
        while(l1 != null && l2 != null){
            int sum = l1.val + l2.val + carry;
            int mod = sum % 10;
            carry = sum / 10;
            res.next = new ListNode(mod);
            res = res.next;
            l1 = l1.next;
            l2 = l2.next;
        }
        while(l1 != null){
            int sum = l1.val + carry;
            int mod = sum % 10;
            carry = sum / 10;
            res.next = new ListNode(mod);
            l1 = l1.next;
            res = res.next;
        }
        while(l2 != null){
            int sum = l2.val + carry;
            int mod = sum % 10;
            carry = sum / 10;
            res.next = new ListNode(mod);
            l2 = l2.next;
            res = res.next;
        }
        if(carry != 0)
            res.next = new ListNode(carry);
        return fakeHead.next;
    }

```



**c++ Code**:

``` cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *addTwoNumbers(ListNode *l1, ListNode *l2) {
        ListNode *p1 = l1, *p2 = l2;
        ListNode *r = new ListNode(0);
        ListNode *begin = r;
        int sum = 0;
        
        while (p1 && p2) {
            sum = p1->val + p2->val + sum / 10;
            r->next = new ListNode(sum % 10);
            p1 = p1->next;
            p2 = p2->next;
            r = r->next;
        }
        
        ListNode *px = NULL;
        if (p1) { px = p1; }
        else if (p2) { px = p2; }
        
        while (px) {
            sum = sum / 10 + px->val;
            r->next = new ListNode(sum % 10);
            px = px->next;
            r = r->next;
        }
        if (sum >= 10) { r->next = new ListNode(sum / 10); }
        
        return begin->next;
    }
    
};
```

The time complexity is O(m+n) and space complexity is O(m+n).

<br>
<br>

###3 Longest Substring without Repeating Characters
>Given a string, find the length of the longest substring without repeating characters. For example, the longest substring without repeating letters for "abcabcbb" is "abc", which the length is 3. For "bbbbb" the longest substring is "b", with the length of 1.


**Idea**: if encounter duplicates, start from the character after the dulicate appear at the first time. eg: abcab, at index 4 a is duplicated, we start count from index 1(after the first a).

```java

    public int lengthOfLongestSubstring(String s) {
        if(s == null || s.length() == 0) return 0;
        int start = 0;
        int current = 0;
        int max = 0;
        Set<Character> set = new HashSet<Character>();
        while(current < s.length()){
            if(set.contains(s.charAt(current))){
                max = Math.max(max, current - start);
                while(s.charAt(start) != s.charAt(current)){
                    set.remove(s.charAt(start));
                    start++;
                }
                start++;
            }else{
                set.add(s.charAt(current));
            }
            current++;
        }
        max = Math.max(current- start, max);
        return max;
    }
    

```

There is another solution use primitive string methods, such as indexOf, subString and contains. Because indexOf and contains take O(n*m), so it's really slow. It can be AC by leetcode, but when network is bad, it may time limit exceeded.

```java

    public int lengthOfLongestSubstring(String s) {
    	if(s == null || s.length() == 0) return 0;  	
    	int longest = 0;
    	int current = 0;
    	StringBuilder sBuilder = new StringBuilder();
    	for(int i = 0, len = s.length(); i < len; i++){

    		if(sBuilder.toString().contains(s.charAt(i)+"")){
    			longest = Math.max(longest, current);
    			int index = sBuilder.indexOf(s.charAt(i)+"");
    			sBuilder = new StringBuilder(sBuilder.substring(index+1));
    			sBuilder.append(s.charAt(i));
    			current = sBuilder.length();
    		}else{
    			sBuilder.append(s.charAt(i));
    			current++;
    		}
    	}
    	longest = Math.max(longest, current);
   		return longest;        
    }

```
<br>


***Related Problems***

* [3 Longest Substring without Repeating Characters](#3-longest-substring-without-repeating-characters))

* [159 Longest String with At Most Two Distinct Characters](#159-longest-string-with-at-most-two-distinct-characters)

<br>

###4 Median of Two Sorted Arrays

>There are two sorted arrays A and B of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).

**Idea**: We need to find the median, thus if (lenA + lenB) % 2 == 1, we need to find the ((lenA + lenB)/2 + 1)th smallest element. If  (lenA + lenB) % 2 == 0, we return ( (lenA + lenB)/2)th + (lenA + lenB)/2 + 1)th)/ 2. So we can use the idea in find the kth element in an array. The steps are as follows:

- 1) find the k/2 element of A and B
- 2) when B[k/2 -1] = A[k/2 -1], then the kth element is A[k/2 -1]
- 3) if A[k/2 -1] < B[k/2 -1], then the kth element is not in A[0.....k/2 -1] and  B[k/2.....B.length -1]
- 4) if A[k/2 -1] > B[k/2 -1], then the kth element is not in B[0.....k/2 -1] and  A[k/2.....A.length -1]

**Time complexity ** O(log(m+n))



**Attention**: There are cases when one array is really longer than the other one, so we need to check the length of k/2 and length of array. Otherwise, there might be indexoutofbound exception. 


```java

    public double findMedianSortedArrays(int A[], int B[]) {
        if(A == null && B == null) return 0;
        if(A == null) return B.length % 2 == 0 ? (B[B.length/2 -1] + B[B.length/2])/2 : B[B.length/2];
        if(B == null) return A.length % 2 == 0 ? (A[A.length/2 -1] + A[A.length/2])/2 : A[A.length/2];
        return ((A.length + B.length) % 2 == 1) ? helper(A, B, 0, A.length-1, 0, B.length-1, (A.length + B.length)/2 + 1):((helper(A, B, 0, A.length-1, 0, B.length-1, (A.length + B.length)/2 )) + helper(A, B, 0, A.length-1, 0, B.length-1, (A.length + B.length)/2 + 1))/2;
    }
    
    public double helper(int[] A, int[] B, int startA, int endA, int startB, int endB, int k){
        int lenA = endA - startA + 1;
        int lenB = endB - startB + 1;
        if(lenA > lenB) return helper(B, A, startB, endB, startA, endA, k);
        if(lenA == 0) return B[startB + k - 1];
        if(lenB == 0) return A[startA + k - 1];
        if(k == 1) return Math.min(A[startA], B[startB]);
        int posA = Math.min(k/2, lenA);
        int posB = k - posA;
        if(A[startA + posA -1] == B[startB + posB -1]) return A[startA + posA -1];
        if(A[startA + posA -1] < B[startB + posB -1]) return helper(A, B, posA+startA, endA, startB, posB+startB-1, k - posA);
        else return helper(A, B, startA, posA + startA -1, startB + posB, endB, k - posB);
        
    }

```

Here is the python code for this problem. We defined two extra functions: `median()` will find the median from *one* given array. `shrink()` will get two shrinked arrays, while one is from the left side and the other is the right side from the given arrays. Because either array may contains the median with exactly the middle two items in the array. So the shrinking size of array will be slightly less.

For example, for array [1,2,6,7] and [3,4,5,8]. The median of two arrays is 4.5 . `median(A)` is 4, `median(B)` is 4.5. So we will shrink the left side of A, and shrink the right side of B. So `shrink(A, B, true)` will be `[2,6,7], [3,4,5]`.

``` python
class Solution:
    def median(self, array):
        n = len(array)
        if n == 1:
            return array[0]
        elif n % 2 == 0:
            return float((array[n/2] + array[n/2 - 1])) / 2
        else:
            return array[n/2]
            
    def shrink(self, A, B, A_isleft):
        a, b = len(A), len(B)
        n = (b-1) / 2 if a > b else (a-1) / 2
        if A_isleft:
            return A[:a-n], B[n:]
        else:
            return A[n:], B[:b-n]
    
    # @return a float
    def findMedianSortedArrays(self, A, B):
        if not A and not B: raise ValueError(message="Two empty arrays")
        
        if not A:
            return self.median(B)
        
        if not B:
            return self.median(A)
            
        if len(A) <= 2 or len(B) <= 2:
            return self.median(sorted(A+B))
        
        A_isleft = self.median(A) > self.median(B)
        a, b = self.shrink(A, B, A_isleft)
        return self.findMedianSortedArrays(a, b)
```




<br>
<br>


###5 Longest Palindromic Substring
>Given a string S, find the longest palindromic substring in S. You may assume that the maximum length of S is 1000, and there exists one unique longest palindromic substring.

**Idea**:

- 1) solution1: use dp, we dp[j][i] == true represents that j...i is a parlindromic substring.
- 2) solution2: for each character s[i], we find the longest substring whose center is s[i] 

**solution1 code**

```java
     public String longestPalindrome(String s) {
        if(s == null || s.length() == 0) return s;
        boolean[][] dp = new boolean[s.length()+1][s.length() + 1];
        dp[0][0] = true;
        int max = 0;
        String res = "";
        for(int i = 0; i < s.length(); i++){
            for(int j = 0; j <= i; j++){
                if(s.charAt(i) == s.charAt(j) && (i - j <= 2 || dp[j+1][i-1])){
                    dp[j][i] = true;
                    if(i - j + 1 > max){
                        max = i-j+1;
                        res = s.substring(j, i+1);
                    }
                }
                
            }
        }
        return res;
  	}

```


**solution2 code**

```java

    public String longestPalindrome(String s) {
        if(s == null || s.length() <= 1) return s;
        int max = 0;
        String res = "";
        for(int i = 0; i < s.length(); i++){
            String mid = helper(s, i-1, i+1);
            String left =  helper(s, i-1, i);
            String right =  helper(s, i, i+1);
            String temp = mid.length() > left.length() ? mid : left;
            temp = temp.equals(mid) ? (mid.length() > right.length() ? mid : right) : (left.length() > right.length() ? left : right);
            if(temp.length() > max){
                max = temp.length();
                res = temp;
            }
        }
        return res;
  	}
  	
  	public String helper(String s, int l, int r){
  	    while(l >= 0 && r < s.length()){
  	        if(s.charAt(l) == s.charAt(r)) {
  	            l--;
  	            r++;
  	        }else{
  	            return s.substring(l+1, r);
  	        }
  	    }
  	    return s.substring(l+1, r);
  	}
  	

```

###6 Zigzag Conversion
>The string "PAYPALISHIRING" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)
<pre>

P   A   H   N
A P L S I I G
Y   I   R

</pre>
And then read line by line: "PAHNAPLSIIGYIR"
Write the code that will take a string and make this conversion given a number of rows:

string convert(string text, int nRows);
convert("PAYPALISHIRING", 3) should return "PAHNAPLSIIGYIR".


** Idea**: 

size of zigzag: 2 * nRows - 2;

index of middle element : size - i + j - i ; i is the row number, j is the starting index of each row.

**code**:

```java

    public String convert(String s, int nRows) {
        if(s == null || nRows == 1) return s;
        StringBuilder res = new StringBuilder();
        int size = nRows * 2 - 2;
        for(int i = 0; i < nRows; i++){
            for(int j = i; j < s.length(); j += size){
                res.append(s.charAt(j));
                if(i != 0 && i != nRows-1 && ((size - i + j - i) < s.length()))
                    res.append(s.charAt(size - i + j - i));
            }
        }
        return res.toString();
    }

```

<br>
<br>

###7 Reverse Integer

> Reverse digits of an integer.

>Example1: x = 123, return 321

>Example2: x = -123, return -321

**Idea**: Record the sign of the number then take abs of the number. Move the lsb to the msb each time until the number change to 0.

**Attention**: After reverse, the number might overflow, then we need to check during reverse. When overflow, we return 0;

```java
    public int reverse(int x) {
        if(x <= 9 && x >= -9) return x;
        int res = 0;
        boolean positive = x > 0 ? true : false;
        x = Math.abs(x);
        while(x > 0 && (Integer.MAX_VALUE - x % 10) / 10 >= res){
            int mod = x % 10;
            res = res * 10 + mod;
            x = x / 10;
        }
        if(x > 0) return 0;
        return positive ?  res : -res;
    }

```


***Related Questions:***

* [7 Reverse Integer](#7-reverse-integer)
* [29 Divide Two Integers](#29-divide-two-integers)
* [50 Pow](#50-pow)
* [69 Sqrt](#69-sqrt)
* [166 Fraction to Recurring Decimal](#166-fraction-to-recurring-decimal)




###8 String to Integer atoi

>Implement atoi to convert a string to an integer.

>Hint: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases.

>Notes: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front.


**Some rules**: 

1) if can not convert, return 0;

2) if value if out of range, return INT_MAX or INT_MIN

3) discard any whitespace until first non-whitespace character is found

4) takes as many characters as possible to form a valid character until encounter an unvalid

```java

	public int atoi(String str){
		if(str == null || str.length() == 0) return 0;
		str = str.trim();
		boolean positive = true;
		int result = 0;
		for(int i = 0; i < str.length(); i++){
			if(i == 0 && (str.charAt(i) == '-' || str.charAt(i) == '+')) {
				if(str.charAt(i) == '-') positive = false;
				continue;
			}
			if(!isNum(str.charAt(i))) break;
			if(result > (Integer.MAX_VALUE - ((int)str.charAt(i) - 48))/10) return positive ? Integer.MAX_VALUE: Integer.MIN_VALUE;
			result = result * 10 + ((int)str.charAt(i) - 48);
		}
		return positive ? result : -result;
	}
	
	public boolean isNum(char c){
		if(c < '0' || c > '9') return false;
		return true;
	}

```

5) python accepts integer larger than INT_MAX and integer smaller than INT_MIN, so make an if-else on that.

``` python
class Solution:
    INT_MIN = -2147483648
    INT_MAX = 2147483647

    if num < self.INT_MIN:
        return self.INT_MIN
    elif num > self.INT_MAX:
        return self.INT_MAX
```

<br>
<br>


###9 Palindrome Number

> Determine whether an integer is a palindrome. Do this without extra space.


**Idea**: Just like check if a string is a palindrom, we need to have two pointers, one from beginning and one from end. The difference is that for a integer, we can not use charAt. But we can still get the number of the two pointers use divide and mod. 


**Jave Code**

```java

    public boolean isPalindrome(int x) {
        if(x < 0) return false;
	    if(x <= 9) return true;
	    int divide = 1;
	    while((divide < Integer.MAX_VALUE/10) && (divide * 10) <= x){
	        divide *= 10;
	    }
	    while(x != 0){
	        int ms = x/divide;
	        int ls = x%10;
	        if(ms != ls) return false;
	        x = (x % divide) / 10;
	        divide  = divide / 100;
	    }
	    return true;
	}

```

<br>
<br>


###10 Regular Expression Matching


>Implement regular expression matching with support for '.' and '*'.

<pre>
'.' Matches any single character.
'*' Matches zero or more of the preceding element.

The matching should cover the entire input string (not partial).

The function prototype should be:
bool isMatch(const char *s, const char *p)

Some examples:
isMatch("aa","a") → false
isMatch("aa","aa") → true
isMatch("aaa","aa") → false
isMatch("aa", "a*") → true
isMatch("aa", ".*") → true
isMatch("ab", ".*") → true
isMatch("aab", "c*a*b") → true

</pre>

**Idea**:

-  Solution1: We divide it into two cases: 1) p[j+1] == '\*'  2)p[j+1] != '\*'. In the first case, it's a little complicated. Because * can match 0 or more characters. Thus we need to check match(s, p, i, j+2), match(s, p, i+1, j+2)....... In the second case we just need to compare s[i] and p[j], if s[i] == p[j] or p[j] == '.', we continue to compare(s, p, i+1, j+1).


**Solution1 code**:

```java

	public boolean isMatch(String s, String p) {
        if((s == null && p == null) || p.equals(".*")) return true;
        return helper(s, p, 0, 0);
    }
    public boolean helper(String s, String p, int i, int j){
        if(j == p.length()) return i == s.length();
         if(j+1 == p.length() || p.charAt(j+1) != '*'){
            if(i < s.length() && (s.charAt(i) == p.charAt(j) || p.charAt(j) == '.')) return helper(s, p, i+1, j+1);
            else return false;
         }
         while(i < s.length() && (p.charAt(j) == '.' || p.charAt(j) == s.charAt(i))){
             if(helper(s, p, i++, j+2)) return true;
         }
         return helper(s, p, i, j+2);
    }
```


**Solution2**:

```java
    public boolean isMatch(String s, String p) {
        if((s == null && p == null) || p.equals(".*")) return true;
        boolean[][] dp = new boolean[s.length()+1][p.length()+1];
        dp[0][0] = true;
        for(int i = 2; i <= p.length(); i++){
            if(p.charAt(i-1) == '*') dp[0][i] = dp[0][i-2];
        }
        for(int i = 1; i <= s.length(); i++){
            for(int j = 1; j <= p.length(); j++){
                if(p.charAt(j-1) != '*'){
                    if(s.charAt(i-1) == p.charAt(j-1) || p.charAt(j-1) == '.') dp[i][j] = dp[i-1][j-1];
                }else{
                   if(j > 1 && (s.charAt(i-1) == p.charAt(j-2) || p.charAt(j-2) == '.'))
                         dp[i][j] = dp[i][j-2] || dp[i-1][j];
                   else dp[i][j] = dp[i][j-2];
                }
            }
        }
        return dp[s.length()][p.length()];
     }

```


***Related Problem***:

* [10 Regular Expression Matching](#10-regular-expression-matching)
* [44 Wildcard Matching](#44-wildcard-matching)
 

<br>
<br>

###11 Container with Most Water

>Given n non-negative integers a1, a2, ..., an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.
Note: You may not slant the container.

**Idea**: Thea easiest way we can do is brute force. We calcuate the possible value with element with all the values after it. The time complexity is O(n^2). Have have another efficient way. We set a window, l = 0, r = size -1. Each time we calculate the container of l r, then we compare the height[l] and height[r]. if(height[l] > height[r]), r--. Because we know that height[l] > height[r], if we move l pointer, then the volumn would decrease.


```java

    public int maxArea(int[] height) {
    	if(height == null || height.length == 0) return 0;
    	int left = 0;
    	int right = height.length-1;
    	int max = 0;
    	while(left < right){
    		max = Math.max(max, Math.min(height[left], height[right]) * (right-left));
    		if(height[right] > height[left]) left++;
    		else right--;
    	}
    	return max;
    }


```



***Related***:

* [11 Container with Most Water](#11-container-with-most-water)
* [42 Trapping Rain Water](#42-trapping-rain-water)
* [135 Candy](#135-candy)

<br>
<br>

###12 Integer to Roman

>Given an integer, convert it to a roman numeral.

>Input is guaranteed to be within the range from 1 to 3999.


**Some rules about Roman**:

*Numbers*:

- I : 1
- V : 5
- X : 10
- L : 50
- C : 100
- D : 500
- M : 1000


*specific rules*: 

- When a larger number add some smaller numbers on its right side: larger + smaller
- when a larger number add some smaller numbers on its left side : larger - smaller
- when add a line on top of roman number, it means the number * 1000
- The same roman code can repeat at most three times eg: XL: 40, we cannot write it as XXXX


**Some Example**:

- I : 1
- II : 2
- III : 3
- IV : 4
- V : 5
- VI : 6
- VII: 7
- VIII : 8
- IX : 9
- X: 10
- XI : 11
- ......
- XC: 90
- CD : 400
- DCCC: 800
- .....

**Idea**:

- 1) Solution1: The most straight forward way is we add the value of each character. There are two cases to consider. 1. character I 2. character V, X....... For the first case, we just need to add I to the result. For the second case, we need to check if there are smaller characters before it. For example IV if 4, we need first add 1 then add 5 -2.

- 2)  Solution2 : We add a map for each pair. These additional space can help make our code more concisely.

**Solution1 code**:

```java
    public int romanToInt1(String s) {
        if(s == null || s.length() == 0) return 0;
        int res = 0;
        for(int i = 0; i < s.length(); i++){
            char c = s.charAt(i);
            if(c == 'I') res += 1;
            else if( c == 'V'){
                if(i > 0 && s.charAt(i-1) == 'I') res += 3;
                else res += 5;
            }else if(c == 'X'){
                if(i > 0 && s.charAt(i-1) == 'I') res += 8;
                else res += 10;
            }else if(c == 'L'){
                if(i > 0 && s.charAt(i-1) == 'X') res += 30;
                else res += 50;
            }else if(c == 'C'){
                if(i > 0 && s.charAt(i-1) == 'X') res += 80;
                else res += 100;
            }else if(c == 'D'){
                if(i > 0 && s.charAt(i-1) == 'C') res += 300;
                else res += 500;
            }else if (c == 'M'){
                if(i > 0 && s.charAt(i-1) == 'C') res += 800;
                else res += 1000;
            }
        }
        return res;
    }

```


**Solution2 code**: Use hashmap

```java

    public int romanToInt(String s) {
        if(s == null || s.length() == 0) return 0;
        int res = 0;
        Map<Character, Integer> map = new HashMap<Character, Integer>();
        map.put('I', 1);
        map.put('V', 5);
        map.put('X', 10);
        map.put('L', 50);
        map.put('C', 100);
        map.put('D', 500);
        map.put('M', 1000);
        for(int i = 0; i < s.length(); i++){
            char c = s.charAt(i);
            if(c == 'I') {
                res += map.get(c);
                continue;
            }
            if(i > 0 && map.get(s.charAt(i-1)) < map.get(c)) res = res + map.get(c) - 2 * map.get(s.charAt(i-1));
            else res += map.get(c);
        }
        return res;
    }

```



***Related Problem***:

* [12 Integer to Roman](#12-integer-to-roman)
* [13 Roman to Integer](#13-roman-to-integer)

<br>

<br>


###13 Roman to Integer 

**Rules**:

See detailed rules at [12 Integer to Roman](#12-integer-to-roman)

**Idea**: Just calculate each digit and append it to result string.

**Code**:

```java
    public String intToRoman1(int num) {
        if(num <= 0 || num >= 4000) return "";
        int divide = 1000;
        int[] digits = new int[4];
        StringBuilder res = new StringBuilder();
        for(int i = 3; i >= 0 && num > 0; i--){
            digits[i] = num/divide;
            num = num % divide;
            divide /= 10;
        }
        res.append(helper(digits[3], 'M', ' ', ' '));
        res.append(helper(digits[2], 'C', 'D', 'M'));
        res.append(helper(digits[1], 'X', 'L', 'C'));
        res.append(helper(digits[0], 'I', 'V', 'X'));
        return res.toString();
    }
    
    public String helper(int i, char one, char five, char ten){
        StringBuilder res = new StringBuilder();
        switch(i){
            case 9: res.append(one + "" + ten); break;
            case 8: res.append(five + "" + one + "" + one + "" + one); break;
            case 7: res.append(five + "" + one + "" + one); break;
            case 6: res.append(five + "" + one); break;
            case 5: res.append(five); break;
            case 4: res.append(one + "" + five); break;
            case 3: res.append(one + "" + one + "" + one); break;
            case 2: res.append(one + "" + one); break;
            case 1: res.append(one);
        }
        return res.toString();
    }
```


**Better code on appending part**:

```java

    public String intToRoman(int num) {
    	if(num <= 0 || num >= 4000) return "";
    	int divide = 1000;
    	int[] digits = new int[4];
    	for(int i = 3; i >= 0 && num > 0; i--){
             digits[i] = num/divide;
             num = num % divide;
             divide /= 10;
         }
    	StringBuilder result = new StringBuilder();
    	result.append(convert(digits[3], 'M', ' ', ' '));
    	result.append(convert(digits[2], 'C', 'D', 'M'));
    	result.append(convert(digits[1], 'X', 'L', 'C'));
    	result.append(convert(digits[0], 'I', 'V', 'X'));
        
    	return result.toString();
    }
    
    public String convert(int digit, char one, char five, char ten){
    	StringBuilder result = new StringBuilder();
    	switch(digit)
    	{
    		case 9:
    			result.append(one);
    			result.append(ten);
    			break;
    		case 8:
    		case 7:
    		case 6:
    		case 5:
    			result.append(five);
    			for(int i = 5; i < digit; i++) result.append(one);
    			break;
    		case 4: 
    			result.append(one);
    			result.append(five);
    			break;
    		case 3:
    		case 2:
    		case 1:
    			for(int i = 0; i < digit; i++) result.append(one);
    			break;
    		default:
    			break;
    	}
    	return result.toString();
    }

```
***Related Problem***:

* [12 Integer to Roman](#12-integer-to-roman)
* [13 Roman to Integer](#13-roman-to-integer)

<br>

<br>

###14 Longest Common Prefix

> Write a function to find the longest common prefix string amongst an array of strings.

**Idea**: Choose the first string, then compare each of its character with the strings in strs. Return result when a mismatch happens.

**Time complexity**: O(n * m), n is the length of prefix string. M is the length of strs. 


**Java code**:


```java

    public String longestCommonPrefix(String[] strs) {
        if(strs == null || strs.length == 0) return "";
        StringBuilder res = new StringBuilder();
        String s = strs[0];
        for(int i = 0; i < s.length(); i++){
            char c = s.charAt(i);
            for(int j= 1; j < strs.length; j++){
                if((i < strs[j].length() && c != strs[j].charAt(i)) || i >= strs[j].length()) return res.toString();
            }
            res.append(c);
        }
        return res.toString();
    }


```


<br>

<br>


###15 3Sum

>Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.

>Note:

- Elements in a triplet (a,b,c) must be in **non-descending order**. (ie, a ≤ b ≤ c)

- The solution set **must not contain duplicate triplets**.
    
    
    
  		For example, given array S = {-1 0 1 2 -1 -4},
    	A solution set is:
    	(-1, 0, 1)
    	(-1, -1, 2)
    
**Idea**: We need to find the three numbers triplets that sum to 0. We can change to this problem to two subproblems. Target + (-target) = 0, num1 + num2 = - target.
Thus we can use the method in two sum to solve this problem. For each number num1 in the array, we find the other two numbers that sum to -num1. 

We first need to sort the array, then use two pointers to find the two sum numbers sum to -num1.

**Time** O(n ^ 2)

**Space** O(n ^ 2)

**Attention**: 

1) Silly check: num is null or num's length less than 3

2) *Duplication*: Both the threeSum and twoSum helper function need to check the duplication. If just need to check if the current is equal to the number before it. 

3) Non-descending order

```java
    public List<List<Integer>> threeSum(int[] num) {
        List<List<Integer>> list = new ArrayList<List<Integer>>();
        if(num == null || num.length < 3) return list;
        Arrays.sort(num);
        for(int i = 0; i <= num.length - 3; i++){
            if(i != 0 && num[i] == num[i-1]) continue;
            List<List<Integer>> current = twoSum(num, i+1, -num[i]);
            if(current.size() > 0){
                for(List<Integer> l : current ){
                    l.add(0, num[i]);
                }
                list.addAll(current);
            }
        }
        return list;
    }
    
    public List<List<Integer>> twoSum(int[] num, int start, int target){
        int r = num.length -1;
        List<List<Integer>> list = new ArrayList<List<Integer>>();
        int l = start;
        while(l < r){
            if(target == num[l] + num[r]){
                List<Integer> cur = new ArrayList<Integer>();
                cur.add(num[l]);
                cur.add(num[r]);
                list.add(cur);
                l++;
                r--;
                while(l < r && num[l] == num[l-1]) l++;
                while(l < r && num[r] == num[r+1]) r--;
            }else if(target < num[l] + num[r])
                r--;
            else l++;
        }
        return list;
    }
   
```

Related problem: 

* [1 Two Sum](#1-two-sum)
* [15 3Sum](#15-3sum)
* [16 3Sum Closest](#16-3sum-closest)
* [18 4Sum](#18-4sum)
* [167 Two Sum II Input array is sorted](#167-two-sum-ii-input-array-is-sorted)
* [170 Two Sum III Data Structure Design](#170-two-sum-iii-data-structure-design)

<br>
<br>


###16 3Sum Closest


>Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. **You may assume that each input would have exactly one solution**.

    For example, given array S = {-1 2 1 -4}, and target = 1.

    The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).
    
**Idea**: It's much similar with the method in three sum, the only difference here is that we calculate the minimum difference use the twosum helper funtion for each item in the array. 

**Attention**: 

1) Each time we compare the **abs** of the difference 

**Time** O(n ^ 2)

**Space** O(1)

```java
    public int threeSumClosest(int[] num, int target) {
	    if(num == null || num.length == 0) return 0;
	    int res = Integer.MAX_VALUE;
	    Arrays.sort(num);
	    for(int i = 0; i <= num.length -3; i++){
	        if(i != 0 && num[i] == num[i-1]) continue;
	        int dif = twoSumClosest(num, i + 1, target-num[i]);
	        if(Math.abs(dif) < Math.abs(res)) res = dif;
	    }
	    return res+target;
	}
	
	public int twoSumClosest(int[] num, int start, int target){
	    int r = num.length - 1;
	    int l = start;
	    int res = Integer.MAX_VALUE;
	    while(l < r){
	        if(Math.abs(num[l] + num[r] - target) < Math.abs(res))
	            res = num[l] + num[r] - target;
	        if(num[l] + num[r] == target)
	            return 0;
	        else if(num[l] + num[r] > target)
	            r--;
	        else 
	            l++;
	        
	    }
	    return res;
	}
	
```
* [1 Two Sum](#1-two-sum)
* [15 3Sum](#15-3sum)
* [16 3Sum Closest](#16-3sum-closest)
* [18 4Sum](#18-4sum)
* [167 Two Sum II Input array is sorted](#167-two-sum-ii-input-array-is-sorted)
* [170 Two Sum III Data Structure Design](#170-two-sum-iii-data-structure-design)

<br>
<br>



###17 Number Combinations of a Phone Number

>  Given a digit string, return all possible letter combinations that the number could represent.

> A mapping of digit to letters (just like on the telephone buttons) is given below.

<pre>

Input:Digit string "23"
Output: ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].

</pre>

> Note:

> Although the above answer is in lexicographical order, your answer could be in any order you want.


**Idea**: This problem is much similar to calculate the combinations. Each time we add each character of a string to all existing strings in the set. Then we go to the next String.

**Time Complexity** : O(k ^ n), k is possible choice of each digit, n is the length of digits


```java

    public List<String> letterCombinations(String digits) {
        List<String> res = new ArrayList<String>();
        if(digits == null || digits.length() == 0) return res;
        for(int i = 0; i < digits.length(); i++){
            String cur = getLetters(digits.charAt(i));
            List<String> temp = new ArrayList<String>();
            if(res.size() == 0){
                for(int j = 0; j < cur.length(); j++){
                    res.add(cur.charAt(j) + "");
                }
            }else{
                for(String s : res){
                    for(int k = 0; k < cur.length(); k++){
                        temp.add(s + cur.charAt(k));
                    }
                }
                res = temp;      
            }
        }
        return res;
        
    }
    
    public String getLetters(char digit){
        switch(digit){
            case '9' : return "wxyz";
            case '8' : return "tuv";
            case '7' : return "pqrs";
            case '6' : return "mno";
            case '5' : return "jkl";
            case '4' : return "ghi";
            case '3' : return "def";
         case '2' : return "abc";
            default: return "";
        }
    }

```

<br>

<br>

###18 4Sum

>Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.

>Note:

- Elements in a quadruplet (a,b,c,d) must be in **non-descending order**. (ie, a ≤ b ≤ c ≤ d)

- The solution set must **not contain duplicate quadruplets**.
 
 
 For example, given array S = {1 0 -1 0 -2 2}, and target = 0.

        A solution set is:
   	    (-1,  0, 0, 1)
        (-2, -1, 1, 2)
        (-2,  0, 0, 2)
    
<br>

**Idea**: Use the 3Sum to calculate 4Sum. 

**Time** O(n ^ 3)

**Space** O(n ^ 2)
```java
    public List<List<Integer>> fourSum(int[] num, int target) {
        List<List<Integer>> list = new ArrayList<List<Integer>>();
        if(num == null || num.length <= 3) return list;
        Arrays.sort(num);
        for(int i = 0; i <= num.length - 4; i++){
            if(i != 0 && num[i] == num[i-1]) continue;
            List<List<Integer>> current = threeSum(num, i+1, target - num[i]);
            for(List<Integer> l : current){
                l.add(0, num[i]);
            }
            list.addAll(current);
        }
        return list;
    }
    
    public List<List<Integer>> threeSum(int[] num, int start, int target){
         List<List<Integer>> list = new ArrayList<List<Integer>>();
         for(int i = start; i <= num.length - 3; i++){
             if(i != start && num[i] == num[i-1]) continue;
             List<List<Integer>> current = twoSum(num, i+1, target - num[i]);
              for(List<Integer> l : current){
                l.add(0, num[i]);
            }
            list.addAll(current);
         }
         return list;
    }
    
    public List<List<Integer>> twoSum(int[] num, int start, int target){
         List<List<Integer>> list = new ArrayList<List<Integer>>();
         int r = num.length -1;
         int l = start;
         while(l < r){
             if(num[l] + num[r] == target){
                 List<Integer> cur = new ArrayList<Integer>();
                 cur.add(num[l]);
                 cur.add(num[r]);
                 list.add(cur);
                 l++;
                 r--;
                 while(l < r && num[l] == num[l-1]) l++;
                 while(l < r && num[r] == num[r+1]) r--;
             }else if(num[l] + num[r] < target) l++;
             else r--;
         }
         return list;
    }
 
``` 
 
 **Other Idea**: 
 
 we can twoSum combine twoSum to calculate 4Sum. Time complexity would be O(n^2 * lgn)
 

    

* [1 Two Sum](#1-two-sum)
* [15 3Sum](#15-3sum)
* [16 3Sum Closest](#16-3sum-closest)
* [18 4Sum](#18-4sum)
* [167 Two Sum II Input array is sorted](#167-two-sum-ii-input-array-is-sorted)
* [170 Two Sum III Data Structure Design](#170-two-sum-iii-data-structure-design)

<br>
<br>



###19 Remove Nth Node From End of List
>Given a linked list, remove the nth node from the end of list and return its head.

For example,

   Given linked list: 1->2->3->4->5, and n = 2.

After removing the second node from the end, the linked list becomes 1->2->3->5.
Note:

Given n will always be valid.
Try to do this in one pass.

**Idea**: Use two pointers, p1, p2. First move p1 k steps, then move p1 and p2 together until p1 change to null. At this time, p2 points to the node we need to delete. 

**Attention**: 

- 1) if after k steps, p1 is null, then return head.next
- 2) record pre

<br>
```java
    public ListNode removeNthFromEnd(ListNode head, int n) {
    	if(head == null) return null;
    	ListNode l1 = head;
    	ListNode l2 = head;
    	while(n > 0){
    	    l1 = l1.next;
    	    n--;
    	}
    	if(l1 == null) return head.next;
    	ListNode pre = null;
    	while(l1 != null){
    	    pre = l2;
    	    l2 = l2.next;
    	    l1 = l1.next;
    	}
    	pre.next = l2.next;
    	return head;
    }

```
***Related problems***:

* [19 Remove Nth Node From End of List](#19-remove-nth-node-from-end-of-list)
* [21 Merge Two Sorted Lists](#21-merge-two-sorted-lists)
* [23 Merge k Sorted Lists](#23-merge-k-sorted-lists)
* [24 Swap Nodes in Pairs](#24-swap-nodes-in-pairs)
* [61 Rotate List](#61-rotate-list)
* [82 Remove Duplicates from Sorted List](#82-remove-duplicates-from-sorted-list)
* [83 Remove Duplicates from Sorted List II](#83-remove-duplicates-from-sorted-list-ii)
* [92 Reverse Linked List II](#92-reverse-linked-list-ii)
* [108 Convert Sorted Array to Binary Search Tree](#108-convert-sorted-array-to-binary-search-tree)
* [109 Convert Sorted List to Binary Search Tree](#109-convert-sorted-list-to-binary-search-tree)
* [114 Flatten Binary Tree to Linked List](#114-flatten-binary-tree-to-linked-list)
* [138 Copy List With Random Pointer](#138-copy-list-with-random-pointer)
* [141 Linked List Cycle](#141-linked-list-cycle)
* [142 Linked List Cycle II](#142-linked-list-cycle-ii)
* [143 Reorder List](#143-reorder-list)
* [147 Insertion Sort List](#147-insertion-sort-list)
* [148 Sort List](#148-sort-list)
* [160 Intersection of Two Linked Lists](#160-intersection-of-two-linked-lists)

<br>
<br>

###20 Valid Parentheses

> Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.

> The brackets must close in the correct order, "()" and "()[]{}" are all valid but "(]" and "([)]" are not.


**Idea**: Use a stack to record parentheses. When encounter ( , [, { push to stack.
when encounter ), ], } pop corresponding parentheses.


**Java code**:


```java


    public boolean isValid(String s) {
        if(s == null || s.length() == 0) return true;
        Stack<Character> stack = new Stack<Character>();
        for(int i = 0; i < s.length(); i++){
            char c = s.charAt(i);
            if(stack.isEmpty() && (c == ')' || c == ']' || c == '}')) return false;
            if(c == '(' || c == '[' || c == '{') stack.push(c);
            else if(c == ')' || c == ']' || c == '}'){
                if((c == ')' && stack.peek() != '(') || (c == ']' && stack.peek() != '[') || (c == '}' && stack.peek() != '{')) 
                    return false;
                else stack.pop();
            }
        }
        return stack.isEmpty();
    }


```



<br>


<br>



###21 Merge Two Sorted Lists

> Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.

**Attention**:

- 1) Use a fake head, thus we don't need to check if head is null


```java
       public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
	    if(l1 == null) return l2;
	    if(l2 == null) return l1;
	    ListNode fakeHead = new ListNode(-1);
	    ListNode temp = fakeHead;
	    while(l1 != null && l2 != null){
	        if(l1.val > l2.val){
	            temp.next = l2;
	            l2 = l2.next;
	        }else{
	            temp.next = l1;
	            l1 = l1.next;
	        }
	        temp = temp.next;
	    }
	    if(l1 != null) temp.next = l1;
	    if(l2 != null) temp.next = l2;
	    return fakeHead.next;
    }  
```

***Related problems***:

* [19 Remove Nth Node From End of List](#19-remove-nth-node-from-end-of-list)
* [21 Merge Two Sorted Lists](#21-merge-two-sorted-lists)
* [23 Merge k Sorted Lists](#23-merge-k-sorted-lists)
* [24 Swap Nodes in Pairs](#24-swap-nodes-in-pairs)
* [61 Rotate List](#61-rotate-list)
* [82 Remove Duplicates from Sorted List](#82-remove-duplicates-from-sorted-list)
* [83 Remove Duplicates from Sorted List II](#83-remove-duplicates-from-sorted-list-ii)
* [92 Reverse Linked List II](#92-reverse-linked-list-ii)
* [108 Convert Sorted Array to Binary Search Tree](#108-convert-sorted-array-to-binary-search-tree)
* [109 Convert Sorted List to Binary Search Tree](#109-convert-sorted-list-to-binary-search-tree)
* [114 Flatten Binary Tree to Linked List](#114-flatten-binary-tree-to-linked-list)
* [138 Copy List With Random Pointer](#138-copy-list-with-random-pointer)
* [141 Linked List Cycle](#141-linked-list-cycle)
* [142 Linked List Cycle II](#142-linked-list-cycle-ii)
* [143 Reorder List](#143-reorder-list)
* [147 Insertion Sort List](#147-insertion-sort-list)
* [148 Sort List](#148-sort-list)
* [160 Intersection of Two Linked Lists](#160-intersection-of-two-linked-lists)

<br>
<br>


###22 Generate Parentheses

> Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.

> For example, given n = 3, a solution set is:

> "((()))", "(()())", "(())()", "()(())", "()()()"

**Idea**: insert "\(\)" to possible spots of every parentheses string. eg : (), we have three spaces to insert. Inspite of duplicates, there are two possible ()() or (()). 

**Iterative code **:

```java
    public List<String> generateParenthesis(int n) {
        List<String> res = new ArrayList<String>();
        res.add("");
        if(n <= 0) return res;
        for(int i = 0; i < n; i++){
            List<String> cur = new ArrayList<String>();
            for(String s : res){
                for(int j = 0; j <= s.length(); j++){
                    String temp =  s.substring(0, j) + "()" + s.substring(j, s.length());
                    if(!cur.contains(temp)) cur.add(temp);
                }
            }
            res = cur;
        }
        return res;
    }

```


**Recursion**:

```java

    public List<String> generateParenthesis1(int n) {
    	List<String> list = new ArrayList<String>();
    	if(n == 0){
    		list.add("");
    		return list;
    	}else if (n == 1){
    		list.add("()");
    		return list;
    	}
    	
    	return helper(n);
    	
    }
    
    public List<String> helper(int n){
    	if(n == 0){
    		List<String> list = new ArrayList<String>();
    		list.add("");
    		return list;
    	}
    	List<String> list  = helper(n-1);
    	List<String> result = new ArrayList<String>();
    	for(String s : list){
    		for(int i = 0, len = s.length(); i <= len; i++){
    			String newS = s.substring(0, i) + "()" + s.substring(i, s.length());
    			if(!result.contains(newS)) result.add(newS);
    		}
    	}
    	return result;
    }

```

<br>

<br>


###23 Merge k Sorted Lists

> Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.

**Idea**:

1) Solution1:

Use priorityqueue, add the head of k lists two queue, each time poll the smallest element from the queue then add the smallest.next to the queue until queue is empty. We need to to give another another parameter to priorityqueue when initialize.

```java

	PriorityQueue queue = new PriorityQueue(size, new Comparator<ListNode>(){
		public int compare(ListNode arg1, ListNode arg2){
			return arg1 - arg2;
		}
	});
	
```	


**Time complexity: nklgk** (lgk for insert element, nk elements).

**Space** O(k)

2) Solution2:

Use the idea in merge sort and use the method in [21 Merge Two Sorted Lists](#21-merge-two-sorted-lists) to merge two elements.

**Time**: O(knlgk)

**Solution1 code**:

<br>
```java
    public static ListNode mergeKLists(List<ListNode> lists){
        if(lists == null || lists.size() == 0) return null;
        ListNode res = new ListNode(-1);
        ListNode h1 = res;
        PriorityQueue<ListNode> queue = new PriorityQueue<ListNode>(lists.size(),new Comparator<ListNode>(){
            public int compare(ListNode l1, ListNode l2){
                return l1.val - l2.val;
            }
        });
        for(ListNode l : lists){
            if(l != null) queue.add(l);
        }
        while(!queue.isEmpty()){
            ListNode current = queue.poll();
            h1.next = current;
            h1 = h1.next;
            if(current.next != null)
                queue.offer(current.next);
        }
        return res.next;
	}
```

**Solution 2 code**
```java
	public  ListNode mergeKLists1(List<ListNode> lists){
		  if(lists == null || lists.size() == 0) return null;
		  return helper(lists, 0, lists.size()-1);
		}
		public ListNode helper(List<ListNode> lists, int start, int end){
		    if(start >= end) return lists.get(start);
		    int mid = (start + end)/2;
		    return mergeTwoLists(helper(lists, start, mid), helper(lists, mid+1, end));
		}
		
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
	    if(l1 == null) return l2;
	    if(l2 == null) return l1;
	    ListNode fakeHead = new ListNode(-1);
	    ListNode temp = fakeHead;
	    while(l1 != null && l2 != null){
	        if(l1.val > l2.val){
	            temp.next = l2;
	            l2 = l2.next;
	        }else{
	            temp.next = l1;
	            l1 = l1.next;
	        }
	        temp = temp.next;
	    }
	    if(l1 != null) temp.next = l1;
	    if(l2 != null) temp.next = l2;
	    return fakeHead.next;
    }
```

**Brute force** time limit exceeded

```java
method1: each time find the minimum from the k nodes, and add it to the result list. Time k * n * k = O(k^2*n)

	 /* Brute force: time limit exceeded*/
		public  ListNode mergeKLists2(List<ListNode> lists){
		    if(lists == null || lists.size() == 0) return null;
		    ListNode head = new ListNode(-1);
		    ListNode temp = head;
		    List<ListNode> l = new ArrayList<ListNode>();
		    for(int i = 0; i < lists.size(); i++){
		        if(lists.get(i) != null) l.add(lists.get(i));
		    }
		    while(l.size() > 0){
		    	int min = 0;
		        for(int i = 0; i < l.size(); i++){
		            if(l.get(i) == null) l.remove(i);
		            else {
		            	if(l.get(i).val < l.get(min).val) min = i;
		            }
		        }
		        if(l.size() > 0){
		        	temp.next = l.get(min);
		        	if(l.get(min).next != null) l.set(min,l.get(min).next);
		        	else l.remove(min);
		        	temp = temp.next;
		        }
		    }
		    return head.next;
		}
	
```

method2: each time merge two lists, until all lists are merged.
```java
	/*Brute force, use merge2 method */
	public  ListNode mergeKLists3(List<ListNode> lists) {
		if( lists == null || lists.size() == 0) return null;
		ListNode result = lists.get(0);
		for(int i = 1; i < lists.size(); i++){
			ListNode currentList = lists.get(i);
			result = mergeTwoLists(result, currentList);

		}
		
		return result;
	}

```

***Related problems***:

* [19 Remove Nth Node From End of List](#19-remove-nth-node-from-end-of-list)
* [21 Merge Two Sorted Lists](#21-merge-two-sorted-lists)
* [23 Merge k Sorted Lists](#23-merge-k-sorted-lists)
* [24 Swap Nodes in Pairs](#24-swap-nodes-in-pairs)
* [61 Rotate List](#61-rotate-list)
* [82 Remove Duplicates from Sorted List](#82-remove-duplicates-from-sorted-list)
* [83 Remove Duplicates from Sorted List II](#83-remove-duplicates-from-sorted-list-ii)
* [92 Reverse Linked List II](#92-reverse-linked-list-ii)
* [108 Convert Sorted Array to Binary Search Tree](#108-convert-sorted-array-to-binary-search-tree)
* [109 Convert Sorted List to Binary Search Tree](#109-convert-sorted-list-to-binary-search-tree)
* [114 Flatten Binary Tree to Linked List](#114-flatten-binary-tree-to-linked-list)
* [138 Copy List With Random Pointer](#138-copy-list-with-random-pointer)
* [141 Linked List Cycle](#141-linked-list-cycle)
* [142 Linked List Cycle II](#142-linked-list-cycle-ii)
* [143 Reorder List](#143-reorder-list)
* [147 Insertion Sort List](#147-insertion-sort-list)
* [148 Sort List](#148-sort-list)
* [160 Intersection of Two Linked Lists](#160-intersection-of-two-linked-lists)

<br>
<br>


###24 Swap Nodes in Pairs

>Given a linked list, swap every two adjacent nodes and return its head.

For example,
Given 1->2->3->4, you should return the list as 2->1->4->3.

Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed.

**Idea**: Just swap pair each time until end. 

**Attention**: If the number of nodes is odd, we need to add the last node to the list.

```java
   public ListNode swapPairs(ListNode head) {
	    if(head == null || head.next == null) return head;
	    ListNode fakeHead = new ListNode(-1);
	    ListNode temp = fakeHead;
	    while(head != null && head.next != null){
	        ListNode nextnext = head.next.next;
	        temp.next = head.next;
	        temp.next.next = head;
	        temp = head;
	        head = nextnext;
	    }
	    temp.next = head;
	    return fakeHead.next;
	  }
```


***Related problems***:

* [19 Remove Nth Node From End of List](#19-remove-nth-node-from-end-of-list)
* [21 Merge Two Sorted Lists](#21-merge-two-sorted-lists)
* [23 Merge k Sorted Lists](#23-merge-k-sorted-lists)
* [24 Swap Nodes in Pairs](#24-swap-nodes-in-pairs)
* [61 Rotate List](#61-rotate-list)
* [82 Remove Duplicates from Sorted List](#82-remove-duplicates-from-sorted-list)
* [83 Remove Duplicates from Sorted List II](#83-remove-duplicates-from-sorted-list-ii)
* [92 Reverse Linked List II](#92-reverse-linked-list-ii)
* [108 Convert Sorted Array to Binary Search Tree](#108-convert-sorted-array-to-binary-search-tree)
* [109 Convert Sorted List to Binary Search Tree](#109-convert-sorted-list-to-binary-search-tree)
* [114 Flatten Binary Tree to Linked List](#114-flatten-binary-tree-to-linked-list)
* [138 Copy List With Random Pointer](#138-copy-list-with-random-pointer)
* [141 Linked List Cycle](#141-linked-list-cycle)
* [142 Linked List Cycle II](#142-linked-list-cycle-ii)
* [143 Reorder List](#143-reorder-list)
* [147 Insertion Sort List](#147-insertion-sort-list)
* [148 Sort List](#148-sort-list)
* [160 Intersection of Two Linked Lists](#160-intersection-of-two-linked-lists)

<br>
<br>


###25 Reverse Nodes in kGroup

> Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.
>
>If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.
>
>You may not alter the values in the nodes, only nodes itself may be changed.
>
>Only constant memory is allowed.
>

>For example,

>Given this linked list: 1->2->3->4->5

>For k = 2, you should return: 2->1->4->3->5

>For k = 3, you should return: 3->2->1->4->5r



**Idea**: Reverse k nodes each time then catenenate the current reverse list with the previous reverse list.


**Attention**:

- 1)the left-out nodes less than k nodes should remain the same.
- 2)For the first node of each reverse list, we should set it's next to null to avoid cycle or double linked list. 



```java

    public ListNode reverseKGroup(ListNode head, int k) {
        if(head == null || head.next == null || k <= 1) return head;
        int len = 0;
        ListNode temp = head;
        while(temp != null){
            len++;
            temp = temp.next;
        }
        if(k > len) return head;
        ListNode res = null, cur = null, pre = null, next = null, savehead = null;
        for(int i = 1; i <= len && i + k <= len+1; i += k){
            savehead = head;
            for(int j = 1; j <= k; j++){
                next = head.next;
                if(cur == null) {
                    cur = head;
                    cur.next = null;
                }else{
                    head.next = cur;
                    cur = head;
                }
                head = next;
            }
            if(res == null) res = cur;
            else{
                pre.next = cur;
            }
            pre = savehead;
            cur = null;
        }
        
        if(head != null) pre.next = head;
        return res;
    }

```



<br>

<br>



### 26 Remove Duplicates from Sorted Array

>Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.
>
>Do not allocate extra space for another array, you must do this in place with constant memory.
>
>For example,
>
>Given input array A = [1,1,2],
>
>Your function should return length = 2, and A is now [1,2].

**Idea**: Record an index, all element before this index contains no duplicates. Insert the new unduplicate element at index. 


**Java code**:

```java

    public int removeDuplicates(int[] A) {
        if(A == null) return 0;
        if(A.length <= 1) return A.length;
        int count = 1;
        int pre = A[0];
        for(int i = 1; i < A.length; i++){
            if(A[i] == pre) continue;
            A[count++] = A[i];
            pre = A[i];
        }
        return count;
    }

```


***Related Problems***:

* [26 Remove Duplicates from Sorted Array](#26-remove-duplicates-from-sorted-array)
* [27 Remove Element](#27-remove-element)
* [80 Remove Duplicates from Sorted Array II](#80-remove-duplicates-from-sorted-array)
* [82 Remove Duplicates from Sorted List](#82-remove-duplicates-from-sorted-list)
* [83 Remove Duplicates from Sorted List II](#83-remove-duplicates-from-sorted-list-ii)


<br>

<br>


###27 Remove Element

>Given an array and a value, remove all instances of that value in place and return the new length.

>The order of elements can be changed. It doesn't matter what you leave beyond the new length

**Idea**: if A[i] != elem, copy element to record index. 

**Java Code**:


```java

    public int removeElement(int[] A, int elem) {
        if(A == null || A.length == 0) return 0;
        int count = 0;
        for(int i = 0; i < A.length; i++){
            if(A[i] == elem) continue;
            A[count++] = A[i];
        }
        return count;
    }


```



***Related Problems***:

* [26 Remove Duplicates from Sorted Array](#26-remove-duplicates-from-sorted-array)
* [27 Remove Element](#27-remove-element)
* [80 Remove Duplicates from Sorted Array II](#80-remove-duplicates-from-sorted-array)
* [82 Remove Duplicates from Sorted List](#82-remove-duplicates-from-sorted-list)
* [83 Remove Duplicates from Sorted List II](#83-remove-duplicates-from-sorted-list-ii)


<br>

<br>


###28 Implement strStr

> Implement strStr().
>
>Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.
>
>Update (2014-11-02):

>The signature of the function had been updated to return the index instead of the pointer. If you still see your function signature returns a char * or String, please click the reload button  to reset your code definition.

**Idea**: It asks us to implement a function like indexOf(string) in java. The easiest way is a O(n^2) solution, just like the time complexity of indexOf. We begin from the first chracter of haystack, check if it has the needle begin at index i. We can also use KMP string match algorithm to implement it in O(n) time. See detail at [kmp](http://wishyouhappy.github.io/2014/12/26/kmp%20algorithm\(knuth-morris-pratt\)).

**Code of solution1**: O(n^2)


```java
  public int strStr1(String haystack, String needle) {
        if(haystack == null || needle == null) return -1;
        if(needle.equals("")) return 0;
        boolean contain = true;
        for(int i = 0; i <= haystack.length() - needle.length();i++){
            for(int j = i; j < i + needle.length(); j++){
                if(haystack.charAt(j) != needle.charAt(j-i)){
                    contain = false;
                    break;
                } 
            }
            if(contain) return i;
            contain = true;
        }
        return -1;
    }

```

**Code of solution2**: O(n)
 
```java

	public int strStr(String haystack, String needle){
		if(haystack == null || needle == null || (haystack.length() < needle.length())) return -1;
        if(needle.equals("")) return 0;
		int[] helper = getHelperArray(needle);
		int i = 0,
			j = 0,
			textLen = haystack.length(),
			patternLen = needle.length();
		while(i < textLen && j < patternLen){
			if(haystack.charAt(i) == needle.charAt(j)){
				j++;
				i++;
			}
			
			if(j == patternLen){
				return i - patternLen;
				//j = helper[j-1]; //if we want find all matches. 
			}else if((i < textLen && j < patternLen) &&haystack.charAt(i) != needle.charAt(j)){
				if(j != 0) j = helper[j-1];
				else i++;
			}
		}
		return -1;
	}
	
	public int[] getHelperArray(String pattern){
		int i = 1, //suffix
			j = 0, //prefix
			len = pattern.length();
		int[] helper = new int[len];
		helper[0] = 0;
		
		while(i < len){
			if(pattern.charAt(i) == pattern.charAt(j)){
				j++;
				helper[i] = j;
				i++;
			}else{
				if(j != 0) j = helper[j-1];
				else{
					helper[i] = 0;
					i++;
				}
			}
		}
		return helper; 
	}

```

<br>

<br>




###29 Divide Two Integers

>Divide two integers without using multiplication, division and mod operator.

If it is overflow, return MAX_INT.


**Idea**: Each integer can be represent as binary format, so n = (0 or 1) * 2 ^ n +(0 or 1) * 2 ^ (n-1) + ......

We can respresent the result = (0 or 1) * 2 ^ n +(0 or 1) * 2 ^ (n-1) + ......

Thus [(0 or 1) * 2 ^ n +(0 or 1) * 2 ^ (n-1) + ......)] * divisor = dividend

Thus, we can calculate (0 or 1) * 2 ^ i, i from n to 0, and combine them together.


**Time complexity** : O(lgn)

**Space**: O(1)

**Attention**:

- abs (Integer.MIN_VALUE) = Integer.MIN_VALUE
- when calculate n, eg:  while(divisor <= (dividend >> 1)) we can not change to while((divisor<<1) <= dividend). It might overflow and keep loop forever.
- Take care of some corner case, eg: dividend = Integer.MIN_VALUE or divisor = Integer.MIN_VALUE


<br>

```java
	public int divide( int dividend, int divisor){
	       if(divisor == 0) return Integer.MAX_VALUE;
	       int result = 0;
	       boolean positive = ((dividend ^ divisor) >>> 31) == 0;
	       if(divisor == Integer.MIN_VALUE){
	           if(dividend == Integer.MIN_VALUE) return 1;
	           else return 0;
	       }
	       if(dividend == Integer.MIN_VALUE){
	           if(divisor == 1) return Integer.MIN_VALUE;
	           else if(divisor == -1) return Integer.MAX_VALUE;
	           dividend += Math.abs(divisor);
	           result += 1;
	       }
	       
	       dividend = Math.abs(dividend);
	       divisor = Math.abs(divisor);
	       
	       int count = 0;
	       while(divisor <= (dividend >> 1)){
	           count++;
	           divisor <<= 1;
	       }
	       
	       while(count >= 0){
	           if(dividend >= divisor){
	               result += 1 << count;
	               dividend -= divisor;
	           }
	           divisor >>= 1;
	           count --;
	       }
	       return positive ? result : -result;
	    }


```

***Related Questions:***

* [7 Reverse Integer](#7-reverse-integer)
* [29 Divide Two Integers](#29-divide-two-integers)
* [50 Pow](#50-pow)
* [69 Sqrt](#69-sqrt)
* [166 Fraction to Recurring Decimal](#166-fraction-to-recurring-decimal)

<br>

<br>


###30 SubString with Concatenation of All Words

> You are given a string, S, and a list of words, L, that are all of the same length. Find all starting indices of substring(s) in S that is a concatenation of each word in L exactly once and without any intervening characters.

<pre>
For example, given:
S: "barfoothefoobarman"
L: ["foo", "bar"]
</pre>

You should return the indices: [0,9].
(order does not matter).

**Idea**: Store a dictionary of L. We use map to record each word of L and their occurence. Then for each index of S from 0, check if there is matches. 


**Java Code**:

```java

    public List<Integer> findSubstring(String S, String[] L) {
    	List<Integer> list = new ArrayList<Integer>();
    
    	if(S == null || S.length() == 0 || L == null || L.length == 0) return list;
    	if(S.length() < L.length * L[0].length()) return list;
    	
    	Map<String, Integer> map = new HashMap<String, Integer>();
    	for(int i = 0, len = L.length; i < len; i++){
    		String current = L[i];
    		if(map.containsKey(current)) map.put(current, map.get(current)+1);
    		else map.put(current, 1);
    	}
    	
    	int unitLen = L[0].length();
    	int sLen = S.length();
    	int totalStr = L.length;
    	int i = 0;
    	
    	while(sLen - i >= unitLen * totalStr){
    		Map<String, Integer> tempMap = new HashMap<String, Integer>(map);
    		for(int j = 0; j < totalStr; j++){
    			String current = S.substring(i+j*unitLen, i + (j+1)*unitLen);
    			if(!tempMap.containsKey(current)) break;
    			if(tempMap.get(current) == 1) tempMap.remove(current);
    			else tempMap.put(current,tempMap.get(current)-1);
    		}
			if(tempMap.size() == 0) list.add(i);
    		i++;
    	}
    	
    	return list;   
    }


```






<br>

<br>


###31 Next Permutation

>Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.

>If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).

>The replacement must be in-place, do not allocate extra memory.

>Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.

<pre>
1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1
</pre>


**Idea**: The next permutation is the permutation that larger than the original permutation and the immediate larger one. We can also think this as a successor. We can find the next permutation by the following steps:

- 1) from the end, find the first non-increasing element, eg 1 2 3 5 4. Then we need to find is 3. Record this index. If it's -1, say 5, 4, 3, 2, 1. Then we can reverse the array to 1, 2, 3, 4, 5 and end the function.

- 2) from the index1 we record in step 1, we find the smallest element larger than num[index1]. Record this index2.

- 3) swap element and index1 and index2, then reverse element after index1. 

For example. a permutation of 1 2 3 4 5 would be:

1 2 3 4 5

1 2 3 5 4

1 2 4 3 5

1 2 4 5 3

1 2 5 3 4

1 2 5 4 3

1 3 2 4 5

1 3 2 5 4

1 3 4 2 5

1 3 4 5 2 

.......


**Attention**

- 1) for step 1, when find the non-inceasing element we allow the equal element. eg: 1 2 5 4 4 3. We should find 2, the index1. Consider test case "[1 1]"
- 2) for step 2, we should find element larger then num[index1]. If change to >=, then it doesn't work. Consider test case "[1, 5, 1]"

**Java code**:

```java


    public void nextPermutation(int[] num) {
    	if(num == null || num.length == 0) return;
    	
    	int i = num.length - 2;
    	while(i >= 0 && num[i] >= num[i+1]) i--;
    	if(i == -1) {
    		reverse(num, 0);
    		return;
    	}
    	
    	int j = i+1;
    	while(j < num.length && num[j] > num[i]) j++;
    	swap(num, i, j-1);
    	
    	reverse(num, i+1);
    }
    
    public void reverse(int[] num, int start){
    	int end = num.length-1;
    	while(start < end){
    		int temp = num[start];
    		num[start] = num[end];
    		num[end] = temp;
    		start++;
    		end--;
    	}
    }
    
    public void swap(int[] num, int i, int j){
    	int temp = num[i];
    	num[i] = num[j];
    	num[j] = temp;
    }

```



<br>

<br>


###32 Longest Valid Parentheses


>Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring.

>For "(()", the longest valid parentheses substring is "()", which has length = 2.

>Another example is ")()())", where the longest valid parentheses substring is "()()", which has length = 4.


**Idea**: This problem has some similarities with the valid parentheses, we need to use the method in that problem to check if the current sequence of parentheses is valid. We use a stack to match the parentheses. The difference is that we store the **index** of the parenthese other than index. Because there is only one type of parentheses, so it's ok to store just the index. 

Then how to calculate the longest valid parentheses? Like the valid parentheses problem, everytime, we encounter a '(', we push the current index. Then if the parentheses is ')', Obviously, if the stack is empty, then the previous parentheses sequence cannot be a valid parentheses, so we update the valid parentheses start position. Otherwise, we need to calculate the local longest parentheses. 

**Attention**: When we calculate the local longest, we need to compare the max with i-stack.peek() after we pop an element from the stack because we need to count in the previous valid sequences. Eg: (()(). 


**Java code**:

```java
    public int longestValidParentheses(String s) {
        if(s == null || s.length() == 0) return 0;
        int max = 0;
        int start = 0;
        Stack<Integer> stack = new Stack<Integer>();
        for(int i = 0; i < s.length(); i++){
            if(stack.isEmpty() && s.charAt(i) == ')') start = i+1;
            else if(s.charAt(i) == ')'){
                stack.pop();
                max = stack.isEmpty()?Math.max(max, i -start+1) : Math.max(max, i-stack.peek());
            } 
            else if(s.charAt(i) == '(') stack.push(i);
        }
        return max;
    }


```


<br>

<br>



###33 Search in Rotated Sorted Array


>Suppose a sorted array is rotated at some pivot unknown to you beforehand.

>(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).

>You are given a target value to search. If found in the array return its index, otherwise return -1.

>You may assume no duplicate exists in the array.

**Idea**: There is no duplicate, so after rotation, the array can be look as two parts, and these two parts are all in ascending order. Thus we can use the binary search method, and update the l and r pointer based on the comparison. See details of comparison on the code.


**Java code**:


```java
    public int search(int[] A, int target) {
        if(A == null || A.length == 0) return -1;
        int l = 0;
        int r = A.length-1;
        while(l <= r){
            int mid = (l+r)/2;
            if(A[mid] == target) return mid;
            if(A[mid] > target && A[mid] < A[r]) r = mid-1;
            else if(A[mid] < target && A[mid] > A[l]) l = mid + 1;
            else if(A[l] != target) l++;
            else return l;
        }
        return -1;
    }


```


**Another way**: 

```java

	 public int search2(int[] A, int target){
			if(A == null || A.length == 0) return -1;
			int l = 0;
			int r = A.length -1;
			while( l <= r){
				int mid = (l + r)/2;
				if(A[mid] == target) return mid;
				if(A[mid] >= A[l]){
					if(A[l] <= target && A[mid] > target) r = mid -1;
					else l = mid + 1;
				}else {
					if(A[mid] < target && A[r] >= target) l = mid + 1;
					else r = mid -1;
				}
			}
			return -1;
		
		}


```




<br>
<br>



###34 Search for a Range

>Given a sorted array of integers, find the starting and ending position of a given target value.

>Your algorithm's runtime complexity must be in the order of O(log n).

>If the target is not found in the array, return [-1, -1].

>For example,

>Given [5, 7, 7, 8, 8, 10] and target value 8,

>return [3, 4].

<br>

**Idea**: We need to find the range in O(lgn), thus binary search comes to mind. We could use binary search to find the target, then for the left and right part, we do binary search again to find the left boundary and right boundary.

The second solution is similar to the first one, the differce is that we do twice binary search to do the left boundary and right boundary. Remember to check the value of the two boundaries. Because in this method, we might not find the target element. 


**Solution1**:


```java
    public int[] searchRange(int[] A, int target) {
        int[] res = {-1, -1};
        if(A == null || A.length == 0) return res;
        int l = 0;
        int r = A.length -1;
        while(l <= r){
            int mid = (l + r)/2;
            if(A[mid] < target) l = mid + 1;
            else if (A[mid] > target) r = mid - 1;
            else{
                int l1 = l;
                int r1 = mid;
                while(l1 <= r1){
                    int mid1 = (l1+r1)/2;
                    if(A[mid1] < target) l1 = mid1 + 1;
                    else r1 = mid1 -1;
                }
                res[0] = l1;
                
                int l2 = mid;
                int r2 = r;
                while(l2 <= r2){
                    int mid2 = (l2+r2)/2;
                    if(A[mid2] <= target) l2 = mid2 + 1;
                    else r2 = mid2 -1;
                }
                res[1] = r2;
                
                return res;
            }
        }
        return res;
    }
    


```


**Solution 2**:

```java
    
    public int[] searchRange1(int[] A, int target) {
        int[] res = {-1, -1};
        if(A == null || A.length == 0) return res;
        int l1 = 0;
        int r1 = A.length -1;
        while(l1 <= r1){
            int mid1 = (l1+r1)/2;
            if(A[mid1] < target) l1 = mid1 + 1;
            else r1 = mid1 -1;
        }
        int l2 = 0;
        int r2 = A.length -1;
        while(l2 <= r2){
            int mid2 = (l2 + r2)/2;
            if(A[mid2] <= target) l2 = mid2 + 1;
            else r2 = mid2 -1;
        }
        if(l1 <= r2){
            res[0] = l1;
            res[1] = r2;
        }
        
        return res;
    }
   


```


<br>
<br>


###35 Search Insert Position


>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.

>You may assume no duplicates in the array.

>Here are few examples.

<pre>
[1,3,5,6], 5 → 2
[1,3,5,6], 2 → 1
[1,3,5,6], 7 → 4
[1,3,5,6], 0 → 0
</pre>


<br>
**Idea**: Just like the method used in search range, we use binary search, when l > r, l is the first element larger then the target. 



```java 

    public int searchInsert(int[] A, int target) {
        if(A == null || A.length == 0) return 0;
        int l = 0;
        int r = A.length-1;
        while(l <= r){
            int mid = (l+r)/2;
            if(A[mid] == target) return mid;
            else if(A[mid] < target) l = mid+1;
            else r = r=mid-1;
        }
        return l;
    }

```

<br>

<br>

###36 Valid Sudoku

>Determine if a Sudoku is valid, according to: Sudoku Puzzles - The Rules.

>The Sudoku board could be partially filled, where empty cells are filled with the character '.'.

**Rules about sudoku**:

- 1) 9×9 grid
- 2) each column, each row, and each of the nine 3×3 sub-grids that compose the grid (also called "boxes", "blocks", "regions", or "sub-squares") contains all of the digits from 1 to 9

**Idea**: Check each row, each column and each 3*3 blocks.


**Java code**:

```java


    public boolean isValidSudoku(char[][] board) {
        if(board == null || board.length != 9 || board[0].length != 9) return false;
        for(int i = 0; i < board.length; i++){
            Set<Character> rset = new HashSet<Character>();
            Set<Character> cset = new HashSet<Character>();
            for(int j = 0; j < board[0].length; j++){
                char rc = board[i][j];
                if((rc != '.' && (rc > '9' || rc < '1')) || rset.contains(rc)) return false;
                if(rc != '.') rset.add(rc);
                char cc = board[j][i];
                if((cc != '.' && (cc > '9' || cc < '1')) || cset.contains(cc)) return false;
                if(cc != '.') cset.add(cc);
            }
        }
        for(int i = 0; i < 3; i++){
            for(int j = 0; j < 3; j++){
                if(!helper(i, j, board)) return false;
            }
        }
        return true;
    }
    public boolean helper(int i, int j, char[][] board){
        Set<Character> set = new HashSet<Character>();
        for(int k = 3*i; k < 3*i+3; k++){
            for(int l = 3*j; l <3*j+3; l++){
                char c = board[k][l];
                if((c != '.' &&(c > '9' || c < '1')) || set.contains(c)) return false;
                if(c != '.') set.add(c);
            }
        }
        return true;
    }

```

***Related Problem***:

* [36 Valid Sudoku](#36-valid-sudoku)
* [37 Sudoku Solver](#37-sudoku-solver)



<br>

<br>


###37 Sudoku Solver

>Write a program to solve a Sudoku puzzle by filling the empty cells.

>Empty cells are indicated by the character '.'.

>You may assume that there will be only one unique solution.


**Idea**: we solve the sudoku line by line, every time we fill in a filed, we check if is valid. We can use the method in * [36 Valid Sudoku](#36-valid-sudoku) to check the sudoku




**Java code**:

```java

    public void solveSudoku(char[][] board) {
        if(board == null || board.length != 9 | board[0].length != 9) return;
        solverHelper(board, 0, 0);
    }
    
    public boolean solverHelper(char[][] board, int i, int j){
        if(j == 9) return solverHelper(board, i+1, 0);
        if(i == 9) return true;
        if(board[i][j] == '.'){
            for(int k = 1; k <=9; k++){
                board[i][j] = (char)(k+'0');
                if(isValid(board, i, j)){
                   if(solverHelper(board, i, j+1)) return true;
                }
            }
            board[i][j] = '.';
        }else return  solverHelper(board, i, j+1);
        return false;
    }
    public boolean isValid(char[][] board, int i, int j) {
		 for(int k = 0; k < 9; k++){
			 if(k != j && board[i][k] == board[i][j]) return false;
			 if(k != i && board[i][j] == board[k][j]) return false;
		 }
		 
		 for(int r = i/3 *3; r < i/3 *3 +3; r++){
			 for(int c = j/3 * 3; c < j/3 * 3+3; c++){
				 if((r != i || c != j) && board[r][c] == board[i][j]) return false;
			 }
		 }
		 return true;
	 }
	 
```

***Related Problem***:

* [36 Valid Sudoku](#36-valid-sudoku)
* [37 Sudoku Solver](#37-sudoku-solver)





<br>

<br>





###38 Count and Say
>The count-and-say sequence is the sequence of integers beginning as follows:

>1, 11, 21, 1211, 111221, ...

>1 is read off as "one 1" or 11.

>11 is read off as "two 1s" or 21.

>21 is read off as "one 2, then one 1" or 1211.

>Given an integer n, generate the nth sequence.

>Note: The sequence of integers will be represented as a string.


**Idea**: Calculate the string based on the previous one. Each time count the repeating times of each character. It's similar to compress string based on its repeating times.

**Java code**:


```java

    public String countAndSay(int n) {
        if(n <= 0) return "";
        if(n == 1) return "1";
        StringBuilder res = new StringBuilder();
        res.append(1);
        for(int i = 2; i <= n; i++){
            String temp = res.toString();
            StringBuilder cur = new StringBuilder();
            char pre = temp.charAt(0);
            int count = 1;
            for(int j = 1; j < temp.length(); j++){
                if(pre != temp.charAt(j)){
                    cur.append(count);
                    cur.append(pre);
                    pre = temp.charAt(j);
                    count = 1;
                }else count++;
            }
            cur.append(count);
            cur.append(pre);
            res = cur;
        }
        return res.toString();
    }


```

<br>

<br>

###39 Combination Sum
>Given a set of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.

> **The same repeated number may be chosen from C unlimited number of times.**

>Note:

>All numbers (including target) will be positive integers.

>Elements in a combination (a1, a2, … , ak) must be in non-descending order. (ie, a1 ≤ a2 ≤ … ≤ ak).

>The solution set must not contain duplicate combinations.

>For example, given candidate set 2,3,6,7 and target 7, 

<pre>

A solution set is: 
[7] 
[2, 2, 3] 

</pre>


**Idea**: We need to add combination in non-descending order, thus its better to first sort candidates. Off course, we can handle the duplicates and sequence in latter if we don't sort it. Then we add element to list, minus the current and go to the next recursion.


**Java code**:


```java

    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> res = new ArrayList<List<Integer>>();
        if(candidates == null || candidates.length == 0) return res;
        Arrays.sort(candidates);
        helper(candidates, target, res, new ArrayList<Integer>(), 0);
        return res;
    }
    public void helper(int[] candidates, int target, List<List<Integer>> res, List<Integer> cur, int start){
        if(target < 0) return;
        if(target == 0){
            res.add(new ArrayList<Integer>(cur));
            return;
        }
        for(int i = start; i < candidates.length; i++){
            cur.add(candidates[i]);
            helper(candidates, target-candidates[i], res, cur, i);
            cur.remove(cur.size()-1);
        }
    }

```


***Related Problems***:

* [39 Combination Sum](#39-combination-Sum)
* [40 Combination Sum II](#40-combination-sum-ii)
<br>

<br>


###40 Combination Sum II

>Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.

>**Each number in C may only be used once in the combination.**

>Note:

>All numbers (including target) will be positive integers.

>Elements in a combination (a1, a2, … , ak) must be in non-descending order. (ie, a1 ≤ a2 ≤ … ≤ ak).

<pre>

The solution set must not contain duplicate combinations.
For example, given candidate set 10,1,2,7,6,1,5 and target 8, 
A solution set is: 
[1, 7] 
[1, 2, 5] 
[2, 6] 
[1, 1, 6] 

</pre>



**Idea**: The difference with [39 Combination Sum](#39-combination-Sum)] is that in ths problem we can only use each number once. So when go to next recursion, the start position should change to i+1, so that it will add itself again. 

**Java code**:

```java
    public List<List<Integer>> combinationSum2(int[] num, int target) {
        List<List<Integer>> res = new ArrayList<List<Integer>>();
        if(num == null || num.length == 0) return res;
        Arrays.sort(num);
        helper(num, target, res, new ArrayList<Integer>(), 0);
        return res;
    }
    public void helper(int[] candidates, int target, List<List<Integer>> res, List<Integer> cur, int start){
        if(target < 0) return;
        if(target == 0){
            res.add(new ArrayList<Integer>(cur));
            return;
        }
        for(int i = start; i < candidates.length; i++){
            if(i > start && candidates[i] == candidates[i-1]) continue;
            cur.add(candidates[i]);
            helper(candidates, target-candidates[i], res, cur, i+1);
            cur.remove(cur.size()-1);
        }
    }

```

***Related Problems***:

* [39 Combination Sum](#39-combination-Sum)
* [40 Combination Sum II](#40-combination-sum-ii)
<br>

<br>


###41 First Missing Positive

>Given an unsorted integer array, find the first missing positive integer.

>For example,

>Given [1,2,0] return 3,

>and [3,4,-1,1] return 2.

>Your algorithm should run in O(n) time and uses constant space.

<br>

**Idea**: This problem has the same idea with the counting sort problem. If no element is missing, then A[A[i]-1] = A[i]. Thus, we just need to put the element to its original place and have another pass to check the miss element.
 


**Java code**:


```java

    public int firstMissingPositive(int[] A) {
        if(A == null || A.length == 0) return 1;
        for(int i = 0; i < A.length; i++){
            if(A[i] > 0 && A[i] - 1 < A.length && A[A[i]-1] != A[i]){
                int temp = A[A[i]-1];
                A[A[i]-1] = A[i];
                A[i] = temp;
                i--;
            } 
        }
        for(int i = 0; i < A.length; i++){
            if(A[i] != i+1) return i+1;
        }
        return A.length+1;
    }

```


<br>
<br>


###42 Trapping Rain Water

>Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.

For example, 
Given [0,1,0,2,1,0,1,3,2,1,2,1], return 6.

**Idea**: 

- 1) Solution1: Like [11 Container with Most Water](#11-container-with-most-water), we record two pointers, l and r, min = min(A[l], A[r]), if A[l] < A[r], we move right, and add water if A[l] < min; similarly, if A[l] > A[r], we move r left, and if A[r] < min, we add water. When l >= r, we get the total volumn. 


```java

 public int trap(int[] A) {
    if(A == null || A.length == 0) return 0;
    int res = 0;
    int l = 0;
    int r = A.length - 1;
    while(l < r){
        int min = Math.min(A[l], A[r]);
        if(A[l] < A[r]){
            l++;
            while(l < r && A[l] < min){
                res += min - A[l++];
            }
        }else{
            r--;
            while(l < r && A[r] < min){
                res += min - A[r--];
            }
        }
    }
    return res;
  }

```

<br>

- 2)solution 2 : we traverse the array two times, left to right and right to left. Then we can get the min(max height on the left of A[i], max height on the right of A[i]). So add the capacity of each bar, we get the total capacity.

```java

	  public int trap(int[] A) {
		if(A == null || A.length == 0) return 0;
		int[] left = new int[A.length];
		int max = 0;
		for(int i = 0; i < A.length; i++){
		    left[i] = max;
		    max = Math.max(max, A[i]);
		}
		
		int res = 0;
		max = 0;
		for(int i = A.length-1; i>=0; i--){
		    res += Math.min(max, left[i]) - A[i] > 0 ? (Math.min(max, left[i]) - A[i]): 0 ;
		    max = Math.max(max, A[i]);
		}
		return res;
	}

```



***Related***:

* [11 Container with Most Water](#11-container-with-most-water)
* [42 Trapping Rain Water](#42-trapping-rain-water)
* [135 Candy](#135-candy)

<br>
<br>




###43 Multiply Strings


>Given two numbers represented as strings, return multiplication of the numbers as a string.

>Note: The numbers can be arbitrarily large and are non-negative.

<br>

**Idea**: If length is n and m, result's length is n+m or n+m-1, result of index i = 0 * i + 1 * i-1 ..... i * 0


**Attention**: We should not add the leftmost zero.



**Java code**:

```java

    public String multiply(String num1, String num2) {
        if(num1 == null || num2 == null) return null;
        if(num1.equals("0") || num2.equals("0")) return "0";
        StringBuilder res = new StringBuilder();
        int cur = 0;
        for(int i= num1.length() + num2.length() -1;i >=0; i--){
            for(int j = Math.min(i-1, num1.length()-1);j >= 0; j--){
                if(j < num1.length() && ((i-j-1) < num2.length())) {
                    cur += (int)(num1.charAt(j) - '0') * (int)(num2.charAt(i-j-1) - '0');
                }
            }
            if(i != 0 || cur > 0) res.insert(0, cur % 10);
            cur = cur / 10;
        }
        return res.toString();
    }


```

<br>
<br>

###44 Wildcard Matching

> Implement wildcard pattern matching with support for '?' and '*'.

<pre>

'?' Matches any single character.
'*' Matches any sequence of characters (including the empty sequence).

The matching should cover the entire input string (not partial).

The function prototype should be:
bool isMatch(const char *s, const char *p)

Some examples:
isMatch("aa","a") → false
isMatch("aa","aa") → true
isMatch("aaa","aa") → false
isMatch("aa", "*") → true
isMatch("aa", "a*") → true
isMatch("ab", "?*") → true
isMatch("aab", "c*a*b") → false

</pre>

**Idea**: This problem is similar with [10 Regular Expression Matching](#10-regular-expression-matching). The difference is that '.' is replace with '?'. And '\*' can match any sequence including empty. We can use the method in [10 Regular Expression Matching](#10-regular-expression-matching). Or we use two pointers to record the return place in s and p when encounter a '\*'

**Iterative Code**:

```java
	 public boolean isMatch(String s, String p) {
   	    if(s == null && p == null || p.equals("*")) return true;
		int i = 0, j = 0, savei = -1, savej = -1;
		while(i < s.length()){
		    if(j < p.length() && (s.charAt(i) == p.charAt(j) || p.charAt(j) == '?')){
		        i++;
		        j++;
		    }else if(j < p.length() && p.charAt(j) == '*'){
		        savei = i;
		        savej = j++;
		    }else if(savej != -1){
		        j = savej + 1;
		        i = ++savei;
		    }else return false;
		}
		while(j < p.length() && p.charAt(j) == '*') j++;
		return j == p.length();
	}

```


**Recursion**: it might exceed the time limit

```java
		
    public boolean isMatch2(String s, String p) {
        if((s == null && p == null) || p.equals("*")) return true;
        return helper(s, p, 0, 0);
    }
    
    public boolean helper(String s, String p, int i, int j){
        if(j == p.length()) return i == s.length();
        if(p.charAt(j) != '*'){
            if(i < s.length() && (s.charAt(i) == p.charAt(j) || p.charAt(j) == '?')) return helper(s, p, i+1, j+1);
            else return false;
        }else{
            while(i < s.length()){
                if(helper(s, p, i++, j+1)) return true;
            }
            return helper(s, p, i, j+1);
        }
    }

```



***Related Problem***:

* [10 Regular Expression Matching](#10-regular-expression-matching)
* [44 Wildcard Matching](#44-wildcard-matching)

<br>
<br>

###45 Jump Game II

>Given an array of non-negative integers, you are initially positioned at the first index of the array.Each element in the array represents your maximum jump length at that position.

>Your goal is to reach the last index in the minimum number of jumps.

<pre>

For example:
Given array A = [2,3,1,1,4]

The minimum number of jumps to reach the last index is 2. (Jump 1 step from index 0 to 1, then 3 steps to the last index.)

</pre>
<br>

**Idea**: The basic idea is same with Jump Game. Difference is that in this problem we need to calculate the optimal steps. How can We get the minimum steps? The idea is that we only increase steps when we found that the **current position i is greater than than the previous step max**, which means that if you want to reach further, you need to increase steps.  


**Java code**:

```java
    public int jump(int[] A) {
        if(A == null || A.length <= 1) return 0;
        int max = 0;
        int canReach = 0;
        int res = 0;
        for(int i = 0; i < A.length; i++){
            if(i > max) return -1;  // check if you can reach to the end.
            if(i > canReach){
                res++;
                canReach = max;
            }
            max = Math.max(max, i + A[i]);
        }
        return res;
    }

```

<br>
<br>


###46 Permutations

>Given a collection of numbers, return all possible permutations.

**No duplicate number in collection**

<pre>
For example,
[1,2,3] have the following permutations:
[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], and [3,2,1].
</pre>

**Idea**:

Since there is no duplicate, we can add element one by one. For example:

1,

1 2, 2 1

3 1 2, 1 3 2, 1 2 3, 3 2 1, 2 3 1, 2 1 3


**Jave code**:



*Iterative*:


```java

    public List<List<Integer>> permute(int[] num) {
        List<List<Integer>> res = new ArrayList<List<Integer>>();
        if(num == null || num.length == 0) return res;
        List<Integer> first = new ArrayList<Integer>();
        first.add(num[0]);
        res.add(first);
        for(int i = 1; i < num.length; i++){
            List<List<Integer>> cur = new ArrayList<List<Integer>>();
            for(List<Integer> l : res){
                for(int j = 0; j <= l.size(); j++){
                    List<Integer> temp = new ArrayList<Integer>(l);
                    temp.add(j, num[i]);
                    cur.add(temp);
                }
            }
            res = cur;
        }
        return res;
    } 

```

*recursion*:

```java

    public List<List<Integer>> permute1(int[] num) {
    	List<List<Integer>> list = new ArrayList<List<Integer>>();
    	if(num == null || num.length == 0) return list;
        return helper(list, num, 0);
    }
    
    public List<List<Integer>> helper(List<List<Integer>> list, int[] num, int i){
    	if(i == num.length){
    		List<Integer> arr = new ArrayList<Integer>();
    		list.add(arr);
    		return list;
    	}
    	
    	list = helper(list, num, i+1);
    	List<List<Integer>> current = new ArrayList<List<Integer>>();
    	for(List<Integer> l : list){
    		if(l.size() == 0){
    			List<Integer> arr = new ArrayList<Integer>();
    			arr.add(num[i]);
        		current.add(arr);
    		}
    		else {
	    		for(int j = 0; j <= l.size(); j++){
	    			List<Integer> arr = new ArrayList<Integer>(l);
	    			arr.add(j, num[i]);
	        		current.add(arr);
	    		}
    		}
    	}
    	list = new ArrayList<List<Integer>>(current);
    	return list;
    }

```

<br>
<br>


###47 Permutations II

>Given a collection of numbers that might **contain duplicates**, return all possible unique permutations.

For example,
[1,1,2] have the following unique permutations:
[1,1,2], [1,2,1], and [2,1,1].
<br>

**Idea**: Since the collection has duplicates, thus each time when we add permutation, we need to consider if it already exists. 

In the following code, the first code snippit use list.contains to check the duplicates. The second code snippit use set to avoid add dupilcates.

These two are accepted, the second one has better time complexity.


**Java code**:

```java

    public List<List<Integer>> permuteUnique(int[] num) {
        List<List<Integer>> res = new ArrayList<List<Integer>>();
        if(num == null || num.length == 0) return res;
        List<Integer> first = new ArrayList<Integer>();
        first.add(num[0]);
        res.add(first);
        for(int i = 1; i < num.length; i++){
            List<List<Integer>> cur = new ArrayList<List<Integer>>();
            for(List<Integer> l : res){
                for(int j = 0; j <= l.size(); j++){
                    List<Integer> temp = new ArrayList<Integer>(l);
                    temp.add(j, num[i]);
                    if(!cur.contains(temp)) cur.add(temp);
                }
            }
            res = cur;
        }
        return res;
    }


```


Use set, recursion:


```java

  	public List<List<Integer>> permuteUnique(int[] num) {
    	List<List<Integer>> list = new ArrayList<List<Integer>>();
    	if(num == null || num.length == 0) return list;
        return helper(list, num, 0);
    }
    
    public List<List<Integer>> helper(List<List<Integer>> list, int[] num, int i){
    	if(i == num.length){
    		List<Integer> arr = new ArrayList<Integer>();
    		list.add(arr);
    		return list;
    	}
    	
    	list = helper(list, num, i+1);
    	Set<List<Integer>> current = new HashSet<List<Integer>>();
    	for(List<Integer> l : list){
    		if(l.size() == 0){
    			List<Integer> arr = new ArrayList<Integer>();
    			arr.add(num[i]);
        		current.add(arr);
    		}
    		else {
	    		for(int j = 0; j <= l.size(); j++){
	    			List<Integer> arr = new ArrayList<Integer>(l);
	    			arr.add(j, num[i]);
	        		current.add(arr);
	    		}
    		}
    	}
    	list = new ArrayList<List<Integer>>(current);
    	return list;
    }

```




<br>
<br>


###48 Rotate Image


>You are given an n x n 2D matrix representing an image.

>Rotate the image by 90 degrees (clockwise).

>Follow up:
>Could you do this in-place?

**Idea**:The easiest way to solve this problem is draw a matrix and rotate it by 90 degrees. Then you'll find the following pattarn.

-   matrix[i][j] = matrix[n-j-1][i];
-   matrix[n-j-1][i] = matrix[n-i-1][n-j-1]
-   matrix[n-i-1][n-j-1] = matrix[j][n-i-1]; 
-   matrix[j][n-i-1] = matrix[i][j]

**Attention**: I made a mistake at the first time, matrix[i][j] should equal to matrix[n-j-1][i] other than matrix[n-j][i]. The other three should follow the same way.

**Java code**:

```java

    public void rotate(int[][] matrix) {
        if(matrix == null || matrix.length == 0 || matrix[0].length == 0) return;
        int n = matrix.length;
        for(int i = 0; i < n/2; i++){
            for(int j = i; j < n - i - 1; j++){
                int temp = matrix[i][j];
                matrix[i][j] = matrix[n-j-1][i];
                matrix[n-j-1][i] = matrix[n-i-1][n-j-1];
                matrix[n-i-1][n-j-1] = matrix[j][n-i-1];
                matrix[j][n-i-1] = temp;
            }
        }
    }

```

<br>
<br>


###49 Anagrams

>Given an array of strings, return all groups of strings that are anagrams.

>Note: All inputs will be in lower-case.


**Ideas**: To solve this problem, we can divide it into two parts

- 1) how to check if two strings are anagrams?

	 we can sort them and check if they are equal

- 2) for a certain string, how to decide if it has anagram in the strs?

	 Use hashmap.





**Java code**:

```java

    public List<String> anagrams(String[] strs) {
        List<String> res = new ArrayList<String>();
        if(strs == null || strs.length == 0) return res;
        Map<String, List<String>> map = new HashMap<String, List<String>>();
        for(String s : strs){
            char[] arr = s.toCharArray();
            Arrays.sort(arr);
            String sorted = new String(arr);
            if(map.containsKey(sorted)){
                map.get(sorted).add(s);
            }else{
                List<String> list = new ArrayList<String>();
                list.add(s);
                map.put(sorted, list);
            }
        }
        for(Map.Entry<String, List<String>> e : map.entrySet()){
            if(e.getValue().size() > 1){
                res.addAll(e.getValue());
            }
        }
        return res;
    }

```


<br>
<br>

###50 Pow

>Implement pow(x, n).

**Idea**: Dichotomy and calculate recursively. 
```java

	public double pow(double x, int n){
	    if (n == 0) return 1;
	    double result = pow(x, n/2);
	    if(n % 2 == 0) return result * result;
	    else if(n % 2 == 1) return result * result * x;
	    else return result * result / x;
	}

```

***Related Questions:***

* [7 Reverse Integer](#7-reverse-integer)
* [29 Divide Two Integers](#29-divide-two-integers)
* [50 Pow(x,n)](#50-pow(x,n))
* [69 Sqrt(x)](#69-sqrt(x))
* [166 Fraction to Recurring Decimal](#166-fraction-to-recurring-decimal)

<br>

<br>

###51 N Queens


>The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.


>Given an integer n, return all distinct solutions to the n-queens puzzle.

>Each solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space respectively.

<pre>
For example,
There exist two distinct solutions to the 4-queens puzzle:

[
 [".Q..",  // Solution 1
  "...Q",
  "Q...",
  "..Q."],

 ["..Q.",  // Solution 2
  "Q...",
  "...Q",
  ".Q.."]
]

</pre>

**Requirement**: For n queen problem, we can not put queens in the same row or same column or diagonal.

**Idea**: We can use the queen one by one, each one correspond to one row. To find all solutions, we need to try each column on a row. When we finish the last row, we find a solution. Use recursions inside the loops we can find all solutions.



**Java code**:


```java

    public List<String[]> solveNQueens(int n) {
        List<String[]> res = new ArrayList<String[]>();
        if(n <= 0) return res;
        solve(0,n,new int[n],res);
        return res;
    }
    
    public void solve(int r, int n, int[] cols, List<String[]> list){
        if(r == n){
            String[] strs = new String[n];
            for(int i = 0; i < n; i++){
                StringBuilder s = new StringBuilder();
                for(int j = 0; j < n; j++){
                    if(j == cols[i]) s.append("Q");
                    else s.append(".");
                }
                strs[i] = s.toString();
            }
            list.add(strs);
            return;
        }
        for(int i = 0; i < n; i++){
            if(isValid(r, i, cols)){
                cols[r] = i;
                solve(r+1, n, cols, list);
            }
        }  
        
    }
    
    public boolean isValid(int r, int c, int[] cols){
        for(int i = 0; i < r; i++){
            if(c == cols[i] || r - i == Math.abs(cols[i] - c)) return false;
        }
        return true;
    }

```


<br>

<br>


###53 Maximum Subarray

>Find the contiguous subarray within an array **(containing at least one number)** which has the largest sum.

For example, given the array [−2,1,−3,4,−1,2,1,−5,4],
the contiguous subarray [4,−1,2,1] has the largest sum = 6.

**Idea**:
- 1) solution1: use dp. Store a local max and global max. Local max represents the max subarray which includes the element A[i]. Thus Local Max = max(local+A[i], A[i]). global = max(global, local).

**Attention**: Because the maxsubarray contains at least one number, thus the max sum might be negative when the array only contains one negative numbers or when all the numbers are negative.



```java

	 public int maxSubArray(int[] A) {
		 if(A == null || A.length == 0) return 0;
		 int local = A[0];
		 int global = A[0];
		 for(int i = 1; i < A.length; i++){
			 local = Math.max(A[i], local+A[i]);
			 global = Math.max(local, global);
		 }
		 return global;
	 }

```

<br>

- 2) solution 2: One pass. When encounter a negative number, record the current max. when sum + A[i] < 0 && A[i] > 0, change the local max to A[i]. 

```java

    public int maxSubArray1(int[] A) {
        if(A == null || A.length == 0) return 0;
        int max = Integer.MIN_VALUE;
        int temp = A[0];
        for(int i = 1; i < A.length; i++){
        	if(temp < 0){
        		max = Math.max(max,temp);
        		temp = A[i];
        	}else{
        		if(A[i] > 0) temp += A[i];
        		else if(temp + A[i] < 0){
        			max = Math.max(max,temp);
            		temp = A[i];
        		}else{
        			max = Math.max(max,temp);
            		temp += A[i];
        		}
        	}
        }
        max = Math.max(max,temp);
        return max;
    }

``` 


<br>
<br>


###54 Spiral Matrix

>Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.

<pre>
For example,
Given the following matrix:

[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]

</pre>

**Idea**:Don't figure out any good solution yet. Just add the element in spiral order one by one.

**Attention**: The row is not necessarily equal to column, thus make sure to check if they are equal. Also, in the following method, I loop Math.min(row, col) / 2 times. what will happen if  Math.min(row, col) is odd? 


**Java code**:


```java

    public List<Integer> spiralOrder(int[][] matrix) {
        List<Integer> res = new ArrayList<Integer>();
        if(matrix == null || matrix.length == 0 || matrix[0].length == 0) 
            return res;
        int row = matrix.length;
        int col = matrix[0].length;
        int loops = (Math.min(row, col)) /2;
        for(int i = 0; i < loops; i++){
            for(int j = i; j < col - i; j++){
                res.add(matrix[i][j]);
            }
            for(int j = i+1; j < row -i; j++){
                res.add(matrix[j][col-i-1]);
            }
            for(int j = col-i-2; j >= i; j--){
                res.add(matrix[row-i-1][j]);
            }
            for(int j = row - (i+2); j >= i+1; j--){
                res.add(matrix[j][i]);
            }
        }
        if(row >= col && col % 2 == 1){
            for(int i = col/2; i < row - col/2; i++){
                res.add(matrix[i][col/2]);
            }
        }
        if(row < col && row % 2 == 1){
            for(int i = row/2; i < col - row/2; i++){
                res.add(matrix[row/2][i]);
            }
        }
         return res;
    }

```

<br>
<br>


###55 Jump Game

> Given an array of non-negative integers, you are initially positioned at the first index of the array.

>Each element in the array represents your maximum jump length at that position.

>Determine if you are able to reach the last index.

<pre>
For example:
A = [2,3,1,1,4], return true.

A = [3,2,1,0,4], return false.
</pre>

**Idea**: We need to figure out the max-position we can reach. If max >= A.length-1, then we can reach to the end. Note that we need to check if at certain step if index i > max, then we can not reach to the end. Because in some cases the A[i] might be 0, thus we might not able to go to the next step.


**Java code**:


```java


    public boolean canJump(int[] A) {
        if(A == null || A.length <= 1) return true;
        int max = A[0];
        for(int i = 0; i < A.length && i <= max; i++){
            max = Math.max(max, i+A[i]);
            if(max >= A.length-1) return true;
        }
        return max >= A.length-1;
    }

```

<br>
<br>


###56 Merge Intervals

> Given a collection of intervals, merge all overlapping intervals.

<pre>
For example,
Given [1,3],[2,6],[8,10],[15,18],
return [1,6],[8,10],[15,18].
</pre>


**Idea**: First sort then merge.

- 1) For sort, we can use Collections.sort(list, comparator). And when interval1.start == interval2.start, we compare interval1.end and interval2.end.
Otherwise, we compare interval1.start and interval2.start
- 2) For merge, if current.start > last.end, just add interval.
Otherwise, we need to compare the end of two intervals. If current.end > last.end, we need to update last.end. 


**Java code**:

```java

    public List<Interval> merge(List<Interval> intervals) {
        if(intervals == null || intervals.size() == 0) return intervals;
        List<Interval> res = new ArrayList<Interval>();
        Comparator<Interval> comp = new Comparator<Interval>(){
          public int compare(Interval arg1, Interval arg2){
              if(arg1.start == arg2.start) return arg1.end - arg2.end;
              else return arg1.start - arg2.start;
          }
        };
        Collections.sort(intervals, comp);
        res.add(intervals.get(0));
        for(int i = 1; i < intervals.size(); i++){
            Interval cur = intervals.get(i);
            if(cur.start > res.get(res.size() -1).end) 
                res.add(cur);
            else {
                if(cur.end > res.get(res.size() -1).end)
                    res.get(res.size() -1).end = cur.end;
            }
        }
        return res;
    }
    
```

<br>

<br>


###57 Insert Interval

>Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).

>You may assume that the intervals were initially sorted according to their start times.

>Example 1:


>Given intervals [1,3],[6,9], insert and merge [2,5] in as [1,5],[6,9].


>Example 2:

>Given [1,2],[3,5],[6,7],[8,10],[12,16], insert and merge [4,9] in as [1,2],[3,10],[12,16].

>This is because the new interval [4,9] overlaps with [3,5],[6,7],[8,10].


**Idea**:

- solution 1 : There are three possible relations between two intervals. Consider interval i1 and interval i2,

	* case 1: i1.end < i2.start
	
	* case 2:  i1.start > i2.end
	
	* case 3: i1 includes i2, or i2 includes i1, or i1.start < i2.start and i1.end < i2.end, or i1.start > i2.start and i1.end > i2.end
	
	In case 1: we just need to add i1 to result,
	In case 2: we add i2 to result, and change newInterval to i1,
	In case 3: We might need to update the start or end of the newInterval.
	
	
- solution 2: First find the place to insert the newInterval, then do merge intervals for the remain intervals. How to find the place to insert the newInterval? If we find a interval that its end is >= newInterval.start, then it is the place to insert the newInterval. After insert, we merge the intervals. 



**java code**:


*Solution 1*:

```java

    public List<Interval> insert(List<Interval> intervals, Interval newInterval) {
        List<Interval> res = new ArrayList<Interval>();
        for(Interval interval : intervals){
            if(interval.end < newInterval.start){
                res.add(interval);
            }else if(interval.start > newInterval.end){
                res.add(newInterval);
                newInterval = interval;
            }else if(newInterval.end >= interval.start || newInterval.start <= interval.end ){
                newInterval.start = Math.min(interval.start, newInterval.start);
                newInterval.end = Math.max(interval.end, newInterval.end);
            }
        }
        res.add(newInterval);
        return res;
    }
    

```



*Solution 2*: 

```java

    public List<Interval> insert(List<Interval> intervals, Interval newInterval) {
        List<Interval> res = new ArrayList<Interval>();
        int i = 0;
        for(; i < intervals.size(); i++){
            Interval cur = intervals.get(i);
            if(cur.end >= newInterval.start){
                break;
            }
            res.add(cur);
        }
        
        res.add(newInterval);
        
        for(; i < intervals.size(); i++){
            Interval cur = intervals.get(i);
            Interval last = res.get(res.size()-1);
            if(cur.start > last.end){
                res.add(cur);
            }else{
                last.start = Math.min(last.start, cur.start);
                last.end = Math.max(last.end, cur.end);
            }
        }
        return res;
    }

```

<br>
<br>



###59 Spiral Matrix II

>Given an integer n, generate a square matrix filled with elements from 1 to n2 in spiral order.

<pre>
For example,
Given n = 3,

You should return the following matrix:
[
 [ 1, 2, 3 ],
 [ 8, 9, 4 ],
 [ 7, 6, 5 ]
]
</pre>

**Idea**: The idea is similar with spiral matrix. Actually, it's easier then the spiral matrix. Because now we can make sure that the matrix is a square matrix, thus we don't need to consider some corner cases like we did in spiral matrix. 


**Java code**:


```java

    public int[][] generateMatrix(int n) {
        int[][] matrix = new int[n][n];
        int num = 1;
        for(int i = 0; i < n/2+1; i++){
            for(int j = i; j < n - i; j++){
               matrix[i][j] = num++ ;
            }
            for(int j = i+1; j < n -i; j++){
               matrix[j][n-i-1] = num++;
            }
            for(int j = n-i-2; j >= i; j--){
               matrix[n-i-1][j] = num++;
            }
            for(int j = n - (i+2); j >= i+1; j--){
               matrix[j][i] = num++;
            }
       }
       return matrix;
    }

```



###61 Rotate List

> Given a list, rotate the list to the right by k places, where k is non-negative.

<pre>
For example:
Given 1->2->3->4->5->NULL and k = 2,
return 4->5->1->2->3->NULL.
</pre>

**Idea**: First calculate the length of list and record the tail, then move len - n steps. Connect tail and head, disconnect the (len-n)th and (len-n+1)th node.

**Attention**: 

- 1) we need to mode n = n%len
- 2) Take care of null pointer


code:
```java
      public ListNode rotateRight(ListNode head, int n) {
        if(n < 0 || head == null) return head;
        ListNode temp = head;
        int len = 0;
        ListNode tail = null;
        while(temp != null){
            len++;
            tail = temp;
            temp = temp.next;
        }
        n = n % len;
        len = len - n;
        if(n == 0 || len == 0) return head;
        temp = head;
        ListNode pre = null;
        while(len > 0){
            pre = temp;
            temp = temp.next;
            len--;
        }
        pre.next = null;
        tail.next = head;
        return temp;
    }

```
***Related problems***:

* [19 Remove Nth Node From End of List](#19-remove-nth-node-from-end-of-list)
* [21 Merge Two Sorted Lists](#21-merge-two-sorted-lists)
* [23 Merge k Sorted Lists](#23-merge-k-sorted-lists)
* [24 Swap Nodes in Pairs](#24-swap-nodes-in-pairs)
* [61 Rotate List](#61-rotate-list)
* [82 Remove Duplicates from Sorted List](#82-remove-duplicates-from-sorted-list)
* [83 Remove Duplicates from Sorted List II](#83-remove-duplicates-from-sorted-list-ii)
* [92 Reverse Linked List II](#92-reverse-linked-list-ii)
* [108 Convert Sorted Array to Binary Search Tree](#108-convert-sorted-array-to-binary-search-tree)
* [109 Convert Sorted List to Binary Search Tree](#109-convert-sorted-list-to-binary-search-tree)
* [114 Flatten Binary Tree to Linked List](#114-flatten-binary-tree-to-linked-list)
* [138 Copy List With Random Pointer](#138-copy-list-with-random-pointer)
* [141 Linked List Cycle](#141-linked-list-cycle)
* [142 Linked List Cycle II](#142-linked-list-cycle-ii)
* [143 Reorder List](#143-reorder-list)
* [147 Insertion Sort List](#147-insertion-sort-list)
* [148 Sort List](#148-sort-list)
* [160 Intersection of Two Linked Lists](#160-intersection-of-two-linked-lists)

<br>
<br>

###69 Sqrt

>Implement int sqrt(int x).

>Compute and return the square root of x.


**Idea**: The result = x/result, so each time we can give a better guess result = (result + x/result)/2 until we get the correct answer.

```java
	public int sqrt(int x){
		if(x < 1) return 0;
		double result = 1;
		while(Math.abs(x/result-result) > 0.000000001){
			result = (x/result + result)/2;
		}
		return (int)result;
	}
```	
**Other Idea**: Dichotomy. l = smallest possible result, r the largest possible result. mid = (l + r)/2 , check the relationship between mid and result

**Attention**: mid <= x/mid && (mid + 1) > x/(mid+1) can not change to mid * mid <= x && (mid+1) * (mid+1) > x. Because, when **mid * mid overflows**, the result might change, also, it might lead to Time limit exceeded.

```java
    public int sqrt(int x){
        if(x < 1) return 0;
        if(x == 1) return 1;
        int l = 1; 
        int r = x/2 + 1;
    	while(l <= r ){
    	    int mid = (l+r)/2;
    	    if(mid <= x/mid && (mid + 1) > x/(mid+1)) return mid;
    	    else if(mid > x/mid) r = mid - 1;
    	    else l = mid + 1;
    	}
    	return 0;
    }

```	
 

***Related Questions:***

* [7 Reverse Integer](#7-reverse-integer)
* [29 Divide Two Integers](#29-divide-two-integers)
* [50 Pow](#50-pow)
* [69 Sqrt](#69-sqrt)
* [166 Fraction to Recurring Decimal](#166-fraction-to-recurring-decimal)

<br>

<br>

###70 Climbing Stairs

>You are climbing a stair case. It takes n steps to reach to the top.

Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?

**Idea**: Each time we can climb 1 steps or 2 steps, thus Fn = Fn-1 + Fn-2. It's just a fibonacci sequence. 

**Solution1** Use dp, Time O(n), Space O(1)

```java
 public int climbStairs(int n){
        if(n == 0) return 1;
        if(n == 1) return 1;
        int n1 = 1;
        int n2 = 1;
        int n3 = 0;
        for(int i = 2; i <= n; i++){
            n3 = n1 + n2;
            n1 = n2;
            n2 = n3;
        }
        return n3;
    }
```    
 
 
 **Solution2**: Use matrix, O(lgn) time.
 
 ```java
 
   public int climbStairs2(int n){
        if(n < 0) return 0;
        if(n <= 1) return 1;
        int[][] res = {{1, 0}, {0, 1}};
        int[][] m = {{1, 1}, {1, 0}};
        while(n > 0){
            if(n % 2 == 1) res = multiplyMatrix(res, m);
            n = n/2;
            m = multiplyMatrix(m, m);
        }
        return res[0][0];
    }
    
    
    public int[][] multiplyMatrix(int[][] m, int[][]n){
        int a = m[0][0] * n[0][0] + m[0][1] * n[1][0];
        int b = m[0][0] * n[0][1] + m[0][1] * n[1][1];
        int c = m[1][0] * n[0][0] + m[1][1] * n[1][0];
        int d = m[1][0] * n[0][1] + m[1][1] * n[1][1];
        int[][] res = {{a, b}, {c, d}};
        return res;
    }
 
```

**Solution 3** : recursion, O(2 ^ n) time.
```java
    public int climbStairs(int n) {
        if(n < 0) return 0;
        if(n == 1 || n == 0) return 1;
        return climbStairs(n-1)+climbStairs(n-2);
    }
    
```

We see that the value of Fibonacci increases exponentially. If we use int, then we can only compute to F47, if we use long, we can compute to F96. So if our required numbers are big, it's unreasonable to use in/long as return value. We can use BigInteger in java. Eg:

```java

	public static String bigFib(int n){
    	if(n <= 0) return "0";
    	if(n == 1) return "1";
    	BigInteger n1 = new BigInteger("0");
    	BigInteger n2 = new BigInteger("1");
    	BigInteger n3 = new BigInteger("0");
        for(int i = 2; i <= n; i++){
        	n3 = n1.add(n2);
        	n1 = n2;
        	n2 = n3;
        }
        return n3.toString();
    	
    }
    

```

<br>
<br>

###73 Set Matrix Zeroes

>Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in place.

**Idea**: The easiest way to do this problem is record the rows of columns needed to be set to 0. We can use extra array to record the rows and columns. The space complexity would ba O(m+n). If we use one row and one column that are supposed to set to 0s to stroe the information, we can get O(1) space complexity.

**Java code**:

```java
public void setZeroes(int[][] matrix) {
        if(matrix == null || matrix.length == 0 || matrix[0].length == 0) return;
        int[] rzeros = new int[matrix.length];
        int[] czeros = new int[matrix[0].length];
        
        for(int i = 0; i < matrix.length; i++){
            for(int j = 0; j < matrix[0].length; j++){
                if(matrix[i][j] == 0) {
                    rzeros[i] = 1;
                    czeros[j] = 1;
                }
            }
        }
        for(int i = 0; i < rzeros.length; i++){
            if(rzeros[i] == 1){
                for(int j = 0; j < matrix[0].length; j++){
                    matrix[i][j] = 0;
                }
            } 
        }
        for(int i = 0; i < czeros.length; i++){
            if(czeros[i] == 1){
                for(int j = 0; j < matrix.length; j++){
                    matrix[j][i] = 0;
                }
            }
        }
    }

```



<br>
<br>

###74 Search a 2D Matrix
>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:

>Integers in each row are sorted from left to right.
The first integer of each row is greater than the last integer of the previous row.
For example,

>Consider the following matrix:

<pre>
[
  [1,   3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]
Given target = 3, return true.

</pre>

**Idea**:

*Solution 1*: We can search from the top-right, if the target is larger than current, then we move to next row. If the target is smaller, then we move to left.

Solution 2*: Use binary search to find the row, then in that row, use binary search to find the target.

**Attention**: In binary search, when loop ends, if target is not found, then l points to the first element larger than the target and r points to the first element smaller than target. 

**java code**:

```java
    public boolean searchMatrix(int[][] matrix, int target) {
        if(matrix == null || matrix.length == 0 || matrix[0].length == 0) return false;
        for(int i = 0; i < matrix.length; i++){
            for(int j = matrix[0].length-1; j >= 0; j--){
                if(matrix[i][j] == target) return true;
                else if(matrix[i][j] < target) break;
            }
        }
        return false;
    }

```

*solution 2*:
```java
    public boolean searchMatrix(int[][] matrix, int target) {
        if(matrix == null || matrix.length == 0 || matrix[0].length == 0) return false;
        int l = 0; 
        int r = matrix.length-1;
        while(l <= r){
            int mid = (l + r)/2;
            if(matrix[mid][0] == target) return true;
            else if(matrix[mid][0] < target) l = mid + 1;
            else r = mid -1;
        }
        int row = r;
        if(row < 0 || row >= matrix.length) return false;
        l = 0;
        r = matrix[0].length-1;
        while(l <= r){
            int mid = (l + r)/2;
            if(matrix[row][mid] == target) return true;
            else if(matrix[row][mid] < target) l = mid + 1;
            else r = mid -1;
        }
        return false;
    }

```

<br>
<br>

###75 Sort Colors


> Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue.

>Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.

>Note:
>You are not suppose to use the library's sort function for this problem. 

**Idea**:

- Solution 1: Use counting sort, we can count the numbers of 0, 1, 2, then refill numbers into A. **Note that this is not inplace**
- Solution 2: Use two pointers for 0 and 1, if we encounter 0, A[count1++] = 1, A[count0++] = 0, if we encounter 1, count1++

**Attention**: 

- 1) For the second method, the sequence of count1++ and count0++ is impoertant, we need first A[count1++] = 1
- 2) Everytime before we move the two pointers, we need to assgin A[i] = 2. Because we don't maintain a pointer for 2, thus the last part would be 2.

**Time complexity**

Use method1 need two pass. Method 2 only need one pass. 


**Java code Solution1**:

```java

    public void sortColors(int[] A) {
    	if(A == null || A.length == 0) return;
    	int count0 = 0;
    	int count1 = 0;
    	for(int i = 0; i < A.length; i++){
    		if(A[i] == 0) count0++;
    		else if(A[i] == 1) count1++;
    	}
    	for(int i = 0; i < A.length; i++){
    		if(i < count0) A[i] = 0;
    		else if(i >= count0 && i < count0+count1) A[i] = 1;
    		else A[i] = 2;
    	}
    }
    

```


**Java code solution 2**:

```java

    public void sortColors(int[] A) {
        if(A == null || A.length == 0) return;
        int count0 = 0, count1 = 0;
        for(int i = 0; i < A.length; i++){
            if(A[i] == 0){
                A[i] = 2;
                A[count1++] = 1;
                A[count0++] = 0;
            }else if(A[i] == 1){
                A[i] = 2;
                A[count1++] = 1;
            }
        }

    }
```



<br>
<br>



###80 Remove Duplicates From Sorted Array II

>Follow up for "Remove Duplicates":
>
>What if duplicates are allowed at most twice?
>
>For example,
>
>Given sorted array A = [1,1,1,2,2,3],
>
>Your function should return length = 5, and A is now [1,1,2,2,3].

**Idea**: It's the same method with [26 Remove Duplicates from Sorted Array](#26-remove-duplicates-from-sorted-array). Only diffence is that we need to compare with previous and previous previous element. 

**Java Code**:


```java

    public int removeDuplicates(int[] A) {
        if(A == null) return 0;
        if(A.length <= 2) return A.length;
        int count = 2;
        int pre = A[1];
        int prepre = A[0];
        for(int i = 2; i < A.length; i++){
            if(A[i] == pre && A[i] == prepre) continue;
            A[count++] = A[i];
            prepre = pre;
            pre = A[i];
        }
        return count;
    }
	

```

***Related Problems***:

* [26 Remove Duplicates from Sorted Array](#26-remove-duplicates-from-sorted-array)
* [27 Remove Element](#27-remove-element)
* [80 Remove Duplicates from Sorted Array II](#80-remove-duplicates-from-sorted-array)
* [82 Remove Duplicates from Sorted List](#82-remove-duplicates-from-sorted-list)
* [83 Remove Duplicates from Sorted List II](#83-remove-duplicates-from-sorted-list-ii)

<br>
<br>



###82 Remove Duplicates from Sorted List

>Given a sorted linked list, delete all duplicates such that each element appear only once.

For example,
Given 1->1->2, return 1->2.
Given 1->1->2->3->3, return 1->2->3.

**Idea**: It's simple compare to * [83 Remove Duplicates from Sorted List II](#83-remove-duplicates-from-sorted-list-ii). Because there are less corner cases related to null pointers. Just if head != null, start from the head.next, when encounter duplicates, delete that node. 

```java
   public ListNode deleteDuplicates(ListNode head) {
        if(head == null) return null;
        ListNode pre = head;
        ListNode temp = head.next;
        while(temp != null){
            if(temp.val == pre.val) {
                pre.next = temp.next;
                temp = temp.next;
            }else{
                pre = temp;
                temp = temp.next;
            }
        }
        return head;
    }

```    
***Related Problems***:

* [26 Remove Duplicates from Sorted Array](#26-remove-duplicates-from-sorted-array)
* [27 Remove Element](#27-remove-element)
* [80 Remove Duplicates from Sorted Array II](#80-remove-duplicates-from-sorted-array)
* [82 Remove Duplicates from Sorted List](#82-remove-duplicates-from-sorted-list)
* [83 Remove Duplicates from Sorted List II](#83-remove-duplicates-from-sorted-list-ii)

<br>
<br>

###83 Remove Duplicates from Sorted List II

>Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.

<pre>
For example,
Given 1->2->3->3->4->4->5, return 1->2->5.
Given 1->1->1->2->3, return 2->3.
</pre>

**Idea**:

1) Compare each node with it's next, count++ if duplicate is found. if head.val != head.next.val, then check if count == 1. If yes, add node, else reset head to 1 and  continue.


**Attention**: Remember to check count at the end. If count == 1, add the last node. else set result's tail.next = null. 

```java
    public ListNode deleteDuplicates(ListNode head) {
        if(head == null) return head;
        ListNode feakHead = new ListNode(-1);
        ListNode h1 = feakHead;
        int count = 1;
        while(head != null && head.next != null){
            if(head.val == head.next.val){
                head = head.next;
                count++;
            }else{
                if(count == 1){
                    h1.next = head;
                    head = head.next;
                    h1 = h1.next;
                }else{
                    head = head.next;
                    count = 1;
                }
            }
        }
        if(count == 1) h1.next = head;
        else h1.next = null;
        return feakHead.next;
    }
```


***Related Problems***:

* [26 Remove Duplicates from Sorted Array](#26-remove-duplicates-from-sorted-array)
* [27 Remove Element](#27-remove-element)
* [80 Remove Duplicates from Sorted Array II](#80-remove-duplicates-from-sorted-array)
* [82 Remove Duplicates from Sorted List](#82-remove-duplicates-from-sorted-list)
* [83 Remove Duplicates from Sorted List II](#83-remove-duplicates-from-sorted-list-ii)

<br>
<br>

###86 Partition List

>Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.

You should **preserve the original relative order** of the nodes in each of the two partitions.

<pre>
For example,
Given 1->4->3->2->5->2 and x = 3,
return 1->2->2->4->3->5.
</pre>

**Idea**: We need to preserve the original order, thus we can maintain two pointers, h1 and tail. h1 is the place we need to insert the element which smaller than x. tail is the end of the result list from which we add the elements equal or larger than x. 

**Attention**: We need to 
```java
    public ListNode partition(ListNode head, int x) {
        if(head == null) return null;
        ListNode feakHead = new ListNode(-1);
        ListNode h = feakHead;
        ListNode tail = feakHead;
        while(head != null){
            if(head.val >= x){
                tail.next = head;
                head = head.next;
                tail = tail.next;
                tail.next = null;
            }else{
                 ListNode saveH = h;
                 ListNode temp = h.next;
                 h.next = head;
                 head = head.next;
                 h = h.next;
                 h.next = temp;
                if(tail.equals(saveH)) tail = h;
            }
        }
        return feakHead.next;
    }

```
###89 Gray Code
>The gray code is a binary numeral system where two successive values differ in only one bit.

>Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.

>For example, given n = 2, return [0,1,3,2]. Its gray code sequence is:

>00 - 0

>01 - 1

>11 - 3

>10 - 2

>Note:
>For a given n, a gray code sequence is not uniquely defined.

>For example, [0,2,3,1] is also a valid gray code sequence according to the above definition.

>For now, the judge is able to judge based on one instance of gray code sequence. Sorry about that.

Let's first see a few example of gray code and find the laws to create gray code

	n = 1: 0 
		   1
	
	n = 2: 00 
		   01
		   11
		   10

	n = 3: 000
	       001
	       011
	       010
	       110
	       111
	       101
	       100
	       
	 n = 4: 0000
	 	    0001
	 	    0011
	 	    0010
	 	    0110
	 	    0111
	 	    0101
	 	    0100
	 	    1100
	 	    1101
	 	    1111
	 	    1110
	 	    1010
	 	    1011
	 	    1001
	 	    1000
		   
**Some laws from above** : we can find that the first half of  2 ^ n numbers could be create by add a 0 to 2 ^ (n-1) numbers. For the last half of 2 ^ n, we can add 1 to the reversed order number of 2 ^ (n-1). 

For example, based on 2 bit gray code, we can get the first half of 3 bit gray code by adding 0, eg: 000 001 011 010, for the last half, we first reverse the order 10, 11, 01, 00, then add 1 to each of them, we can get 110 111 101 100.

**Time Complexity**: we have 2 ^ n gray code numbers, thus the time complexity is 2 ^ n
**Space**: 2 ^ n
```java
    public List<Integer> grayCode(int n) {
        List<Integer> list = new ArrayList<Integer>();
        if(n < 0) return list;
        list.add(0);
        if(n == 0) return list;
        list.add(1);
        for(int i = 2; i <= n; i++){
            for(int j = list.size()-1; j >= 0; j--){
                list.add(list.get(j) + (1 <<(i-1)));
            }
        }
        return list;
     }
```
**Related Questions** : check if two bytes can be put successively in a gray code sequence.

**Idea**: we know that the neighbor gray code numbers is different with 1 bit. We need to check if these two numbers have only one bit diffenence.

```java
	public boolean isSuccesive(byte b1, byte b2){
		int count = 0;
		while(b1 > 0 || b2 > 0){
			if((b1 & 1) != (b2 & 1))
				count++;
			b1 >>>= 1;
			b2 >>>= 1;
		}
		return count == 1;
	}
```

If the numbers are unsigned numbers, we can first ^ then check if it is the power of 2
```java	
	temp = b1 ^ b2;
	
	return (temp > 0) && ((temp & -temp) == temp); 
	
	return (temp > 0) && ((temp & (temp -1)) == 0);
	
```	
<br>
<br>

###92 Reverse Linked List II

>Reverse a linked list from position m to n. Do it in-place and in one-pass.

<pre>

For example:
Given 1->2->3->4->5->NULL, m = 2 and n = 4,

return 1->4->3->2->5->NULL.

Note:
Given m, n satisfy the following condition:
1 ≤ m ≤ n ≤ length of list.
	
</pre>

**Idea**: 1) Find begining node of reverse. 2) reverse m-n 3) concatenate 

**Attention**:

- 1) when concatenate, take care of null pointer. ***(When use node.next, always check if node is null)***
- 2) If m == 1, what should we return? So check the previous node of the reverse list's head, if it's null, just return the reverse head. 
- 3) Take care of the steps. We need to move ***m-1*** steps to find the beginning of the reverse. We need take another ***n-m+1*** steps to reverse the nodes. 
```java
    public ListNode reverseBetween1(ListNode head, int m, int n) {
        if(head == null || head.next == null || (m == n)) return head;
        ListNode saveHead = head;
        ListNode preReverse = null;
        while(m-1 > 0){
            preReverse = head;
            head = head.next;
            m--;
            n--;
        }
        ListNode reverseHead = null;
        ListNode reverseTail = null;
        ListNode next = null;
        while(n-1 >= 0){
            n--;
            if(reverseHead == null){
                reverseHead = head;
                reverseTail = head;
                head = head.next;
                continue;
            }
            next = head.next;
            head.next = reverseHead;
            reverseHead = head;
            head = next;
        }
        if(preReverse != null) preReverse.next = reverseHead;
        if(reverseTail != null) reverseTail.next = head;
        if(preReverse == null) return reverseHead;
        return saveHead;
      }
```   
   <br>
 
     

Pretty much the save with the above, just change while to for:
```java
  public ListNode reverseBetween(ListNode head, int m, int n) {
    	if(head == null) return null;
    	if(m < 0) m = 0;
    	if(m > n){
    		int tempValue = m;
    		m = n;
    		n = tempValue;
    	}
    	
    	ListNode temp = head;
    	ListNode previousM = null;
    	
    	/* find node at m */
    	for(int i = 1; i < m && temp != null; i++){
    		previousM = temp;
    		temp = temp.next;
    	}
    	ListNode saveTemp = temp;
    	
    	/* reverse node between m and n */
    	ListNode pre = null;
    	ListNode next = null;
    	for(int i = m; i <= n && temp != null; i++){
    		next = temp.next;
    		temp.next = pre;
    		pre = temp;
    		temp = next;
    	}
    	
    	/* concatenate */
    	if(previousM != null) previousM.next = pre;
    	if(saveTemp != null) saveTemp.next = temp;
    	
    	if(m == 1) return pre; 
    	return head;
     }
     
``` 
 ***Related problems***:

* [19 Remove Nth Node From End of List](#19-remove-nth-node-from-end-of-list)
* [21 Merge Two Sorted Lists](#21-merge-two-sorted-lists)
* [23 Merge k Sorted Lists](#23-merge-k-sorted-lists)
* [24 Swap Nodes in Pairs](#24-swap-nodes-in-pairs)
* [61 Rotate List](#61-rotate-list)
* [82 Remove Duplicates from Sorted List](#82-remove-duplicates-from-sorted-list)
* [83 Remove Duplicates from Sorted List II](#83-remove-duplicates-from-sorted-list-ii)
* [92 Reverse Linked List II](#92-reverse-linked-list-ii)
* [108 Convert Sorted Array to Binary Search Tree](#108-convert-sorted-array-to-binary-search-tree)
* [109 Convert Sorted List to Binary Search Tree](#109-convert-sorted-list-to-binary-search-tree)
* [114 Flatten Binary Tree to Linked List](#114-flatten-binary-tree-to-linked-list)
* [138 Copy List With Random Pointer](#138-copy-list-with-random-pointer)
* [141 Linked List Cycle](#141-linked-list-cycle)
* [142 Linked List Cycle II](#142-linked-list-cycle-ii)
* [143 Reorder List](#143-reorder-list)
* [147 Insertion Sort List](#147-insertion-sort-list)
* [148 Sort List](#148-sort-list)
* [160 Intersection of Two Linked Lists](#160-intersection-of-two-linked-lists)

<br>
<br>


###94 Binary Tree Inorder Traversal

> Given a binary tree, return the inorder traversal of its nodes' values.

<pre>
For example:
Given binary tree {1,#,2,3},
   1
    \
     2
    /
   3
return [1,3,2].

</pre>

> Note: Recursive solution is trivial, could you do it iteratively?

**Idea**: 

- 1) Solution 1: Recursion. It's the simplest method. Just visit in left, root, right order.

- 2) Solution 2: Iterative. Use a stack to record the parant node, so we can go to it and its right child after visit its left child.

- 3) Solution 3 : Morris Traversal. Use a pointer to go back to its parent after visit it's left child. Note that use this method we only need O(1) space. Want to know more about Morris traversal click on this link. [Morris Traversal](http://wishyouhappy.github.io/2014/12/17/morris%20traversal-traverse%20a%20binary%20tree%20without%20stack/). 


**Solution 1, Recursion**:


```java

	    public List<Integer> inorderTraversal(TreeNode root) {
	        List<Integer> res = new ArrayList<Integer>();
	        helper(root, res);
	        return res;
	    }
	    public void helper(TreeNode root, List<Integer> res){
	        if(root == null) return;
	        helper(root.left, res);
	        res.add(root.val);
	        helper(root.right, res);
	    }


```



**Solution 2, Iterative**:

```java
    public static List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<Integer>();
        Stack<TreeNode> stack = new Stack<TreeNode>();
        while(!stack.isEmpty() || root != null){
            if(root != null){
                stack.push(root);
                root = root.left;
            }else{
                root = stack.pop();
                res.add(root.val);
                root = root.right;
            }
        }
        return res;
    }
    


```



**Solution 3: Morris Traversal**:

```java

    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<Integer>();
        TreeNode pre = null;
        while(root != null){
            if(root.left == null){
                res.add(root.val);
                root = root.right;
            }else{
                pre = root.left;
                while(pre.right != null && pre.right != root){
                    pre = pre.right;
                }
                if(pre.right == null){
                    pre.right = root;
                    root = root.left;
                }else{
                    pre.right = null;
                    res.add(root.val);
                    root = root.right;
                }
            }
        }
        return res;
        
    }

```


<br>
<br>



###95 Unique Binary Search Trees

> Given n, how many structurally unique BST's (binary search trees) that store values 1...n?

> For example,

> Given n = 3, there are a total of 5 unique BST's.

<pre>


   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3


</pre>



**Idea**: Consider a binary rooted at certain node node1, the number of unique binary trees would be #left sub-BST * #right sub-BST. So the total number of binary search tree would be sum of binary trees rooted at each node. 

This is similar to the [catalan numbers](http://en.wikipedia.org/wiki/Catalan_number). In this problem, we could use dynamic programming to store middle results.  


**Java code**:

```java
    public int numTrees(int n) {
        if(n <= 0) return 0;
    
        int result[] = new int[n+1];
        result[0] = 1;
        result[1] = 1;
        
        for(int i = 2; i <= n; i++){
        	for(int j = 0; j < i; j++){
        		result[i] += result[j] * result[i-j-1];
        	}
        }
        
        return result[n];
    }

```


<br>
<br>


###96 Unique Binary Search Trees II

> Given n, generate all structurally unique BST's (binary search trees) that store values 1...n.

<pre>
For example,
Given n = 3, your program should return all 5 unique BST's shown below.

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
confused what "{1,#,2,3}" means? > read more on how binary tree is serialized on OJ.

</pre>

**Idea**: The basic Idea is same as [95 Unique Binary Search Trees](#95-unique-binary-search-trees). We still need to create the left sub-BST and right sub-BST, then combine it with the root. 

This is a bottom up approach, we create the trees from leaves. The time complexity is not polynomial. 

**Attention**: In order to create all the combinations in the for loop. So when left subtree is null, we still need to add null to list. 

```java
	  public List<TreeNode> generateTrees(int n) {
	        List<TreeNode> res = new ArrayList<TreeNode>();
	        if(n < 0) return res;
	        return helper(1, n);
	    }
	    
	    public List<TreeNode> helper(int l, int r){
	        List<TreeNode> res = new ArrayList<TreeNode>();
	        if(l > r){
	            res.add(null);
	            return res;
	        }
	        
	        for(int i = l; i <= r; i++){
	            List<TreeNode> llist = helper(l, i-1);
	            List<TreeNode> rlist = helper(i+1, r);
	            for(int j = 0; j < llist.size(); j++){
	                for(int k = 0; k < rlist.size(); k++){
	                    TreeNode root = new TreeNode(i);
	                    root.left = llist.get(j);
	                    root.right = rlist.get(k);
	                    res.add(root);
	                }
	            }
	        }
	        return res;
	    }

```




<br>
<br>




###98 Validate Binary Search Tree

>Given a binary tree, determine if it is a valid binary search tree (BST).

Assume a BST is defined as follows:

The left subtree of a node contains only nodes with keys **less than** the node's key.
The right subtree of a node contains only nodes with keys **greater than** the node's key.
Both the left and right subtrees must also be binary search trees.

**Idea**: We know that if a tree is a binary search tree, then it's inorder traversal is sequential. Thus we can traverse the tree inorder to check if everynode's predecessor is less than the node. We can also traverse the tree inorder and save the sequence, then check if there is out of order nodes. But it will require addtional space. 

**Time**: O(n) **Space**: O(lgn)

```java
   public boolean isValidBST(TreeNode root) {
       if(root == null) return true;
       boolean[] result = new boolean[1];
       result[0] = true;
       helper(root, new TreeNode[1], result);
       return result[0];
   }
   
   public void helper(TreeNode root, TreeNode[] pre, boolean[] result){
       if(root == null) return;
       helper(root.left, pre, result);
       if(pre[0] != null && pre[0].val >= root.val) result[0] = false;
       pre[0] = root;
       helper(root.right, pre, result);
   }
```


**Other idea**: We record the lower bound and upper bound for each node. If a node's value is not between the lower bound and upper bound, return false. There is a problem with this method: if the tree contains nodes with value of Integer.MIN_VALUE AND Integer.MAX_VALUE. 

```java

    public boolean isValidBST1(TreeNode root) {  
        return helper1(root, Integer.MIN_VALUE, Integer.MAX_VALUE);   
    }  
    
    public boolean helper1(TreeNode root, int min, int max)     
    {    
        if(root == null)    
           return true;    
        if(root.val <= min || root.val >= max)  
             return false;    
         return helper1(root.left, min, root.val) && helper1(root.right, root.val, max);  
    }
	

```

**Wrong answer**: The following code just check if each node maintains node.val > node.left.val and node.val < node.right.val. However, even though each node satisfies this condition, it might not be a binary search tree. ***Eg: 10,5,15,#,#,6,20***

```java

  public boolean isValidBST1(TreeNode root) {
    	if(root == null) return true;
    	if(root.left == null && root.right == null) return true;
    	if(root.left != null && root.left.val >= root.val) return false;
    	if(root.right != null && root.right.val <= root.val) return false;
        return isValidBST(root.left) && isValidBST(root.right);
   }
   

```

<br>
<br>


###99 Recover Binary Search Tree

> Two elements of a binary search tree (BST) are swapped by mistake.

> Recover the tree without changing its structure.

> Note:

> A solution using O(n) space is pretty straight forward. Could you devise a constant space solution?

**Idea**: We can traverse the tree inorder to find the misplaced TreeNode. If we use recursion, we need O(n) space. If we use morris traversal, we can solve this problem in constant space. 


**Solution 1: O(n) space.**

```java
    public void recoverTree(TreeNode root) {
        if(root == null) return;
        TreeNode[] arr = new TreeNode[3];
        helper(root, arr);
        int temp = arr[0].val;
        arr[0].val = arr[1].val;
        arr[1].val = temp;
    }
    
    public void helper(TreeNode root, TreeNode[] arr){
        if(root == null) return;
        helper(root.left, arr);
        if(arr[2] != null && arr[2].val > root.val){
            if(arr[0] == null) arr[0] = arr[2];
            arr[1] = root;
        }
        arr[2] = root;
        helper(root.right, arr);
    }

```

**Solution2 : morris**

```java
	/*Morris traversal O(1) */
    public void recoverTree(TreeNode root) {
    	/* arr[0] arr[1] stroe two swapped elements, arr[2] store pre.*/
        TreeNode[] arr = new TreeNode[2];
        morrisTraversal(root, arr);
        int temp = arr[0].val;
        arr[0].val = arr[1].val;
        arr[1].val = temp;
    }
    
    
    public void morrisTraversal(TreeNode root, TreeNode[] arr){
		if(root == null) return;
		
		TreeNode pre = null; /* predecessor*/
		TreeNode previous = null;
		while(root != null){
			if(root.left == null){
				if( previous != null && previous.val > root.val){
		    		if(arr[0] == null) arr[0] = previous;
		    		arr[1] = root;
		    	}
				previous = root;
				root = root.right;
			}else{
				/* find predecessor */
				pre = root.left;
				while(pre.right != null && pre.right != root)
					pre = pre.right;
				
				/* if predecessor's right == null, set current node as its right child */
				if(pre.right == null){
					pre.right = root;
					root = root.left;
				}else{
					/* recover tree, when return to parent node the second time */
					pre.right = null;
					if( previous != null && previous.val > root.val){
			    		if(arr[0] == null) arr[0] = previous;
			    		arr[1] = root;
			    	}	
					previous = root;
					root = root.right;
				}
			}
		}
	}


```

<br>
<br>


###100 Same Tree

> Given two binary trees, write a function to check if they are equal or not.

>Two binary trees are considered equal if they are structurally identical and the nodes have the same value.


**Idea**: We can choose any traverse method to visit each node and check if they are the same. We need to check the val, the left child and the right child.


**Java code**:


```java
    public boolean isSameTree(TreeNode p, TreeNode q) {
        if(p == null && q == null) return true;
        if((p == null || q == null) || p.val != q.val) return false;
        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
    }
```

<br>

<br>


###103 Binary Tree Zigzag Level Order Traversal

> Given a binary tree, return the zigzag level order traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between).

<pre>
For example:
Given binary tree {3,9,20,#,#,15,7},
    3
   / \
  9  20
    /  \
   15   7
return its zigzag level order traversal as:
[
  [3],
  [20,9],
  [15,7]
]
</pre>

**Idea** we can solve this problem by changing a little bit about BFS. We need tp print zigzag, thus we print one row then reversely print next row. 

```java
	
	  public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        List<List<Integer>> list = new ArrayList<List<Integer>>();
    	if(root == null) return list;
    	Queue<TreeNode> queue = new LinkedList<TreeNode>();
    	queue.offer(root);
    	boolean inorder = true;
    	while(!queue.isEmpty()){
    	    List<Integer> cur = new ArrayList<Integer>();
    	    for(int i = 0, size = queue.size(); i < size; i++){
    	        TreeNode temp = queue.poll();
    	        cur.add(temp.val);
    	        if(temp.left != null) queue.offer(temp.left);
    	        if(temp.right != null) queue.offer(temp.right);
    	    }
    	    if(inorder == true){
    	        list.add(cur);
    	        inorder = false;
    	    }else{
    	        Collections.reverse(cur);
    	        list.add(cur);
    	        inorder = true;
    	    }
    	}
    	return list;
    }
    
```

<br>
<br>
    
###108 Convert Sorted Array to Binary Search Tree  

>Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.

**Idea**: 

Just find the mid of the list each time and create the tree from root.
root = mid
root.left = mid of (0, mid -1)
root.right = mid of (mid + 1, end)

**Time: O(n)**, because we need to traverse all the nodes. 

**Space** O(lg(n)) for recursion. 
```java

    public TreeNode sortedArrayToBST(int[] num) {
        if(num == null || num.length == 0) return null;
        return helper(num, 0, num.length-1);
    }
    public TreeNode helper(int[] num, int start, int end){
        if(start > end) return null;
        int mid = (start + end)/2;
        TreeNode root = new TreeNode(num[mid]);
        root.left = helper(num, start, mid-1);
        root.right = helper(num, mid + 1, end);
        return root;
    }
```
***Related problems***:

* [19 Remove Nth Node From End of List](#19-remove-nth-node-from-end-of-list)
* [21 Merge Two Sorted Lists](#21-merge-two-sorted-lists)
* [23 Merge k Sorted Lists](#23-merge-k-sorted-lists)
* [24 Swap Nodes in Pairs](#24-swap-nodes-in-pairs)
* [61 Rotate List](#61-rotate-list)
* [82 Remove Duplicates from Sorted List](#82-remove-duplicates-from-sorted-list)
* [83 Remove Duplicates from Sorted List II](#83-remove-duplicates-from-sorted-list-ii)
* [92 Reverse Linked List II](#92-reverse-linked-list-ii)
* [108 Convert Sorted Array to Binary Search Tree](#108-convert-sorted-array-to-binary-search-tree)
* [109 Convert Sorted List to Binary Search Tree](#109-convert-sorted-list-to-binary-search-tree)
* [114 Flatten Binary Tree to Linked List](#114-flatten-binary-tree-to-linked-list)
* [138 Copy List With Random Pointer](#138-copy-list-with-random-pointer)
* [141 Linked List Cycle](#141-linked-list-cycle)
* [142 Linked List Cycle II](#142-linked-list-cycle-ii)
* [143 Reorder List](#143-reorder-list)
* [147 Insertion Sort List](#147-insertion-sort-list)
* [148 Sort List](#148-sort-list)
* [160 Intersection of Two Linked Lists](#160-intersection-of-two-linked-lists)

<br>
<br>
 
###109 Convert Sorted List to Binary Search Tree
>Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.

**Idea**: 

1) solution1: Bottom-up

The list is sorted and we need to convert it to a **balanced BST**. When visit the linkedlist, we can only visit node by node. Thus we visit the nodes in ascending order: **Inorder Traversal !**. Thus, we create the binary tree **Bottom-up**. The bottom-up approach enables us to access the list in its order while creating nodes.

**Time O(n)**

**Space**: O(n) + O(lgn) = O(n)


2) solution2 : Top-down

Just find the mid of the list each time and create the tree from root.
root = mid
root.left = mid of (0, mid -1)
root.right = mid of (mid + 1, end)

**Time: O(nlgn)**

**Space**: O(n) + O(lgn) = O(n)

3) solution3: 

Store all the nodes in an array, then use the array to create the BST. just like the method in  * [108 Convert Sorted Array to Binary Search Tree](#108-convert-sorted-array-to-binary-search-tree). However, not recommend this method. If we do in this way, then this question is meaningless. 

**Time: O(n)**

**Space**: O(n) + O(lgn) = O(n)

*Solution1 code:*

<br>
```java
		public TreeNode sortedListToBST(ListNode head) {
		    if(head == null) return null;
		    int len = 0;
		    ListNode temp = head;
		    while(temp != null){
		        temp = temp.next;
		        len++;
		    }
		    ListNode[] saveHead = new ListNode[1];
		    saveHead[0] = head;
		    return helper(saveHead, 0, len-1);
		 }
		 public TreeNode helper(ListNode[] saveHead, int start, int end){
		    if(start > end) return null;
		    int mid = (start + end)/2;
		    TreeNode left = helper(saveHead, start, mid-1);
		    TreeNode root = new TreeNode(saveHead[0].val);
		    root.left = left;
		    saveHead[0] = saveHead[0].next;
		    root.right = helper(saveHead, mid + 1, end);
		    return root;
		 }
		 
```		 
*solution 2 code*

```java
 		public TreeNode sortedListToBST1(ListNode head) {
			    if(head == null) return null;
			    if(head.next == null) return new TreeNode(head.val);
			    ListNode pre = getMidPre(head);
			    ListNode mid = pre.next;
			    pre.next = null;
			    TreeNode root= new TreeNode(mid.val);
			    root.left = sortedListToBST(head);
			    root.right = sortedListToBST(mid.next);
			    return root;
			 }
			 
			 public ListNode getMidPre(ListNode head){
		        ListNode fast = head;  
		        ListNode pre = head;  
		        while(fast!=null) {  
		            fast = fast.next;  
		            if(fast != null){
		                fast = fast.next;  
		                pre = head;  
		                head = head.next;  
		            } 
		        }  
		        return pre;  
			 }

```			 
*solution3 code*

```java
	 public TreeNode sortedListToBST2(ListNode head) {
		    if(head == null) return null;
		    if(head.next == null) return new TreeNode(head.val);
	        int count = 0;
	        ListNode temp = head;
	        while(temp != null){
	            count++;
	            temp = temp.next;
	        }
	        int[] num = new int[count];
	        temp = head;
	        count = 0;
	        while(temp != null){
	            num[count++] = temp.val;
	            temp = temp.next;
	        }
	        return sortedArrayToBST(num);
		 }
		 
	    public TreeNode sortedArrayToBST(int[] num) {
	        if(num == null || num.length == 0) return null;
	        return helper(num, 0, num.length-1);
	    }
	    public TreeNode helper(int[] num, int start, int end){
	        if(start > end) return null;
	        int mid = (start + end)/2;
	        TreeNode root = new TreeNode(num[mid]);
	        root.left = helper(num, start, mid-1);
	        root.right = helper(num, mid + 1, end);
	        return root;
	    }

```		 
***Related problems***:

* [19 Remove Nth Node From End of List](#19-remove-nth-node-from-end-of-list)
* [21 Merge Two Sorted Lists](#21-merge-two-sorted-lists)
* [23 Merge k Sorted Lists](#23-merge-k-sorted-lists)
* [24 Swap Nodes in Pairs](#24-swap-nodes-in-pairs)
* [61 Rotate List](#61-rotate-list)
* [82 Remove Duplicates from Sorted List](#82-remove-duplicates-from-sorted-list)
* [83 Remove Duplicates from Sorted List II](#83-remove-duplicates-from-sorted-list-ii)
* [92 Reverse Linked List II](#92-reverse-linked-list-ii)
* [108 Convert Sorted Array to Binary Search Tree](#108-convert-sorted-array-to-binary-search-tree)
* [109 Convert Sorted List to Binary Search Tree](#109-convert-sorted-list-to-binary-search-tree)
* [114 Flatten Binary Tree to Linked List](#114-flatten-binary-tree-to-linked-list)
* [138 Copy List With Random Pointer](#138-copy-list-with-random-pointer)
* [141 Linked List Cycle](#141-linked-list-cycle)
* [142 Linked List Cycle II](#142-linked-list-cycle-ii)
* [143 Reorder List](#143-reorder-list)
* [147 Insertion Sort List](#147-insertion-sort-list)
* [148 Sort List](#148-sort-list)
* [160 Intersection of Two Linked Lists](#160-intersection-of-two-linked-lists)

<br>
<br>

###114 Flatten Binary Tree to Linked List
>Given a binary tree, flatten it to a linked list **in-place**.

<pre>
For example,
Given

         1
        / \
       2   5
      / \   \
     3   4   6
The flattened tree should look like:
   1
    \
     2
      \
       3
        \
         4
          \
           5
            \
             6

</pre>


**Idea**: From the structure of the original tree and result tree, we know that we need to traverse the tree preorder. We can solve it recursively or use a stack to record the right child. 

**Attention**: we can use a fake node pre so that each time we can add the current node to the right of pre, set pre.left = null and recursively solve this problem. Also, we need to save the right child, because the right child has changed when we visit the left child. 

*Reversion code* : 

```java
		public void flatten(TreeNode root){
		   if(root == null) return;
		   TreeNode[] pre  = new TreeNode[1];
		   pre[0] = new TreeNode(-1);
		   helper(root, pre);
		}
		
		public void helper(TreeNode root, TreeNode[] pre){
		    if(root == null) return;
		    TreeNode right = root.right;
		    pre[0].left = null;
		    pre[0].right = root;
		    pre[0] = root;
		    helper(root.left, pre);
		    helper(right, pre);
		}
```

*Stack*:

```java
	public void flatten(TreeNode root){
		   if(root == null) return;
		   TreeNode pre = new TreeNode(-1);
		   Stack<TreeNode> stack = new Stack<TreeNode>();
		   int status = 0;
		   while(!stack.isEmpty() || root != null){
		       if(status == 0){
		           if(root == null){
		               status = 1;
		               continue;
		           }
		           pre.right = root;
		           pre.left = null;
		           pre = root;
		           stack.push(root.right);
		           root = root.left;
		       }else{
		           root = stack.pop();
		           status = 0;
		       }
		   }
		}


```
<br>
***Related problems***:

* [19 Remove Nth Node From End of List](#19-remove-nth-node-from-end-of-list)
* [21 Merge Two Sorted Lists](#21-merge-two-sorted-lists)
* [23 Merge k Sorted Lists](#23-merge-k-sorted-lists)
* [24 Swap Nodes in Pairs](#24-swap-nodes-in-pairs)
* [61 Rotate List](#61-rotate-list)
* [82 Remove Duplicates from Sorted List](#82-remove-duplicates-from-sorted-list)
* [83 Remove Duplicates from Sorted List II](#83-remove-duplicates-from-sorted-list-ii)
* [92 Reverse Linked List II](#92-reverse-linked-list-ii)
* [108 Convert Sorted Array to Binary Search Tree](#108-convert-sorted-array-to-binary-search-tree)
* [109 Convert Sorted List to Binary Search Tree](#109-convert-sorted-list-to-binary-search-tree)
* [114 Flatten Binary Tree to Linked List](#114-flatten-binary-tree-to-linked-list)
* [138 Copy List With Random Pointer](#138-copy-list-with-random-pointer)
* [141 Linked List Cycle](#141-linked-list-cycle)
* [142 Linked List Cycle II](#142-linked-list-cycle-ii)
* [143 Reorder List](#143-reorder-list)
* [147 Insertion Sort List](#147-insertion-sort-list)
* [148 Sort List](#148-sort-list)
* [160 Intersection of Two Linked Lists](#160-intersection-of-two-linked-lists)

<br>
<br>

###118 Pascal Triangle

>Given numRows, generate the first numRows of Pascal's triangle.

<pre>
For example, given numRows = 5,
Return

[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]

</pre>


**Idea**: First row : 1. Then each row is calculated based on the last row. In each row the first element and the last element is 1. Thus val = j == 0 || j == pre.size() ? 1 : pre.get(j-1)+pre.get(j);

```java
            public List<List<Integer>> generate(int numRows) {
	        List<List<Integer>> list = new ArrayList<List<Integer>>();
	        if(numRows <= 0) return list;
	        List<Integer> firstR = new ArrayList<Integer>();
	        firstR.add(1);
	        list.add(firstR);
	        for(int i = 1; i < numRows; i++){
	            List<Integer> current = new ArrayList<Integer>();
	            List<Integer> pre = list.get(list.size()-1);
	            for(int j = 0; j <= pre.size(); j++){
	                int val = j == 0 || j == pre.size() ? 1 : pre.get(j-1)+pre.get(j);
	                current.add(val);
	            }
	            list.add(current);
	        }
	        return list;
	    }
	    

```
***Related Problems***:

* [118 Pascal Triangle](#118-pascal-triangle)
* [119 Pascal Triangle II](#119-pascal-triangle-ii)
* [120 Triangle](#120-triangle)

<br>
<br>


###119 Pascal Triangle II

>Given an index k, return the kth row of the Pascal's triangle.

For example, given k = 3,
Return [1,3,3,1].

Note:
Could you optimize your algorithm to use only O(k) extra space?

**Idea**: If we can only use O(k) space, then we need to store all rows info in a single array. So the current row is calculated based on the last row. Eg: the last row is 1 2 1, we need to replace it with 1 3 3 1. We can ignore the first 1. Then 3 = 1 + 2 = pre + list.get(j). We need to store the current elment before we overwrite it. 

If there is no other requirements, then we can just use the result in [118 Pascal Triangle](#118-pascal-triangle) and get the last row. 


**Attention**:

- 1) k = 3, we return the fourth row.
- 2) we need to store the current elment before we overwrite it. 

<br>

```java
     public List<Integer> getRow(int rowIndex) {
	List<Integer> list = new ArrayList<Integer>();
    	if(rowIndex < 0) return list;
    	list.add(1);
    	for(int i = 0; i < rowIndex; i++){
    	    int pre = 1;
    	    int current = 0;
    	    for(int j = 0; j < list.size(); j++){
    	        if(j == 0) continue;
    	        current = list.get(j);
    	        list.set(j, pre + list.get(j));
    	        pre = current;
    	    } 
    	    list.add(1);
    	}
        return list;
	}

```
***Related Problems***:

* [118 Pascal Triangle](#118-pascal-triangle)
* [119 Pascal Triangle II](#119-pascal-triangle-ii)
* [120 Triangle](#120-triangle)

<br>
<br>

###120 Triangle

>Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.

<pre>
For example, given the following triangle
[
     [2],
    [3,4],
   [6,5,7],
  [4,1,8,3]
]
The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).

Note:
Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.
</pre>

**Idea**: Begin from the second-last layer, calculate the min sum of the last layer and last second layer, then continue the second-last layer and third-last layer....eg: the sum of last layer and last-second layer: min(4, 1) + 6, min(1, 8) + 5, min(8, 3) + 7. If we are only allowed to use O(n) space, then we need to replace the sum each time.

For example: Assume we use int[] res = new int[triangle.get(triangle.size()-1).size()] to store the sum

<pre>

Original triangle:             

[							   
     [2],					   
    [3,4],					  
   [6,5,7],					   
  [4,1,8,3]                  
] 


res array:
11
9, 10
7, 6, 10
4, 1, 8, 3

</pre>

**Space**: O(n)


We can also calculate from the top layer, then go down. It's similar to the method above. It's easier to handle the index if we begin from the last layer.

```java
	public int minimumTotal(List<List<Integer>> triangle) {
	    if(triangle == null || triangle.size() == 0) return 0;
	    int[] res = new int[triangle.get(triangle.size()-1).size()];
	    for(int i = 0; i < res.length; i++){
	        res[i] = triangle.get(triangle.size()-1).get(i);
	    }
	    for(int i = triangle.size()-2; i >= 0; i--){
	        List<Integer> current = triangle.get(i);
	        for(int j = 0; j < current.size(); j++){
	            res[j] = Math.min(res[j], res[j+1]) + current.get(j);
	        }
	    }
	    return res[0];
	 }
```

**Solution 2**: From top to bottom:

```java
	/* from top to bottom */
	 public int minimumTotal1(List<List<Integer>> triangle) {
		   if(triangle == null || triangle.size() == 0) return 0;
		   int[] sum = new int[triangle.get(triangle.size()-1).size()];
		   sum[0] = triangle.get(0).get(0);
		   int min = Integer.MAX_VALUE;
		   for(int i = 1; i < triangle.size(); i++){
		       List<Integer> cur = triangle.get(i);
		       for(int j = cur.size() -1 ; j >= 0; j--){
		          if(j == cur.size()-1) sum[j] = cur.get(j) + sum[j-1];
		          else if(j == 0) sum[j] = cur.get(j) + sum[0];
		          else sum[j] = cur.get(j) + Math.min(sum[j], sum[j-1]);
		       }
		   }
		   for(int i = 0; i < sum.length; i++){
		       if(min > sum[i]) min = sum[i];
		   }
		   return min;
		 }
    


```

***Related Problems***:

* [118 Pascal's Triangle](#118-pascal's-triangle)
* [119 Pascal's Triangle II](#119-pascal's-triangle-ii)
* [120 Triangle](#120-triangle)

<br>
<br>

###121 Best Time to Buy and Sell Stock
>Say you have an array for which the ith element is the price of a given stock on day i.

> If you were only permitted to complete **at most one transaction** (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.

**Idea:** We are allowed at most one transaction. Thus we only need to maintain a local  min stock price before prices[i]. Traverse prices one pass to get the max profit.

**max = Math.max(max, prices[i] - min)** 

**min = Math.min(min, prices[i])**

**Time complexity**: O(n)
 
**Space** : O(1)

```java
	public int maxProfit(int[] prices){
		if(prices == null || prices.length == 0) return 0;
		int max = 0;
		int min = prices[0];
		for(int i = 1; i < prices.length; i++){
			max = Math.max(max, prices[i] - min);
			min = Math.min(min, prices[i]);
		}
		return max;
	}
```
Related problem: 

* [121 Best Time to Buy and Sell Stock](#121-best-time-to-buy-and-sell-stock)
* [122 Best Time to Buy and Sell Stock II](#122-best-time-to-buy-and-sell-stock-ii)
* [123 Best Time to Buy and Sell Stock III](#123-best-time-to-buy-and-sell-stock-iii)
* [188 Best Time to Buy and Sell Stock IV](#188-best-time-to-buy-and-sell-stock-iv)
	
<br>
<br>

###122 Best Time to Buy and Sell Stock II

>Say you have an array for which the ith element is the price of a given stock on day i.

>Design an algorithm to find the maximum profit. You may complete **as many transactions** as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).

**Idea:** We are allowed as many transactions. Thus we only need to each neighbor pair, if prices[i] > prices[i-1], we add the difference to our result. We can get the max one pass. 

**dif = Math.max(0, prices[i] - prices[i-1])** 

**max = max + dif** 

**Time complexity**: O(n) 

**Space** : O(1)
```java
	public int maxProfit(int[] prices){
		int max = 0;
		int dif = 0;
		for(int i = 1; i < prices.length; i++){
			dif = Math.max(0, prices[i] - prices[i-1]);
			max = max + dif;
		}
		return max;
	}
```	
Related problem: 

* [121 Best Time to Buy and Sell Stock](#121-best-time-to-buy-and-sell-stock)
* [122 Best Time to Buy and Sell Stock II](#122-best-time-to-buy-and-sell-stock-ii)
* [123 Best Time to Buy and Sell Stock III](#123-best-time-to-buy-and-sell-stock-iii)
* [188 Best Time to Buy and Sell Stock IV](#188-best-time-to-buy-and-sell-stock-iv)

<br>
<br>

###123 Best Time to Buy and Sell Stock III

>Say you have an array for which the ith element is the price of a given stock on day i. 
> 
>Design an algorithm to find the maximum profit. You may complete **at most two transactions**.

>Note:
>You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).

**Idea:** We are only allowed  at most two transactions. Thus, we can use two arrays to record the max profit before profits[i], including i, denote as l[i], and max profits after profits[i], including i, denote as r[i]. Then find the max of l[i] + r[i]. 

**Time complexity**: O(n) 

**Space** : O(n)
```java
	public int maxProfit(int[] prices){
		if(prices == null || prices.length <= 1) return 0;
		int[] l = new int[prices.length];
		int[] r = new int[prices.length];
		int max = 0;
		int min = prices[0];
		for(int i = 1; i < prices.length; i++){
			max = Math.max(max, prices[i] - min);
			min = Math.min(min, prices[i]);
			l[i] = max;
		}
		int maxR = prices[prices.length-1];
		max = 0;
		for(int i = prices.length - 2; i >= 0; i--){
			max = Math.max(max, maxR - prices[i]);
			maxR = Math.max(maxR, prices[i]);
			r[i] = max;
		}
		max = 0;
		for(int i = 0; i < prices.length; i++){
			max = Math.max(max, l[i] + r[i]);
		}
		return max;
	}
```	
**Another solution:** 

global[i][j]: denotes max profit, at most j transactions before day i: 

**global[i][j]=max(local[i][j],global[i-1][j])**

local[i][j]: denotes max profit, at most j transactions before day i, and last transaction is saled on day i: 

**local[i][j]=max(global[i-1][j-1]+max(diff,0),local[i-1][j]+diff)**

From above, we know that we can change the two dimensional array to one dimensional to save space. Because we only use two rows in the two dimensional array. 

**Time complexity**: O(n) 

**Space** : O(1) (O(k), but k is 2 in this problem)
```java
	public int maxProfit1(int[] prices){
		return maxProfit(prices, 2);
	}
	public int maxProfit(int[] prices, int k){
		if(prices == null || prices.length <= 1) return 0;
		int[] global = new int[k+1];
		int[] local = new int[k+1];
		for(int i = 1; i < prices.length; i++){
			int dif = prices[i] - prices[i-1];
			for(int j = k; j >= 1; j--){
				local[j] = Math.max(global[j-1] + Math.max(dif, 0), local[j] + dif);
				global[j] = Math.max(local[j], global[j]);
			}
		}
		return global[k];
	}
```
* [121 Best Time to Buy and Sell Stock](#121-best-time-to-buy-and-sell-stock)
* [122 Best Time to Buy and Sell Stock II](#122-best-time-to-buy-and-sell-stock-ii)
* [123 Best Time to Buy and Sell Stock III](#123-best-time-to-buy-and-sell-stock-iii)
* [188 Best Time to Buy and Sell Stock IV](#188-best-time-to-buy-and-sell-stock-iv)

<br>
<br>

###126 Word Ladder

>Given two words (start and end), and a dictionary, find the length of shortest transformation sequence from start to end, such that:


Only one letter can be changed at a time
Each intermediate word must exist in the dictionary
For example,

Given:

start = "hit"

end = "cog"

dict = ["hot","dot","dog","lot","log"]

As one shortest transformation is "hit" -> "hot" -> "dot" -> "dog" -> "cog",

return its length 5.

Note:

Return 0 if there is no such transformation sequence.

All words have the same length.

All words contain **only lowercase alphabetic characters**.




**Idea**: This shortest transformation ladder is just like a shortest path in a graph. We teat each string as a graph node. If these two strings only have one different char, then we add an edge to these two nodes. When we come to the end string, we find the shortest path. 

If we use bfs, we can use an additional lenqueue to record the path length of each node. 


**Attention**: 

- 1)Everytime, we visit a string in dict and add an edge, we need to remove it from dict. 
- 2) char arr = start.toCharArray() should be inside the first for while loop. Otherwise, it may change more than one character of the string. 



**Solution**:
```java
	public static int ladderLength(String start, String end, Set<String> dict) {
	        if(dict == null || dict.size() == 0 || start == null || end == null) return 0;
	        Deque<String> queue = new LinkedList<String>();
	        Deque<Integer> qlen = new LinkedList<Integer>();
	        queue.offer(start);
	        qlen.offer(1);
	        while(!queue.isEmpty()){
	            start = queue.pollFirst();
	            int len = qlen.pollFirst();
	            if(start.equals(end)) return len;
	            for(int i = 0; i < start.length(); i++){
	                char[] arr = start.toCharArray();
	                for(arr[i] = 'a'; arr[i] <='z'; arr[i]++){
	                    String s = new String(arr);
	                    if(dict.contains(s)){
	                        queue.addLast(s);
	                        qlen.addLast(len+1);
	                        dict.remove(s);
	                    }
	                }
	            }
	        }
	        return 0;
	    }
    
```

* [126 Word Ladder](#126-word-ladder)
* [127 word Ladder II](#127-word-ladder-ii)

<br>
<br>

###127 Word Ladder II

>Given two words (start and end), and a dictionary, find all shortest transformation sequence(s) from start to end, such that:

<pre>
Only one letter can be changed at a time
Each intermediate word must exist in the dictionary
For example,

Given:
start = "hit"
end = "cog"
dict = ["hot","dot","dog","lot","log"]
Return
  [
    ["hit","hot","dot","dog","cog"],
    ["hit","hot","lot","log","cog"]
  ]
Note:
All words have the same length.
All words contain only lowercase alphabetic characters.
</pre>


<br>
<span style="background-color:#303030 ">


**Idea**: Becuase we need to output all the shortest paths, thus we need to record the parent node in the path. Then build paths based on these parent nodes.

**Attention**:

- 1) we need to remove end from dict if dict contains end, otherwise, we might have duplicates.
- 2) When we find all the path to end, we can break and rebuild the paths.
- 3) We can not remove element immediately when we find an neighbors in dict, because one node might have two or more parents. Thus we need to remove it after we have build the relationships between the node and all its parents. *We can remove it at the beginning of the next while loop*
- 4) when add element to queue, check if queue has alreay contains this element.

</span>

<br>
```java
    public List<List<String>> findLadders(String start, String end, Set<String> dict) {
        List<List<String>> res = new ArrayList<List<String>>();
        if(dict == null || dict.size() == 0 || start == null || end == null) return res;
        /*if start equals end, we can return [[start, end]]*/
        if(start.equals(end)){
            List<String> temp = new ArrayList<String>();
            temp.add(start);
            temp.add(end);
            return res;
        }
        
        /*if dict contains end, remove end from dict, otherwise we might have duplicates */
        dict.remove(end); 
        
        Queue<String> queue = new LinkedList<String> ();
        
        /*store the parent node of each node*/
        Map<String, ArrayList<String>> map = new HashMap<String, ArrayList<String>>();
        queue.offer(start);
        for(String s : dict){
            map.put(s, new ArrayList<String>());
        }
        map.put(end, new ArrayList<String>());
        List<String> cur = new ArrayList<String>();
        
        while(!queue.isEmpty()){
            cur.clear();
            for(int i = 0, size = queue.size(); i < size; i++){
            	String temp = queue.poll();
                cur.add(temp);
                dict.remove(temp);
            }
            for(String s : cur){
                for(int i = 0; i < s.length(); i++){
                    char[] arr = s.toCharArray();
                    for(arr[i] = 'a'; arr[i] <= 'z'; arr[i]++){
                        String temp = new String(arr);
                        /* It's ok not add this sentence. just to jump unnecessary operations*/
                        if(temp.equals(s)) continue;
                        if(temp.equals(end)){
                            map.get(end).add(s);
                        }
                        if(dict.contains(temp)){
                            if(!map.containsKey(temp)){
                                map.put(temp, new ArrayList<String>());
                            }
                            map.get(temp).add(s);
                            if(!queue.contains(temp)) queue.offer(temp);
                        }
                    }
                }
            }
            
            if(map.get(end).size()>0) break;
        }
        
        List<String> path = new ArrayList<String>();
        path.add(end);
        buildPaths(map, res, end, start, path);
        return res;
 	}
 	
 	public void buildPaths(Map<String, ArrayList<String>> map, List<List<String>> res, String end, String start, List<String> path){
 	    if(end.equals(start)){
 	        List<String> apath = new ArrayList<String>(path);
 	        Collections.reverse(apath);
 	        res.add(apath);
 	        return;
 	    }
 	    List<String> pre = map.get(end);
 	    for(String s : pre){
 	        path.add(s);
 	        buildPaths(map, res, s, start, path);
 	        path.remove(path.size()-1);
 	    }
 	}
 	
```

***Related problems***:

* [126 Word Ladder](#126-word-ladder)
* [127 word Ladder II](#127-word-ladder-ii)

<br>
<br>


###135 Candy

> There are N children standing in a line. Each child is assigned a rating value.

> You are giving candies to these children subjected to the following requirements:

> Each child must have at least one candy.

> Children with a higher rating get more candies than their neighbors.

> What is the minimum candies you must give?

**Idea**: 

- 1) Solution1 : Traverse the array two times, left to right and right to left. In the first traverse, we calculate the min candy for each child based on its left neighbor. In the right to left traverse, we calculate the min candy for each child based on its right neighbor. It's easier to use 2 array and traverse three times. We can reduce it to 1 array and 2 pass. 

**Three pass, two array**

```java

 public static int candy(int[] ratings) {
        if(ratings == null || ratings.length == 0) return 0;
        int[] left = new int[ratings.length];
        left[0] = 1;
        for(int i = 1; i < ratings.length; i++){
            if(ratings[i] > ratings[i-1]) left[i] = left[i-1] +1;
            else left[i] = 1;
        }
        int[] right = new int[ratings.length];
        right[ratings.length - 1] = 1;
        for(int i = ratings.length - 2; i >= 0; i--){
             if(ratings[i] > ratings[i+1]){
                right[i] = right[i+1] + 1;
            }else right[i] = 1;
        }
        int res = 0;
        for(int i = 0; i < ratings.length; i++){
            res += Math.max(left[i], right[i]);
        }
        return res;
    }

```

<br>

**Two pass, one array**

```java

    public static int candy(int[] ratings) {
        if(ratings == null || ratings.length == 0) return 0;
        int[] left = new int[ratings.length];
        left[0] = 1;
        for(int i = 1; i < ratings.length; i++){
            if(ratings[i] > ratings[i-1]) left[i] = left[i-1] +1;
            else left[i] = 1;
        }
        int res = left[ratings.length-1];
        for(int i = ratings.length - 2; i >= 0; i--){
            int right = 1;
            if(ratings[i] > ratings[i+1]){
                right = left[i+1] + 1;
            }
            res += Math.max(right, left[i]);
            left[i] = right;
        }
        return res;
    }

```



<br>

- 2) solution 2: Brute force. O(n ^2 )

```java

    public static int candy(int[] ratings) {
    	if(ratings == null || ratings.length == 0) return 0;
    	
    	int preRating = ratings[0],
    		count = 1,
    		preCandy = 1,
    		lastIncreasingIndex = 0,
    		lastDecreasingIndex = 0,
    		lastIncreasingCandy = 1,
    		changeFlag = 0;
    	for(int i = 1, len = ratings.length; i < len; i++){
    		if(ratings[i] >= preRating){
    			if(changeFlag == 1){				
    				if(ratings[i] == preRating){
        				/*if increasing sequence is longer than deceasing sequence */
        				if(lastIncreasingCandy > lastDecreasingIndex - lastIncreasingIndex +1){
        					count += sumTools(lastDecreasingIndex - lastIncreasingIndex);
        				}else{
            				count -= lastIncreasingCandy;
            				count += sumTools(lastDecreasingIndex - lastIncreasingIndex+1);
        				}
    					count += 1;
    					preCandy = 1;
    				}else{
        				/*if increasing sequence is longer than deceasing sequence */
        				if(lastIncreasingCandy > lastDecreasingIndex - lastIncreasingIndex +1){
        					count += sumTools(lastDecreasingIndex - lastIncreasingIndex);
        				}else{
            				count -= lastIncreasingCandy;
            				count += sumTools(lastDecreasingIndex - lastIncreasingIndex +1);
        				}
    					count += 2;
        				preCandy = 2;
    				}
    				changeFlag = 0;
        			lastIncreasingIndex = i;
        			lastIncreasingCandy = preCandy;
        			preRating = ratings[i];
    				continue;
    			}else{
    				if(ratings[i] == preRating){
    					preCandy = 1;
    				}else{
    					preCandy++;
    				}
        			count += preCandy;
        			preRating = ratings[i];
        			lastIncreasingIndex = i;
        			lastIncreasingCandy = preCandy;
    			}
    			
    		}else{
    			lastDecreasingIndex = i;
    			preRating = ratings[i];
    			changeFlag = 1;
    			continue;
    		}
    	}
    	
    	if(changeFlag == 1){
    		if(lastIncreasingCandy > lastDecreasingIndex - lastIncreasingIndex +1){
				count += sumTools(lastDecreasingIndex - lastIncreasingIndex);
			}else{
				count -= lastIncreasingCandy;
				count += sumTools(lastDecreasingIndex - lastIncreasingIndex +1);
			} 
    	}
        return count;
    }
    
    public static int sumTools(int n){
    	int sum = 0;
    	for(int i = 1; i <= n; i++ ){
    		sum += i;
    	}
    	return sum;
    }

```




***Related problems***:

* [11 Container with Most Water](#11-container-with-most-water)
* [42 Trapping Rain Water](#42-trapping-rain-water)
* [135 Candy](#135-candy)

<br>
<br>


###138 Copy List With Random Pointer

>A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null. Return a deep copy of the list.
 

**Idea** :

**Solution1:**Copy each node in the list, then divide the list into two lists. For example: 1->2->3, we copy nodes and the list turns to 1->1->2->2->3->3. Then we divide it into two 1->2->3

**Attention**: ***we should copy the random pointer seperatel after we copy all the nodes***. At the beginning, I thought that I can copy the random pointer at the same time and just let it pointer to the same node with the original node, when breaking the list, I change the copy node's random to origin's random's next. It works only when the node that random pointer points to is after to the current pointer. What if it is before the current node? we might not able to find the random's next because when breaking the list we have changed the structure of the list. 

**Solution2**: Use hashmap store old and copy, then copy the random pointer

***Solution1 code***
```java
    public RandomListNode copyRandomList(RandomListNode head) {
        if(head == null) return null;
        RandomListNode temp = head;
        while(temp != null){
            RandomListNode next = temp.next;
            temp.next = new RandomListNode(temp.label);
            temp.next.next = next;
            temp = next;
        }
        temp = head;
        while(temp != null){
            if(temp.random != null){
                temp.next.random = temp.random.next;
            }
            temp = temp.next.next;
        }
        RandomListNode fakeHead = new RandomListNode(-1);
        RandomListNode copy = fakeHead;
        while(head != null){
            RandomListNode next = head.next.next;
            copy.next = head.next;
            copy = copy.next;
            copy.next = null;
            head.next = next;
            head = next;
        }
        return fakeHead.next;
    }
```    
***Solution2 code***
```java
 	public RandomListNode copyRandomList1(RandomListNode head) {
        if(head == null) return null;
        RandomListNode copy = new RandomListNode(-1);
        RandomListNode temp = head;
        HashMap<RandomListNode, RandomListNode> map = new HashMap<RandomListNode, RandomListNode>();
        while(temp != null){
            copy.next = new RandomListNode(temp.label);
            map.put(temp, copy.next);
            copy = copy.next;
            temp = temp.next;
        }
        copy = map.get(head);
        RandomListNode saveHead = copy;
        while(head != null){
            copy.random = map.get(head.random);
            head = head.next;
            copy = copy.next;
        }
        return saveHead;
    }
```
***Related problems***:

* [19 Remove Nth Node From End of List](#19-remove-nth-node-from-end-of-list)
* [21 Merge Two Sorted Lists](#21-merge-two-sorted-lists)
* [23 Merge k Sorted Lists](#23-merge-k-sorted-lists)
* [24 Swap Nodes in Pairs](#24-swap-nodes-in-pairs)
* [61 Rotate List](#61-rotate-list)
* [82 Remove Duplicates from Sorted List](#82-remove-duplicates-from-sorted-list)
* [83 Remove Duplicates from Sorted List II](#83-remove-duplicates-from-sorted-list-ii)
* [92 Reverse Linked List II](#92-reverse-linked-list-ii)
* [108 Convert Sorted Array to Binary Search Tree](#108-convert-sorted-array-to-binary-search-tree)
* [109 Convert Sorted List to Binary Search Tree](#109-convert-sorted-list-to-binary-search-tree)
* [114 Flatten Binary Tree to Linked List](#114-flatten-binary-tree-to-linked-list)
* [138 Copy List With Random Pointer](#138-copy-list-with-random-pointer)
* [141 Linked List Cycle](#141-linked-list-cycle)
* [142 Linked List Cycle II](#142-linked-list-cycle-ii)
* [143 Reorder List](#143-reorder-list)
* [147 Insertion Sort List](#147-insertion-sort-list)
* [148 Sort List](#148-sort-list)
* [160 Intersection of Two Linked Lists](#160-intersection-of-two-linked-lists)

<br>
<br>

###141 Linked List Cycle

>Given a linked list, determine if it has a cycle in it.

Follow up:
Can you solve it without using extra space?

**Idea**: Use two pointers, one pointer move one step each time, the other pointer move two step each time. If they encounter, then a cycle exist.

**Attention**: when check if they encounter, if check if they are null! Otherwise, if(f.equals(s)) will have null pointer. 
```java
    public boolean hasCycle(ListNode head) {
        if(head == null) return false;
        ListNode f = head;
        ListNode s = head;
        while(f != null){
            f = f.next;
            if(f != null) f = f.next;
            s = s.next;
            if(f == null) return false;
            if(f.equals(s)) return true;
        }
        return false;
    }
```
***Related problems***:

* [19 Remove Nth Node From End of List](#19-remove-nth-node-from-end-of-list)
* [21 Merge Two Sorted Lists](#21-merge-two-sorted-lists)
* [23 Merge k Sorted Lists](#23-merge-k-sorted-lists)
* [24 Swap Nodes in Pairs](#24-swap-nodes-in-pairs)
* [61 Rotate List](#61-rotate-list)
* [82 Remove Duplicates from Sorted List](#82-remove-duplicates-from-sorted-list)
* [83 Remove Duplicates from Sorted List II](#83-remove-duplicates-from-sorted-list-ii)
* [92 Reverse Linked List II](#92-reverse-linked-list-ii)
* [108 Convert Sorted Array to Binary Search Tree](#108-convert-sorted-array-to-binary-search-tree)
* [109 Convert Sorted List to Binary Search Tree](#109-convert-sorted-list-to-binary-search-tree)
* [114 Flatten Binary Tree to Linked List](#114-flatten-binary-tree-to-linked-list)
* [138 Copy List With Random Pointer](#138-copy-list-with-random-pointer)
* [141 Linked List Cycle](#141-linked-list-cycle)
* [142 Linked List Cycle II](#142-linked-list-cycle-ii)
* [143 Reorder List](#143-reorder-list)
* [147 Insertion Sort List](#147-insertion-sort-list)
* [148 Sort List](#148-sort-list)
* [160 Intersection of Two Linked Lists](#160-intersection-of-two-linked-lists)

<br>
<br>    

###142 Linked List Cycle II

>Given a linked list, return the node where the cycle begins. If there is no cycle, return null.

Follow up:
Can you solve it without using extra space?

**Idea**: 

- 1) Use the method in [141 Linked List Cycle](#141-linked-list-cycle) to check if cycle exist. 
- 2) when faster and slower encounters, change the faster to head, and move faster and slower one step each time until they encounter. At this time, the faster and slower point to the node where the cycle begins.

**Attention**: when check if they encounter, if check if they are null! Otherwise, if(f.equals(s)) will have null pointer. 
```java
    public ListNode detectCycle(ListNode head) {
        if(head == null) return null;
        ListNode f = head;
        ListNode s = head;
        while(f != null){
            f = f.next;
            if(f != null) f = f.next;
            s = s.next;
            if(f == null) return null;
            if(f.equals(s)) break;
        }
        f = head;
        while(f != null){
            if(f.equals(s)) return s;
            f = f.next;
            s = s.next;
        }
        return null;
    }
```
***Related problems***:

* [19 Remove Nth Node From End of List](#19-remove-nth-node-from-end-of-list)
* [21 Merge Two Sorted Lists](#21-merge-two-sorted-lists)
* [23 Merge k Sorted Lists](#23-merge-k-sorted-lists)
* [24 Swap Nodes in Pairs](#24-swap-nodes-in-pairs)
* [61 Rotate List](#61-rotate-list)
* [82 Remove Duplicates from Sorted List](#82-remove-duplicates-from-sorted-list)
* [83 Remove Duplicates from Sorted List II](#83-remove-duplicates-from-sorted-list-ii)
* [92 Reverse Linked List II](#92-reverse-linked-list-ii)
* [108 Convert Sorted Array to Binary Search Tree](#108-convert-sorted-array-to-binary-search-tree)
* [109 Convert Sorted List to Binary Search Tree](#109-convert-sorted-list-to-binary-search-tree)
* [114 Flatten Binary Tree to Linked List](#114-flatten-binary-tree-to-linked-list)
* [138 Copy List With Random Pointer](#138-copy-list-with-random-pointer)
* [141 Linked List Cycle](#141-linked-list-cycle)
* [142 Linked List Cycle II](#142-linked-list-cycle-ii)
* [143 Reorder List](#143-reorder-list)
* [147 Insertion Sort List](#147-insertion-sort-list)
* [148 Sort List](#148-sort-list)
* [160 Intersection of Two Linked Lists](#160-intersection-of-two-linked-lists)

<br>
<br>

###143 Reorder List

>Given a singly linked list L: L0→L1→…→Ln-1→Ln,
reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→…

You must do this in-place without altering the nodes' values.

For example,
Given {1,2,3,4}, reorder it to {1,4,2,3}.

**Idea**: We can solve this problem in two ways.
- 1) copy a reversed linked list, then insert half of the list into original list.
- 2) Reverse the last half of the list, then insert it into the first half. 

**Attention**: When reverse, remember to set the first node's next to null, otherwise their will have a loop. 


***Solution1 code ***:

```java
    public void reorderList(ListNode head) {
        if(head == null) return;
        ListNode copy = new ListNode(-1);
        int count = 0;
        ListNode temp = head;
        while(temp != null){
            ListNode current = new ListNode(temp.val);
            current.next = copy;
            copy = current;
            temp = temp.next;
            count++;
        }
        if(count <= 2) return;
        temp = head;
        ListNode next = null, copyNext = null, pre = null;
        for(int i = 0; i < count/2; i++){
            next = temp.next;
            copyNext = copy.next;
            temp.next = copy;
            copy.next = next;
            pre = copy;
            temp = next;
            copy = copyNext;
        }
        if(count % 2 != 0) temp.next = null;
        else pre.next = null;
    }

```    
***Solution2 code ***:
```java    
      public void reorderList1(ListNode head) {
        if(head == null || head.next == null || head.next.next == null) return;
        ListNode f = head;
        ListNode s = head;
        ListNode pre = null;
        while(f != null){
            f = f.next;
            if(f != null) f = f.next;
            pre = s;
            s = s.next;
        }
        pre.next = null;
        ListNode lastHalf = null;
        ListNode next = null;
        while(s != null){
        	next = s.next;
            if(lastHalf == null) {
            	lastHalf = s;
            	lastHalf.next = null;
            }else{
                s.next = lastHalf;
                lastHalf = s;
            }
            s = next;
        }
        ListNode temp = head;
        ListNode lastHalfNext = null;
        while(temp != null && lastHalf != null){
            next = temp.next;
            lastHalfNext = lastHalf.next;
            temp.next = lastHalf;
            lastHalf.next = next;
            temp = next;
            lastHalf = lastHalfNext;
        }
    }
```
***Related problems***:

* [19 Remove Nth Node From End of List](#19-remove-nth-node-from-end-of-list)
* [21 Merge Two Sorted Lists](#21-merge-two-sorted-lists)
* [23 Merge k Sorted Lists](#23-merge-k-sorted-lists)
* [24 Swap Nodes in Pairs](#24-swap-nodes-in-pairs)
* [61 Rotate List](#61-rotate-list)
* [82 Remove Duplicates from Sorted List](#82-remove-duplicates-from-sorted-list)
* [83 Remove Duplicates from Sorted List II](#83-remove-duplicates-from-sorted-list-ii)
* [92 Reverse Linked List II](#92-reverse-linked-list-ii)
* [108 Convert Sorted Array to Binary Search Tree](#108-convert-sorted-array-to-binary-search-tree)
* [109 Convert Sorted List to Binary Search Tree](#109-convert-sorted-list-to-binary-search-tree)
* [114 Flatten Binary Tree to Linked List](#114-flatten-binary-tree-to-linked-list)
* [138 Copy List With Random Pointer](#138-copy-list-with-random-pointer)
* [141 Linked List Cycle](#141-linked-list-cycle)
* [142 Linked List Cycle II](#142-linked-list-cycle-ii)
* [143 Reorder List](#143-reorder-list)
* [147 Insertion Sort List](#147-insertion-sort-list)
* [148 Sort List](#148-sort-list)
* [160 Intersection of Two Linked Lists](#160-intersection-of-two-linked-lists)

<br>
<br>

###147 Insertion Sort List	
> Sort a linked list using insertion sort.


**Idea**: It's similar to insertion sort array. The difference is that in array, if we want to insert i into (0....i-1), we can swap form i-1 if array[i] < array[i-1]. But we can not visit a linkedlist by index. What we can do is visit from the first element.

Something we can do to simplify the insert:
 
- 1) first check if current.val >= pre.val. If true, it's already in right place. we can just go to the next element. 
- 2) then check if current.val <= head.val. If true, we can just insert it before the head.
- 3) If it's not eh two cases above, we need to find the right place to insert the element. Because we have eliminate the corner case above, thus we just need to find the insertion spot, then change the relationship of the pointers.

If we add a fakeHead pointer to avoid the null pointer cases, we can have more concise code.

**Time***: O(n^2)

<br>
```java
    public ListNode insertionSortList(ListNode head) {
        if(head == null) return null;
        ListNode fakeHead = new ListNode(-1);
        ListNode cur = head;
        ListNode temp = fakeHead;
        while(cur != null){
            ListNode next = cur.next;
            ListNode pre = fakeHead;
            temp = fakeHead.next;
            while(temp != null && temp.val < cur.val){
                pre = temp;
                temp = temp.next;
            }
            pre.next = cur;
            cur.next = temp;
            cur = next;
        }
        return fakeHead.next;
    }
```

<br>

	/* Actually, in some cases the code below is a little faster then above. 	Because when the element is alreay in the right place, we don't need to find 	from the beginning */
```java	
	 public ListNode insertionSortList(ListNode head) {
	        if(head == null) return null;
	        ListNode cur = head.next;
	        ListNode preCur = head;
	        while(cur != null){
	            ListNode next = cur.next;
	            if(cur.val >= preCur.val){
	                preCur = cur;
	            }else if(cur.val <= head.val){
	                cur.next = head;
	                head = cur;
	                preCur.next = next;
	            }else{
	                ListNode insertPre = head;
	                ListNode temp = head.next;
	                while(temp != null && temp.val < cur.val){
	                    insertPre = temp;
	                    temp = temp.next;
	                }
	                insertPre.next = cur;
	                cur.next = temp;
	                preCur.next = next;
	            }
	            cur = next;
	        }
	        return head;
	    }
```
***Related problems***:

* [19 Remove Nth Node From End of List](#19-remove-nth-node-from-end-of-list)
* [21 Merge Two Sorted Lists](#21-merge-two-sorted-lists)
* [23 Merge k Sorted Lists](#23-merge-k-sorted-lists)
* [24 Swap Nodes in Pairs](#24-swap-nodes-in-pairs)
* [61 Rotate List](#61-rotate-list)
* [82 Remove Duplicates from Sorted List](#82-remove-duplicates-from-sorted-list)
* [83 Remove Duplicates from Sorted List II](#83-remove-duplicates-from-sorted-list-ii)
* [92 Reverse Linked List II](#92-reverse-linked-list-ii)
* [108 Convert Sorted Array to Binary Search Tree](#108-convert-sorted-array-to-binary-search-tree)
* [109 Convert Sorted List to Binary Search Tree](#109-convert-sorted-list-to-binary-search-tree)
* [114 Flatten Binary Tree to Linked List](#114-flatten-binary-tree-to-linked-list)
* [138 Copy List With Random Pointer](#138-copy-list-with-random-pointer)
* [141 Linked List Cycle](#141-linked-list-cycle)
* [142 Linked List Cycle II](#142-linked-list-cycle-ii)
* [143 Reorder List](#143-reorder-list)
* [147 Insertion Sort List](#147-insertion-sort-list)
* [148 Sort List](#148-sort-list)
* [160 Intersection of Two Linked Lists](#160-intersection-of-two-linked-lists)

<br>
<br>

###148 Sort List

> Sort a linked list in O(n log n) time using constant space complexity.

**Idea**: It require us to sort in O(nlgn) time. "Mergesort" and "Quicksort" is the typical O(nlgn) sort algorithm. When use merge sort, similar with mergesort an array, we fisrt need to find the mid of the list. (The typical two pointer method to find the middle). Then sort(left, mid-1), sort(mid , right) and merge the result.


<br>
```java
	   public ListNode sortList(ListNode head){
		    if(head == null || head.next == null) return head;
		    ListNode f = head;
		    ListNode s = head;
		    ListNode pre = null;
		    while(f != null){
		        f = f.next;
		        if(f != null){
		            f = f.next;
		            pre = s;
		            s = s.next;
		        }
		    }
		    pre.next = null;
		    return merge(sortList(s), sortList(head));
		}
		
		public ListNode merge(ListNode l1, ListNode l2){
		    if(l1 == null) return l2;
		    if(l2 == null) return l1;
		    ListNode fakeHead = new ListNode(-1);
		    ListNode temp = fakeHead;
		    while(l1 != null && l2 != null){
		        if(l1.val > l2.val){
		            temp.next = l2;
		            l2 = l2.next;
		        }else{
		            temp.next = l1;
		            l1 = l1.next;
		        }
		        temp = temp.next;
		    }
		    if(l1 != null) temp.next = l1;
		    if(l2 != null) temp.next = l2;
		    return fakeHead.next;
		}
```		
***Related problems***:

* [19 Remove Nth Node From End of List](#19-remove-nth-node-from-end-of-list)
* [21 Merge Two Sorted Lists](#21-merge-two-sorted-lists)
* [23 Merge k Sorted Lists](#23-merge-k-sorted-lists)
* [24 Swap Nodes in Pairs](#24-swap-nodes-in-pairs)
* [61 Rotate List](#61-rotate-list)
* [82 Remove Duplicates from Sorted List](#82-remove-duplicates-from-sorted-list)
* [83 Remove Duplicates from Sorted List II](#83-remove-duplicates-from-sorted-list-ii)
* [92 Reverse Linked List II](#92-reverse-linked-list-ii)
* [108 Convert Sorted Array to Binary Search Tree](#108-convert-sorted-array-to-binary-search-tree)
* [109 Convert Sorted List to Binary Search Tree](#109-convert-sorted-list-to-binary-search-tree)
* [114 Flatten Binary Tree to Linked List](#114-flatten-binary-tree-to-linked-list)
* [138 Copy List With Random Pointer](#138-copy-list-with-random-pointer)
* [141 Linked List Cycle](#141-linked-list-cycle)
* [142 Linked List Cycle II](#142-linked-list-cycle-ii)
* [143 Reorder List](#143-reorder-list)
* [147 Insertion Sort List](#147-insertion-sort-list)
* [148 Sort List](#148-sort-list)
* [160 Intersection of Two Linked Lists](#160-intersection-of-two-linked-lists)

<br>
<br>

###155 Min Stack
>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.
<pre>
push(x) -- Push element x onto stack.
pop() -- Removes the element on top of the stack.
top() -- Get the top element.
getMin() -- Retrieve the minimum element in the stack.
</pre>


**Idea**: Memory limits. If we just a corresponding minstack with the same length of the stack, we would exceed the limit on leetcode. What should we do? We just need to keep the current smallest element. Eg: push(1) to stack, we push(1) to minstack. Next time we push(2) to stack, we don't need to push(2) to minstack. Because the min value is still 1. Thus, every time we push an element to stack, we check if element x > minstack.peek(), if true, we don't need to push. When pop, we check if element x == minstack.peek(), if equals, minstack.pop().

**Attention** : Duplicate elements. (less or equal than, push into min stack). Eg: push (0), push(1), push(0), the minstack should have element 0, 0. 


```java

public class MinStack {
	 Stack<Integer> stack; 
	   Stack<Integer> minstack;
	   public MinStack(){
	       stack = new Stack<Integer>();
	       minstack = new Stack<Integer>();
	   }
	    public void push(int x){
	        stack.push(x);
	        if(minstack.isEmpty() || minstack.peek() >= x)
	            minstack.push(x);
	    }
	    
	    public void pop(){
	        if(stack.isEmpty()) return;
	        int val = stack.pop();
	        if(val == minstack.peek()) minstack.pop();
	    }
	    
	    public int top(){
	        if(stack.isEmpty()) return -1;
	        return stack.peek();
	    }
	    
	    public int getMin(){
	    	if(stack.isEmpty()) return -1;
	    	return minstack.peek();
	    }
	}

```
 		
    
### 156 Binary Tree Upside Down

> Given a binary tree where all the right nodes are either leaf nodes with a sibling (a left node that shares th> e same parent node) or empty, flip it upside down and turn it into a tree where the original right nodes turned into left leaf nodes. Return the new root.

<pre>
For example:
Given a binary tree {1,2,3,4,5},
    1
   / \
  2   3
 / \
4   5

return the root of the binary tree [4,5,2,#,#,3,1].
   4
  / \
 5   2
    / \
   3   1  				   
   
</pre>

**Idea:** The structure of the tree: 

* 1) right child doesn't have children
* 2) If right child exist, left child must exist. 

Structure of result tree:

* 1) Right child turn to left child: p.left = parent.right

2) Parant becomes right child: p.right = parent 
* 3) Left child becomes root. 
```java
		public TreeNode upsideDownBinaryTree(TreeNode root){
			TreeNode parent = null, rightChild = null, leftChild = null;
			while(root != null){
				leftChild = root.left;
				root.left = rightChild; //  Right child turn to left child
				rightChild = root.right;
				root.right = parent;   //Parant becomes right child
				parent = root;
				root = leftChild;  //Left child becomes root
			}
			return parent;	
		}	

```
<br>
<br>


### 157 Read N Characters Given Read4 

> The API: int read4(char *buf) reads 4 characters at a time from a file.
> 
> The return value is the actual number of characters read. For example, it returns 3 if there is only 3 characters left in the file.

> By using the read4 API, implement the function int read(char *buf, int n) that reads n characters from the file.
> 
> Note:The read function will only be called once for each test case.

**Idea:**Iterative call read4 before end of file or each n, store and copy it to the destination buf. 

**Ambiguity:**What if n exceeds the buf's length? 
```java
	/* read 4 characters each time, return the exact number of characters read. */
	int read(char[] buf);
	public int read(char[] buf, int n){
		char[] buffer = new char[4];
		int count = 0;
		int current = 0;
		int needAdd = 0;
		while(true){
			current = read(buffer);
			if(current == 0 || n == count) return count;
			needAdd = Math.min(n-count, current);
			for(int i = 0; i < needAdd; i++){
				buf[count++] =  buffer[i];
			}
		}
	}
```	
Related problem:

* [157 Read N Characters Given Read4](#157-read-n-characters-given-read4)
* [158 Read N Characters Given Read4 II - Call multiple times](#158-read-n-characers-given-read4-ii-call-multiple-times) 

<br>
<br>

	

### 158 Read N Characters Given Read4 II - Call multiple times. 

> The API: int read4(char *buf) reads 4 characters at a time from a file.

> The return value is the actual number of characters read. For example, it returns 3 if there is only 3 characters left in the file.

> By using the read4 API, implement the function int read(char *buf, int n) that reads n characters from the file.

> Note:
> The read function may be called multiple times.


**Idea:** Because the read function maybe called multiple times, so at the next call, there might be some data remain in the read4 buffer due to the up amount data of n at each readN bytes call. So we need to keep track of the state of read 4 buffer. If there remains data at read4 buffer at the call, we need start from that position instead of call read4 function. 

```java
	/* read 4 characters each time, return the exact number of characters read. */
	int read(char[] buf);
	int read4Ptr = 0;
	int read4Count = 0;
	char[] buffer = new char[4];
	public int read(char[] buf, int n){	
		int count = 0;
		while(true){
			if(read4Ptr == 0){
				read4Count = read(buffer);
			}
			if(read4Count == 0 || n == count) return count;
			while(count < n && read4Ptr < read4Count){
				buf[count++] =  buffer[read4Ptr++];
			}
			read4Ptr = read4Ptr%read4Count;
			
		}
	}
```	
Related problem:

* [157 Read N Characters Given Read4](#157-read-n-characters-given-read4)
* [158 Read N Characters Given Read4 II - Call multiple times](#158-read-n-characers-given-read4-ii-call-multiple-times) 

<br>
<br>


### 159 Longest String with At Most Two Distinct Characters
> Given a string, find longest substring T that contains at most 2 distinct characters.For example, Given s = “eceba”,T is "ece" which its length is 3.

**Idea**: Using a slide window keep track of the substring with at most 2 distinct characters. Each time we encounter the third distinct character, we first calculate the length of the substring, then we move the start position of our slide window to the position that contains only the third character, the first character or the third character, the second character. 

**Example:** Assume the string is accacccbac....., when we encounter "b" at index 7, we calculate the length of substring accaccc and do related operations, then we move the start position of slide window to index 4, then keep going... 

**Solution && time complexity:**	Time complexity: O(n), map contains only two elements. Here, we can use two variables to replace the hashmap, if we extend the problem to k characters, then hashmap maybe more convenient 

```java
	public String subString(String s){
		int start = 0; // start of longest substring
		int end = 0;   // end of longest substring
		int j = 0;     // start of slide window
		int max = 0;
		Map<Character, Integer> map = new HashMap<Character, Integer>();
		for(int i = 0; i < s.length(); i++){
			//check: contains <= 2 characters && substring ends at the end 
			if(i == s.length()-1 && map.size() <= 2 && map.containsKey(s.charAt(i))){
				if(end == 0) return s;
				else{
					if(max < s.length() - j){
						start = j;
						end = s.length()-1;	
					}
				}
			}
			if(map.size() == 2 && !map.containsKey(s.charAt(i))){
				if(max < i - j){
					max = i - j ;
					start = j;
					end = i-1;
				}
				j = s.length();
				char needToRemove = ' ';
				for(char c : map.keySet()){
					if(j > map.get(c)){
						j = map.get(c);
						needToRemove = c;
					}
				}
				j++;
				map.remove(needToRemove);
			}
				map.put(s.charAt(i), i);
		}
		return s.substring(start, end+1);
	
	
```	

**Another way**: This is **not as fast as** the method above. If we encounter the third different element, we can find back from this element and reset the start window to make it contains only two different elements.

```java
	public String subStr(String s){
		if(s == null || s.length() == 0) return s;
		Map<Character, Integer> map = new HashMap<Character, Integer>();
		int start = 0;
		int max = 0;
		int end = 0;
		int j = 0;
		for(int i = 0; i < s.length(); i++){
			if(i == s.length()-1 && map.size() <= 2 && map.containsKey(s.charAt(i))){
				if(end == 0) return s;
				else{
					if(max < s.length() - j){
						start = j;
						end = s.length()-1;	
					}
				}
			}
			if(!map.containsKey(s.charAt(i)) && map.size() == 2){
				if(i - j > max){
					start = j;
					end = i-1;
					max = i-j;
				}
				int temp = i-1;
				char c = s.charAt(temp);
				while(temp >= 0 && s.charAt(temp) == c) temp--;
				j = temp + 1;
				map.remove(s.charAt(temp));
			}
			map.put(s.charAt(i), i);
		}
		return j == 0 ? s : s.substring(start, end+1);
		
	}

```
**Extention:** Find the longest substring contains at most k unique elements. Idea is much similar with k = 2. When we encounter the k+1 character, we need to calculate the length of string do related operations and move slide window, let it contains only k-1 different characters, add the k+1 character, and keep going.  

**Time Complexity:** O(k * n)

```java
	public String subString(String s, int k){
		int start = 0; // start of longest substring
		int end = 0;   // end of longest substring
		int j = 0;     // start of slide window
		int max = 0;
		Map<Character, Integer> map = new HashMap<Character, Integer>();
		for(int i = 0; i < s.length(); i++){
			//check: contains <= 2 characters && substring ends at the end 
			if(i == s.length()-1 && map.size() <= k && map.containsKey(s.charAt(i))){
				if(end == 0) return s;
				else{
					if(max < s.length() - j){
						start = j;
						end = s.length()-1;	
					}
				}
			}
			if(map.size() == k && !map.containsKey(s.charAt(i))){
				if(max < i - j){
					max = i - j ;
					start = j;
					end = i-1;
				}
				j = s.length();
				char needToRemove = ' ';
				for(char c : map.keySet()){
					if(j > map.get(c)){
						j = map.get(c);
						needToRemove = c;
					}
				}
				j++;
				map.remove(needToRemove);
			}
				map.put(s.charAt(i), i);
		}
		return s.substring(start, end+1);
	}
```

***Related Problems***

* [3 Longest Substring without Repeating Characters](#3-longest-substring-without-repeating-characters))

* [159 Longest String with At Most Two Distinct Characters](#159-longest-string-with-at-most-two-distinct-characters)

<br>


###160 Intersection of Two Linked Lists
>Write a program to find the node at which the intersection of two singly linked lists begins.


<pre>
For example, the following two linked lists:

A:          a1 → a2
                   ↘
                     c1 → c2 → c3
                   ↗            
B:     b1 → b2 → b3

begin to intersect at node c1.

</pre>


Notes:

If the two linked lists have no intersection at all, return null.

The linked lists must retain their original structure after the function returns.

You may assume there are no cycles anywhere in the entire linked structure.

Your code should preferably run in O(n) time and use only O(1) memory.


<br>

**Idea**: 

Solustion1: 

We can get the length of two linkedlist, assume len1 > len2. We move head1 move len1-len2 steps, then compare each node in list1 and list2, until two lists have the same nodes. 

Solution2: We don't need to calculae the length of list1 and list2. Use two pointers p1 p2, when one pointer reaches the end, assume it's p1, we change p1  to head2. Then continues until p2 reach to the end. By this time, p1 is pointer to len2 -len1 of list2, we let p2 points to head1. So we can continue to compare until we encounter same nodes. 


**Attention**: Null pointer! We need to take care of null pointer for all linkedlist problems.

Solution1 :
```java
	 public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
	       if(headA == null || headB == null) return null;
	       int lenA = 0;
	       int lenB = 0;
	       ListNode temp = headA;
	       while(temp != null){
	           lenA++;
	           temp = temp.next;
	       }
	       temp = headB;
	       while(temp != null){
	           temp = temp.next;
	           lenB++;
	       }
	       int diff = Math.abs(lenA - lenB);
	       if(lenA > lenB){
	           while(diff > 0) {
	               headA = headA.next;
	               diff--;
	           }
	       }else{
	           while(diff > 0){
	               headB = headB.next;
	               diff--;
	           }
	       }
	       while(headA != null && headB != null && !headA.equals(headB)){
	           headA = headA.next;
	           headB = headB.next;
	       }
	       return headA;
	 }
```
Solution2:
```java
	 public ListNode getIntersectionNode2(ListNode headA, ListNode headB) {
	       if(headA == null || headB == null) return null;
	       ListNode tempA = headA;
	       ListNode tempB = headB;
	       while(tempA != null && tempB != null){
	           tempA = tempA.next;
	           tempB = tempB.next;
	       }
	       tempA = tempA == null ? headB : tempA;
	       tempB = tempB == null? headA : tempB;
	       while(tempA != null && tempB != null){
	           tempA = tempA.next;
	           tempB = tempB.next;
	       }
	      tempA = tempA == null ? headB : tempA;
	      tempB = tempB == null ? headA : tempB;
	      while(tempA != null && tempB != null && !tempA.equals(tempB)){
	          tempA = tempA.next;
	          tempB = tempB.next;
	      }
	      return tempA;
	 }
```
***Related problems***:

* [19 Remove Nth Node From End of List](#19-remove-nth-node-from-end-of-list)
* [21 Merge Two Sorted Lists](#21-merge-two-sorted-lists)
* [23 Merge k Sorted Lists](#23-merge-k-sorted-lists)
* [24 Swap Nodes in Pairs](#24-swap-nodes-in-pairs)
* [61 Rotate List](#61-rotate-list)
* [82 Remove Duplicates from Sorted List](#82-remove-duplicates-from-sorted-list)
* [83 Remove Duplicates from Sorted List II](#83-remove-duplicates-from-sorted-list-ii)
* [92 Reverse Linked List II](#92-reverse-linked-list-ii)
* [108 Convert Sorted Array to Binary Search Tree](#108-convert-sorted-array-to-binary-search-tree)
* [109 Convert Sorted List to Binary Search Tree](#109-convert-sorted-list-to-binary-search-tree)
* [114 Flatten Binary Tree to Linked List](#114-flatten-binary-tree-to-linked-list)
* [138 Copy List With Random Pointer](#138-copy-list-with-random-pointer)
* [141 Linked List Cycle](#141-linked-list-cycle)
* [142 Linked List Cycle II](#142-linked-list-cycle-ii)
* [143 Reorder List](#143-reorder-list)
* [147 Insertion Sort List](#147-insertion-sort-list)
* [148 Sort List](#148-sort-list)
* [160 Intersection of Two Linked Lists](#160-intersection-of-two-linked-lists)

<br>
<br>


###166 Fraction to Recurring Decimal

>Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.
	
>If the fractional part is repeating, enclose the repeating part in parentheses.

	For example,

	Given numerator = 1, denominator = 2, return "0.5".
	Given numerator = 2, denominator = 1, return "2".
	Given numerator = 2, denominator = 3, return "0.(6)".

<br>

**Idea**: Just do the divide like what we normally do in math. 

For example, 3/7 

- quotient = 0, remainer = 3 , string = 0.
- **3 * 10/7** quotient = 4, remainder = 2; string = 0.4
- 2 * 10/ 7 quotient = 2, remainder = 6; string = 0.42
- 6 * 10/7 quotient = 8, remainder = 4; string = 0.428
- 4 * 10 /7 quotient = 5, remainder = 5; string = 0.4285
- 5 * 10/7 quotient = 7, remainder = 1, string = 0.42857
- 1 * 10/7 quotient = 1, remainder = 3, string = 0.428571
- **3 * 10/7**

Thus, we know the result is 0.(428571)

In order to know when the recuisive begins, we need to record the remainder at each iteration.

**Attention**

- 1)We need to do abs for both numbers, otherwise, there might be unnecessary "-" in the result string
- 2)abs(Integer.MIN_VALUE)
- 3)use hashmap to record the position of each remainder.


<br>
```java
    public String fractionToDecimal(int numerator, int denominator) {
        if(denominator == 0 || numerator == 0) return "0";
        StringBuilder res = new StringBuilder();
        Map<Long, Integer> map = new HashMap<Long, Integer>();
        boolean positive = ((numerator ^ denominator) >>> 31) == 0;
        if(!positive) res.append("-");
        long num = Math.abs((long)numerator);
        long den = Math.abs((long)denominator);
        res.append(num/den);
        if(num % den == 0) return res.toString();
        res.append(".");
        long mod = num % den;
        while(mod != 0){
            if(map.containsKey(mod)){
                res.insert(map.get(mod), "(");
                res.append(")");
                return res.toString();
            }
            map.put(mod, res.length());
            mod = mod * 10;
            long divide = mod/den;
            mod = mod % den;
            res.append(divide);
        }
        return res.toString();
    }

```

***Related Questions:***

* [7 Reverse Integer](#7-reverse-integer)
* [29 Divide Two Integers](#29-divide-two-integers)
* [50 Pow](#50-pow)
* [69 Sqrt](#69-sqrt)
* [166 Fraction to Recurring Decimal](#166-fraction-to-recurring-decimal)

<br>

<br>


###167 Two Sum II Input array is sorted

>Given an array of integers that is already **sorted in ascending order**, find two numbers such that they add up to a specific target number.

>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are **not zero-based**.
You may assume that each input would have exactly one solution.

	Input: numbers={2, 7, 11, 15}, target=9
	Output: index1=1, index2=2

<br>

**Idea**: We can solve this problem use the second method in * [1 Two Sum](#1-two-sum). Just use two pointers, one at the beginning, one at the ending. Compare num[l] + num[r] and target. If the former is larger, then r--, if the latter is larger, l++.

```java
	public int[] twoSum(int[] numbers, int target){
		int[] res = new int[2];
		if(numbers == null || numbers.length <= 1) return res;
		int l = 0;
		int r = numbers.length -1;
		while(l < r){
			if(numbers[l] + numbers[r] == target){
				res[0] = l+1;
				res[1] = r+1;
				return res;
			}else if(numbers[l] + numbers[r] > target) r--;
			else l++;
		}
		return res;
	}

```
* [1 Two Sum](#1-two-sum)
* [15 3Sum](#15-3sum)
* [16 3Sum Closest](#16-3sum-closest)
* [18 4Sum](#18-4sum)
* [167 Two Sum II Input array is sorted](#167-two-sum-ii-input-array-is-sorted)
* [170 Two Sum III Data Structure Design](#170-two-sum-iii-data-structure-design)

<br>

<br>


###170 Two Sum III Data Structure Design

>Design and implement a TwoSum class. It should support the following operations: add and find.

>add - Add the number to an internal data structure.

>find - Find if there exists any pair of numbers which sum is equal to the value.

	For example,
	add(1); add(3); add(5);
	find(4) -> true
	find(7) -> false
	
<br>

**Idea**: How to design the structure is based on our needs. Remember in * [1 Two Sum](#1-two-sum) , the first method we use hashmap to record each number, and check if sum - number exist. If we do this the same way in this problem, we can use hashmap to record each number when add, and find the number use the method in * [1 Two Sum](#1-two-sum). 

**Time complexity** : add O(1) find O(n)

**Space**: O(n)

***What if we want to find sum in O(1)?***

We need to record the all possible sum when add new numbers. Then the time complexity would change to O(n). Also, we need a set to record the possible sum. So we need to increase the space. 
```java
	public class TwoSum{
		private Map<Integer, Integer> map = new HashMap<Integer, Integer>();
		public void add(int number){
			if(map.containsKey(number)) map.put(number, map.get(number)+1);
			else map.put(number, 1);
		}
		
		public boolean find(int value){
			for(Integer i : map.keySet()){
				int remain = value -i;
				if(map.containsKey(remain)){
					if(remain == i && map.get(remain) < 2) continue;
					else return true;
				}
			}
			return false;
		}
	}
	
```





* [1 Two Sum](#1-two-sum)
* [15 3Sum](#15-3sum)
* [16 3Sum Closest](#16-3sum-closest)
* [18 4Sum](#18-4sum)
* [167 Two Sum II Input array is sorted](#167-two-sum-ii-input-array-is-sorted)
* [170 Two Sum III Data Structure Design](#170-two-sum-iii-data-structure-design)

<br>

<br>

### 171 Excel Sheet Column Number

> Given a column title as appear in an Excel sheet, return its corresponding column number.
>
> For example:
>
> ```
>   A -> 1
>   B -> 2
>   C -> 3
>   ...
>   Z -> 26
>   AA -> 27
>   AB -> 28 
> ```

**Analysis:** 

for example: CABD

`C * 26 ^ 3 + A * 26 ^ 2 + B * 26 ^ 1 + D * 26 ^ 0`

which is

`3 * 26 ^ 3 + 1 * 26 ^ 2 + 2 * 26 ^ 1 + 4`

The following code takes O(N) time and O(1) space.

``` C
int titleToNumber(char *s) {
    int i = 0, val = 0, x = 1;
    
    if (s[0] == 0) { return 0; } // if empty string
    for (; s[i+1] != 0; i ++); // find the end of string
    
    for (; i >= 0; i --) {
        val += x * (s[i] - 'A' + 1);
        x *= 26; // if we use something like pow(26, length - i) it 
                 // will cause extra calculation and takes more time.
    }
    
    return val;
}
```
	
### 188 Best Time to Buy and Sell Stock IV

> Say you have an array for which the ith element is the price of a given stock on day i.

>Design an algorithm to find the maximum profit. You may complete **at most k transactions**.

>Note:

>You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).

**First try:** Use the idea in [Best time to buy and sale stock iii](#123-best-time-to-buy-and-sell-stock-iii).
global[i][j]: denotes max profit, at most j transactions before day i:

 **global[i][j]=max(local[i][j],global[i-1][j])**

local[i][j]: denotes max profit, at most j transactions before day i, and last transaction is saled on day i: 

**local[i][j]=max(global[i-1][j-1]+max(diff,0),local[i-1][j]+diff)**

**Time complexity**: O(k * n)

**Space** : O(k)

Looks good, right? But we'll get out of memory error. Because in one test case, k = 100000. 

```java
	public int maxProfit(int k, int[] prices){
		if(prices == null || prices.length <= 1) return 0;
		int[] global = new int[k+1];
		int[] local = new int[k+1];
		for(int i = 1; i < prices.length; i++){
			int dif = prices[i] - prices[i-1];
			for(int j = k; j >= 1; j--){
				local[j] = Math.max(global[j-1] + Math.max(dif, 0), local[j] + dif);
				global[j] = Math.max(local[j], global[j]);
			}
		}
		return global[k];
	}
```
**Solution:**


* [121 Best Time to Buy and Sell Stock](#121-best-time-to-buy-and-sell-stock)
* [122 Best Time to Buy and Sell Stock II](#122-best-time-to-buy-and-sell-stock-ii)
* [123 Best Time to Buy and Sell Stock III](#123-best-time-to-buy-and-sell-stock-iii)
* [188 Best Time to Buy and Sell Stock IV](#188-best-time-to-buy-and-sell-stock-iv)

<br>
<br>


###189 Rotate Array

>Rotate an array of n elements to the right by k steps.

For example, with n = 7 and k = 3, the array [1,2,3,4,5,6,7] is rotated to [5,6,7,1,2,3,4].


Note:
Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.

**Idea**

- 1)Solution1:  In place. Reverse the array three times. (0, n-1) (0, k-1), (k-n-1)
- 2)Solution2:  Use an extra array, and copy to the right place.

<br>
**Solution1**:
```java
   public void rotate(int[] nums, int k) {
       if(nums == null || nums.length == 0 || k <= 0) return;
       k = k % nums.length;
       reverse(nums, 0, nums.length-1);
       reverse(nums, 0, k-1);
       reverse(nums, k, nums.length-1);
    }
    
    public void reverse(int[] nums, int left, int right){
        while(left < right){
            int temp = nums[left];
            nums[left] = nums[right];
            nums[right] = temp;
            left++;
            right--;
        }
    }
```    
**Solution 2**:
```java
    public void rotate1(int[] nums, int k) {
        if(nums == null || nums.length == 0 || k <= 0) return;
        int[] result = new int[nums.length];
        k = k % nums.length;
        for(int i = 0; i < k; i++){
            result[i] = nums[nums.length -k + i];
        }
        for(int i = k; i < nums.length; i++){
            result[i] = nums[i-k];
        }
        for(int i = 0; i < nums.length; i++){
            nums[i] = result[i];
        }
    }
```

###190 Reverse Bits

>Reverse bits of a given 32 bits unsigned integer.

>For example, given input 43261596 (represented in binary as 00000010100101000001111010011100), return 964176192 (represented in binary as 00111001011110000010100101000000).

>Follow up:

>If this function is called many times, how would you optimize it?

>Related problem: Reverse Integer


**Idea**: Like reverse a string, we swap each bit i with 32 -i -1 for 1/2 of the total bit length. 

```java

    public int reverseBits(int n) {
        if(n == 0) return 0;
        for(int i = 0; i < 16; i++){
        	n = swap(n, i, 32-i-1);
        }
        return n;
    }
    
    public int swap(int n,int i, int j){
    	int bitI = (n >> i) & 1;
    	int bitJ = (n >> j) & 1;
    	if((bitI ^ bitJ) != 0){
    		n = n ^ ((1 << i) | (1 << j));
    	}
    	return n;
    }

```

**Another solution in c++**: If the binary of number  a is  10001111 we can represent it as 2 ^ 7 + 2 ^ 3 + 2 ^2 + 2 ^ 1 + 2 ^ 0. Thus we use mod 2 and * 2 to reserve this number. Because in java int is not unsigned, so use this method in java have sign problem.

```c++

	uint32_t reverseBits(uint32_t n) {
        if(n == 0) return 0;
        int res = 0;
        for(int i = 0; i < 32; i++){
            int mod = n % 2;
            n = n >> 1;
            res = (res << 1) + mod;
        }
        return res;
    }


```



<br>

<br>


###191 Number of 1 Bits

>Write a function that takes an unsigned integer and returns the number of ’1' bits it has (also known as the Hamming weight).

>For example, the 32-bit integer ’11' has binary representation 00000000000000000000000000001011, so the function should return 3.


**Idea**: There are three ways to deal with this problem.

- 1) n & 1, if result is 1, count ++, n >>>= 1, till n = 0; ** Remember use >>>**
- 2) use n = n & n-1 to remove the rightmost 1. **Time complexity is O(number od 1s)**
- 3) use left shift. 



**Solution1 : Java code**:



```java


    public int hammingWeight(int n) {
        if(n == 0) return 0;
        int res = 0;
        while(n != 0){
            if((n & 1) != 0) res++;
            n = n >>> 1;
        }
        return res;
    }

```

**Solution 2: c++ code**:

```c++

    int hammingWeight(uint32_t n) {
          int res = 0;
          while(n > 0){
        	  n &= n-1;
        	  res++;
          }
          return res;
    }

```

**Solution 3: c++ code**:

```c++

    int hammingWeight(uint32_t n) {
      int res = 0;
      unsigned int flag = 1;
      while(flag){
         if(n&flag){
            res++;
        }
        flag = flag << 1;
      }
      return res;
    }

```


<br>
<br>

###198 House Robber


>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.

>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.


**Idea**: It's an one dimensional dp problem, like the **Best time to buy and sell stocks. We need to find the maximum nonadjacent sum. Thus, for each room our choice is either rob or not rob, based on the previous room, and we need to mantain the max money on the current. If we want to rob this room, the condition is that we don't rob the previous room. Thus robYes = robNo + room[i]. And if we don't rob this room, then we can choose the max from previous robYes and robNo. See details on the following code.

 

**Solution 1 **:


```java

    public int rob(int[] num) {
        if(num == null || num.length == 0) return 0;
        int robYes = 0;
        int robNo = 0;
        for(int money : num){
            int temp = robNo;
            robNo = Math.max(robYes, robNo);
            robYes = temp + money;
        }
        return Math.max(robYes, robNo);
    }


```



**Solution 2**:

```java

    public int rob(int[] num) {
        if(num == null || num.length == 0) return 0;
        int even = 0;
        int odd = 0;
        for(int i = 0; i < num.length; i++){
            if(i % 2 == 0){
                even += num[i];
                even = Math.max(even, odd);
            }else{
                odd += num[i];
                odd = Math.max(even, odd);
            }
        }
        return Math.max(odd, even);
    }

```


<br>
<br>



###199 Binary Tree Right Side View


>Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.

<pre>

For example:
Given the following binary tree,
   1         
 /   \
2     3         
 \     \
  5     4      
You should return [1, 3, 4].

</pre>

**Idea**: This problem is similar to the breadth first search of a binary search tree. If you can figure out this, the problem is easy. We use a queue, more precisely a deque to store element of each level. Then each time we store the rightmost element in each level to the result list. 


**Java code**:


```java

    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> res = new ArrayList<Integer>();
        if(root == null){
            return res;
        }
        Deque<TreeNode> deque = new LinkedList<TreeNode>();
        deque.offer(root);
        while(!deque.isEmpty()){
            TreeNode cur = null;
            for(int i = 0, size = deque.size(); i < size; i++){
                cur = deque.pollLast();
                if(cur.right != null){
                    deque.addFirst(cur.right);
                }
                if(cur.left != null){
                    deque.addFirst(cur.left);
                }
                if(i == 0){
                    res.add(cur.val);
                }
            }
        }
        return res;
    }

```

<br>
<br>


###200 Number of Islands

>Given a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.

<pre>
Example 1:

11110
11010
11000
00000
Answer: 1

Example 2:

11000
11000
00100
00011
Answer: 3


</pre>


**Idea**: Basically, the idea is similar to flood fill or bfs/dfs of graph. Each time we visited a land, we marked it as visited, then go north/west/south/east. When dfs ends, that means we have visited every land of a certain island. In the same way, we can count the number of all islands.


**Java code**:

```java
public int numIslands(char[][] grid) {
        if(grid == null || grid.length == 0 || grid[0].length == 0) return 0;
        boolean[][] visited = new boolean[grid.length][grid[0].length];
        int res = 0;
        for(int i = 0; i < grid.length; i++){
            for(int j = 0; j < grid[0].length; j++){
                if(grid[i][j] == '1' && visited[i][j] == false){
                    dfs(visited, grid, i, j);
                    res++;
                }
            }
        }
        return res;
    }
    
    public void dfs(boolean[][] visited, char[][] grid, int i, int j){
        if(i < 0 || i >= grid.length || j < 0 || j >= grid[0].length)
            return;
        if(visited[i][j] == true || grid[i][j] == '0')
            return;
        visited[i][j] = true;
        dfs(visited, grid, i-1, j);
        dfs(visited, grid, i, j-1);
        dfs(visited, grid, i+1, j);
        dfs(visited, grid, i, j+1);
    }

```



<br>
<br>


###201 Bitwise AND of Numbers Range

>Given a range [m, n] where 0 <= m <= n <= 2147483647, return the bitwise AND of all numbers in this range, inclusive.

>For example, given the range [5, 7], you should return 4.

**Idea**: what we need to do is to  find the similar bits of of m and n on the left side. For eample, if n = 111, m = 101, then the similar part on the left side is 1, then the result is 100. Then we left shift 1 by 2 we can get the result.


**Java code**:


```java


    public int rangeBitwiseAnd(int m, int n) {
        int count = 0;
        while(m != n){
            m >>= 1;
            n >>= 1;
            count++;
        }
        return m << count;
    }

```

<br>
<br>
