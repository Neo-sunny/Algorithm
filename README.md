

### Overview
* [1 Two Sum](#1-two-sum)
* [2 Add Two Numbers](#2-add-two-numbers)
* [3 Longest Substring without Repeating Characters](#3-longest-substring-without-repeating-characters)
* [4 Median of Two Sorted Arrays](#4-median-of-two-sorted-arrays)
* [5 Longest Palindromic Substring](#5-longest-palindromic-substring)
* [6 Zigzag Conversion](#6-zigzag-conversion)
* [7 Reverse Integer](#7-reverse-integer)
* [8 String to Integer atoi](#8-string-to-integer-atoi)
* [9 Palindrome Number](#9-palindrome-number)
* [10 Regular Expression Matching](#10-regular-expression-matching)
* [11 Container with Most Water](#11-container-with-most-water)
* [12 Integer to Roman](#12-integer-to-roman)
* [13 Roman to Integer](#13-roman-to-integer)
* [14 Longest Common Prefix](#14-longest-common-prefix)
* [15 3Sum](#15-3sum)
* [16 3Sum Closest](#16-3sum-closest)
* [17 Number Combinations of a Phone Number](#17-number-combinations-of-a-phone-number)
* [18 4Sum](#18-4sum)
* [19 Remove Nth Node From End of List](#19-remove-nth-node-from-end-of-list)
* [20 Valid Parentheses](#20-valid-parentheses)
* [21 Merge Two Sorted Lists](#21-merge-two-sorted-lists)
* [22 Generate Parentheses](#22-generate-parentheses)
* [23 Merge k Sorted Lists](#23-merge-k-sorted-lists)
* [24 Swap Nodes in Pairs](#24-swap-nodes-in-pairs)
* [25 Reverse Nodes in kGroup](#25-reverse-nodes-in-kgroup)
* [26 Remove Duplicates from Sorted Array](#26-remove-duplicates-from-sorted-array)
* [27 Remove Element](#27-remove-element)
* [28 Implement strStr](#28-implement-strstr)
* [29 Divide Two Integers](#29-divide-two-integers)
* [30 Substring with Concatenation of All Words](#30-substring-with-concatenation-of-all-words)
* [31 Next Permutation](#31-next-permutation)
* [32 Longest Valid Parentheses](#32-longest-valid-parentheses)
* [33 Search in Rotated Sorted Array](#33-search-in-rotated-sorted-array)
* [34 Search for a Range](#34-search-for-a-range)
* [35 Search Insert Position](#35-search-insert-position)
* [36 Valid Sudoku](#36-valid-sudoku)
* [37 Sudoku Solver](#37-sudoku-solver)
* [38 Count and Say](#38-count-and-say)
* [39 Combination Sum](#39-combination-sum)
* [40 Combination Sum II](#40-combination-sum-ii)
* [41 First Missing Positive](#41-first-missing-positive)
* [42 Trapping Rain Water](#42-trapping-rain-water)
* [43 Multiply Strings](#43-multiply-strings)
* [44 Wildcard Matching](#44-wildcard-matching)
* [45 Jump Game II](#45-jump-game-ii)
* [46 Permutations](#46-permutations)
* [47 Permutations II](#47-permutations-ii)
* [48 Rotate Image](#48-rotate-image)
* [49 Anagrams](#49-anagrams)
* [50 Pow](#50-pow)
* [51 N Queens](#51-n-queens)
* [52 N Queens II](#52-n-queens-ii)
* [53 Maximum Subarray](#53-maximum-subarray)
* [54 Spiral Matrix](#54-spiral-matrix)
* [55 Jump Game](#55-jump-game)
* [56 Merge Intervals](#56-merge-intervals)
* [57 Insert Interval](#57-insert-interval)
* [58 Length of Last Word](#58-length-of-last-word)
* [59 Spiral Matrix II](#59-spiral-matrix-ii)
* [60 Permutation Sequence](#60-permutation-sequence)
* [61 Rotate List](#61-rotate-list)
* [62 Unique Paths](#62-unique-paths)
* [63 Unique Paths II](#63-unique-paths-ii)
* [64 Minimum Path Sum](#64-minimum-path-sum)
* [65 Valid Number](#65-valid-number)
* [66 Plus One](#66-plus-one)
* [67 Add Binary](#67-add-binary)
* [69 Sqrt](#69-sqrt)
* [70 Climbing Stairs](#70-climbing-stairs)
* [73 Set Matrix Zeroes](#73-set-matrix-zeroes)
* [74 Search a 2D Matrix](#74-search-a-2d-matrix)
* [75 Sort Colors](#75-sort-colors)
* [77 Combinations](#77-combinations)
* [78 Subsets](#78-subsets)
* [80 Remove Duplicates from Sorted Array II](#80-remove-duplicates-from-sorted-array)
* [81 Search in Rotated Sorted Array II](#81-search-in-rotated-sorted-array-ii)
* [82 Remove Duplicates from Sorted List](#82-remove-duplicates-from-sorted-list)
* [83 Remove Duplicates from Sorted List II](#83-remove-duplicates-from-sorted-list-ii)
* [86 Partition List](#86-partition-list)
* [89 Gray Code](#89-gray-code)
* [90 Subsets II](#90-subsets-ii)
* [92 Reverse Linked List II](#92-reverse-linked-list-ii)
* [94 Binary Tree Inorder Traversal](#94-binary-tree-inorder-traversal)
* [95 Unique Binary Search Trees](#95-unique-binary-search-trees)
* [96 Unique Binary Search Trees II](#96-unique-binary-search-trees)
* [98 Validate Binary Search Tree](#98-validate-binary-search-tree)
* [99 Recover Binary Search Tree](#99-recover-binary-search-tree)
* [100 Same Tree](#100-same-tree)
* [101 Symmetric Tree](#101-symmetric-tree)
* [102 Binary Tree Level Order Traversal](#102-binary-tree-level-order-traversal)
* [103 Binary Tree Zigzag Level Order Traversal](#103-binary-tree-zigzag-level-order-traversal)
* [104 Maximum Depth of Binary Tree](#104-maximum-depth-of-binary-tree)
* [105 Construct Binary Tree from Preorder and Inorder Traversal](#105-construct-binary-tree-from-preorder-and-inorder-traversal)
* [106 Construct Binary Tree from Inorder and Postorder Traversal](#106-construct-binary-tree-from-inorder-and-postorder-traversal)
* [107 Binary Tree Level Order Traversal II](#107-binary-tree-level-order-traversal-ii)
* [108 Convert Sorted Array to Binary Search Tree](#108-convert-sorted-array-to-binary-search-tree)
* [109 Convert Sorted List to Binary Search Tree](#109-convert-sorted-list-to-binary-search-tree)
* [110 Balanced Binary Tree](#110-balanced-binary-tree)
* [111 Minimum Depth of Binary Tree](#111-minimum-depth-of-binary-tree)
* [114 Flatten Binary Tree to Linked List](#114-flatten-binary-tree-to-linked-list)
* [118 Pascal Triangle](#118-pascal-triangle)
* [119 Pascal Triangle II](#119-pascal-triangle-ii)
* [120 Triangle](#120-triangle)
* [121 Best Time to Buy and Sell Stock](#121-best-time-to-buy-and-sell-stock)
* [122 Best Time to Buy and Sell Stock II](#122-best-time-to-buy-and-sell-stock-ii)
* [123 Best Time to Buy and Sell Stock III](#123-best-time-to-buy-and-sell-stock-iii)
* [124 Binary Tree Maximum Path Sum](#124-binary-tree-maximum-path-sum)
* [126 Word Ladder](#126-word-ladder)
* [127 Word Ladder II](#127-word-ladder-ii)
* [135 Candy](#135-candy)
* [138 Copy List With Random Pointer](#138-copy-list-with-random-pointer)
* [141 Linked List Cycle](#141-linked-list-cycle)
* [142 Linked List Cycle II](#142-linked-list-cycle-ii)
* [143 Reorder List](#143-reorder-list)
* [144 Binary Tree Preorder Traversal](#144-binary-tree-preorder-traversal)
* [145 Binary Tree Postorder Traversal](#145-binary-tree-postorder-traversal)
* [147 Insertion Sort List](#147-insertion-sort-list)
* [148 Sort List](#148-sort-list)
* [151 Reverse Words in a String](#151-reverse-words-in-a-string)
* [153 Find Minimum in Rotated Sorted Array](#153-find-minimum-in-rotated-sorted-array)
* [154 Find Minimum in Rotated Sorted Array II](#154-find-minimum-in-rotated-sorted-array-ii)
* [155 Min Stack](#155-min-stack)
* [156 Binary Tree Upside Down](#156-binary-tree-upside-down)
* [157 Read N Characters Given Read4](#157-read-n-characters-given-read4)
* [158 Read N Characters Given Read4 II - Call multiple times](#158-read-n-characters-given-read4-ii-call-multiple-times) 
* [159 Longest String with At Most Two Distinct Characters](#159-longest-string-with-at-most-two-distinct-characters)
* [160 Intersection of Two Linked Lists](#160-intersection-of-two-linked-lists)
* [162 Find Peak Element](#162-find-peak-element)
* [166 Fraction to Recurring Decimal](#166-fraction-to-recurring-decimal)
* [167 Two Sum II Input array is sorted](#167-two-sum-ii-input-array-is-sorted)
* [170 Two Sum III Data Structure Design](#170-two-sum-iii-data-structure-design)
* [173 Binary Search Tree Iterator](#173-binary-search-tree-iterator)
* [188 Best Time to Buy and Sell Stock IV](#188-best-time-to-buy-and-sell-stock-iv)
* [189 Rotate Array](#189-rotate-array)
* [190 Reverse Bits](#190-reverse-bits)
* [191 Number of 1 Bits](#191-number-of-1-bits)
* [198 House Robber](#198-house-robber)
* [199 Binary Tree Right Side View](#199-binary-tree-right-side-view)
* [200 Number of Islands](#200-number-of-islands)
* [201 Bitwise AND of Numbers Range](#201-bitwise-and-of-numbers-range)
* [202 Happy Number](#202-happy-number)
* [203 Remove Linked List Elements](#203-remove-linked-list-elements)
* [204 Count Primes](#204-count-primes)
* [205 Isomorphic Strings](#205-isomorphic-strings)
* [206 Reverse Linked List](#206-reverse-linked-list)
* [207 Course Schedule](#207-course-schedule)
* [208 Implement Trie Prefix Tree](#208-implement-trie-prefix-tree)
* [209 Minimum Size Subarray Sum](#209-minimum-size-subarray-sum)
* [210 Course Schedule II](#210-course-schedule-ii)
* [216 Combination Sum III](#216-combination-sum-iii)
* [222 Count Complete Tree Nodes](#222-count-complete-tree-nodes)



##Similar questions from other sources.

* [1 Search a 2D Matrix II](#1-search-a-2d-matrix-ii)
* [2 First Bad Version](#2-first-bad-version)
* [3 Compare Strings](#3-compare-strings)
* [4 Longest Common Substring](#4-longest-common-substring)
* [5 Insert in Sorted Linked List](#5-insert-in-sorted-linked-list)
* [6 Is Bipartite](#6-is-bipartite)
* [7 Lowest Common Ancestor](#7-lowest-common-ancestor)



<br>


### 1 Two Sum
>Given an array of integers, find two numbers such that they add up to a specific target number.

>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.

>You may assume that each input would have exactly one solution.

>Input: numbers={2, 7, 11, 15}, target=9

>Output: index1=1, index2=2

**Solution1**: Use hashmap to record the number and its index, each time check if map containsKey target - num[i].

**Time complexity** O(n)

**Space** O(n)

```java
   public int[] twoSum(int[] numbers, int target) {
        //use hashmap
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        int[] result = new int[2];
        if(numbers == null || numbers.length == 0) return result;
        
        for(int i = 0; i < numbers.length; i++){
            if(map.containsKey(target - numbers[i])){
                result[0] = map.get(target - numbers[i]) + 1;
                result[1] = i + 1;
                return result;
            }
            map.put(numbers[i], i);
        }
        return result;
    }
```    
	
**Solution2**: We can first sort the numbers. Then use two pointers, the first pointer points to the begining and the second points to the end. Each time compares the target and num[p1]+num[p2], if target is bigger, p1++, else p2--. But it doesn't work for this problem, because we need to return the index. If we are requested to return the nunbers, we can use the following way.

**Time**: O(nlgn)

**Space**: O(1)

```java
    //this function returns the numbers, not the index
    public int[] twoSum(int[] numbers, int target) {
        //First sort, then use two pointers
        int[] res = new int[2];
        if(numbers == null || numbers.length <= 1) return res;
        Arrays.sort(numbers);
        int l = 0;
        int r = numbers.length -1;
        while(l < r){
            if(numbers[l] + numbers[r] == target){
                res[0] = numbers[l];
                res[1] = numbers[r];
                return res;
            }else if(numbers[l] + numbers[r] > target)
                r--;
            else l++;
        }
        return res;
    }

```


<br>
<br>

### 2 Add Two Numbers

> You are given two linked lists representing two non-negative numbers.
> The digits are stored in reverse order and each of their nodes contain a single digit.
> Add the two numbers and return it as a linked list.
>
> **`Input:`** `(2 -> 4 -> 3) + (5 -> 6 -> 4)`
>
> **`Output`** `(7 -> 0 -> 8)`

**Idea**: 

Digits are stored in reverse order, that means `(2 -> 4 -> 3)` is `342`. When it reaches 10 after addition, the next node shall add 1 and current node shall only keep the unit number: `(3 -> 2) + (9 -> 1) = (2 -> 4)`; if one integer doesn't have more numbers, add the remaining digits to  result.


**Attention**: After both l1 and l2 reach to the end, check the carry. If carry != 0, add an additional node to the result. 

**More**: What if the numbers are store in order? It's a little complicated than the question above. One way is add the corresponding digits, notice that the numbers might have different number of bits, so we can not add from beginning. The other stupid method is first reverse the linkedlist, then use the method above. 

**java code**:

```java

    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        if(l1 == null) return l2;
        if(l2 == null) return l1;
        ListNode fakeHead = new ListNode(-1);
        ListNode res = fakeHead;
        int carry = 0;
        while(l1 != null && l2 != null){
            int sum = l1.val + l2.val + carry;
            int mod = sum % 10;
            carry = sum / 10;
            res.next = new ListNode(mod);
            res = res.next;
            l1 = l1.next;
            l2 = l2.next;
        }
        while(l1 != null){
            int sum = l1.val + carry;
            int mod = sum % 10;
            carry = sum / 10;
            res.next = new ListNode(mod);
            l1 = l1.next;
            res = res.next;
        }
        while(l2 != null){
            int sum = l2.val + carry;
            int mod = sum % 10;
            carry = sum / 10;
            res.next = new ListNode(mod);
            l2 = l2.next;
            res = res.next;
        }
        if(carry != 0)
            res.next = new ListNode(carry);
        return fakeHead.next;
    }

```



**c++ Code**:

``` cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *addTwoNumbers(ListNode *l1, ListNode *l2) {
        ListNode *p1 = l1, *p2 = l2;
        ListNode *r = new ListNode(0);
        ListNode *begin = r;
        int sum = 0;
        
        while (p1 && p2) {
            sum = p1->val + p2->val + sum / 10;
            r->next = new ListNode(sum % 10);
            p1 = p1->next;
            p2 = p2->next;
            r = r->next;
        }
        
        ListNode *px = NULL;
        if (p1) { px = p1; }
        else if (p2) { px = p2; }
        
        while (px) {
            sum = sum / 10 + px->val;
            r->next = new ListNode(sum % 10);
            px = px->next;
            r = r->next;
        }
        if (sum >= 10) { r->next = new ListNode(sum / 10); }
        
        return begin->next;
    }
    
};
```

The time complexity is O(m+n) and space complexity is O(m+n).

<br>
<br>

###3 Longest Substring without Repeating Characters
>Given a string, find the length of the longest substring without repeating characters. For example, the longest substring without repeating letters for "abcabcbb" is "abc", which the length is 3. For "bbbbb" the longest substring is "b", with the length of 1.


**Idea**: if encounter duplicates, start from the character after the dulicate appear at the first time. eg: abcab, at index 4 a is duplicated, we start count from index 1(after the first a).

```java

    public int lengthOfLongestSubstring(String s) {
        if(s == null || s.length() == 0) return 0;
        int start = 0;
        int current = 0;
        int max = 0;
        Set<Character> set = new HashSet<Character>();
        while(current < s.length()){
            if(set.contains(s.charAt(current))){
                max = Math.max(max, current - start);
                while(s.charAt(start) != s.charAt(current)){
                    set.remove(s.charAt(start));
                    start++;
                }
                start++;
            }else{
                set.add(s.charAt(current));
            }
            current++;
        }
        max = Math.max(current- start, max);
        return max;
    }
    

```

There is another solution use primitive string methods, such as indexOf, subString and contains. Because indexOf and contains take O(n*m), so it's really slow. It can be AC by leetcode, but when network is bad, it may time limit exceeded.

```java

    public int lengthOfLongestSubstring(String s) {
    	if(s == null || s.length() == 0) return 0;  	
    	int longest = 0;
    	int current = 0;
    	StringBuilder sBuilder = new StringBuilder();
    	for(int i = 0, len = s.length(); i < len; i++){

    		if(sBuilder.toString().contains(s.charAt(i)+"")){
    			longest = Math.max(longest, current);
    			int index = sBuilder.indexOf(s.charAt(i)+"");
    			sBuilder = new StringBuilder(sBuilder.substring(index+1));
    			sBuilder.append(s.charAt(i));
    			current = sBuilder.length();
    		}else{
    			sBuilder.append(s.charAt(i));
    			current++;
    		}
    	}
    	longest = Math.max(longest, current);
   		return longest;        
    }

```
<br>




<br>

###4 Median of Two Sorted Arrays

>There are two sorted arrays A and B of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).

**Idea**: We need to find the median, thus if (lenA + lenB) % 2 == 1, we need to find the ((lenA + lenB)/2 + 1)th smallest element. If  (lenA + lenB) % 2 == 0, we return ( (lenA + lenB)/2)th + (lenA + lenB)/2 + 1)th)/ 2. So we can use the idea in find the kth element in an array. The steps are as follows:

- 1) find the k/2 element of A and B
- 2) when B[k/2 -1] = A[k/2 -1], then the kth element is A[k/2 -1]
- 3) if A[k/2 -1] < B[k/2 -1], then the kth element is not in A[0.....k/2 -1] and  B[k/2.....B.length -1]
- 4) if A[k/2 -1] > B[k/2 -1], then the kth element is not in B[0.....k/2 -1] and  A[k/2.....A.length -1]

**Time complexity ** O(log(m+n))



**Attention**: There are cases when one array is really longer than the other one, so we need to check the length of k/2 and length of array. Otherwise, there might be indexoutofbound exception. 


```java

    public double findMedianSortedArrays(int A[], int B[]) {
        if(A == null && B == null) return 0;
        if(A == null) return B.length % 2 == 0 ? (B[B.length/2 -1] + B[B.length/2])/2 : B[B.length/2];
        if(B == null) return A.length % 2 == 0 ? (A[A.length/2 -1] + A[A.length/2])/2 : A[A.length/2];
        return ((A.length + B.length) % 2 == 1) ? helper(A, B, 0, A.length-1, 0, B.length-1, (A.length + B.length)/2 + 1):((helper(A, B, 0, A.length-1, 0, B.length-1, (A.length + B.length)/2 )) + helper(A, B, 0, A.length-1, 0, B.length-1, (A.length + B.length)/2 + 1))/2;
    }
    
    public double helper(int[] A, int[] B, int startA, int endA, int startB, int endB, int k){
        int lenA = endA - startA + 1;
        int lenB = endB - startB + 1;
        if(lenA > lenB) return helper(B, A, startB, endB, startA, endA, k);
        if(lenA == 0) return B[startB + k - 1];
        if(lenB == 0) return A[startA + k - 1];
        if(k == 1) return Math.min(A[startA], B[startB]);
        int posA = Math.min(k/2, lenA);
        int posB = k - posA;
        if(A[startA + posA -1] == B[startB + posB -1]) return A[startA + posA -1];
        if(A[startA + posA -1] < B[startB + posB -1]) return helper(A, B, posA+startA, endA, startB, posB+startB-1, k - posA);
        else return helper(A, B, startA, posA + startA -1, startB + posB, endB, k - posB);
        
    }

```

Here is the python code for this problem. We defined two extra functions: `median()` will find the median from *one* given array. `shrink()` will get two shrinked arrays, while one is from the left side and the other is the right side from the given arrays. Because either array may contains the median with exactly the middle two items in the array. So the shrinking size of array will be slightly less.

For example, for array [1,2,6,7] and [3,4,5,8]. The median of two arrays is 4.5 . `median(A)` is 4, `median(B)` is 4.5. So we will shrink the left side of A, and shrink the right side of B. So `shrink(A, B, true)` will be `[2,6,7], [3,4,5]`.

``` python
class Solution:
    def median(self, array):
        n = len(array)
        if n == 1:
            return array[0]
        elif n % 2 == 0:
            return float((array[n/2] + array[n/2 - 1])) / 2
        else:
            return array[n/2]
            
    def shrink(self, A, B, A_isleft):
        a, b = len(A), len(B)
        n = (b-1) / 2 if a > b else (a-1) / 2
        if A_isleft:
            return A[:a-n], B[n:]
        else:
            return A[n:], B[:b-n]
    
    # @return a float
    def findMedianSortedArrays(self, A, B):
        if not A and not B: raise ValueError(message="Two empty arrays")
        
        if not A:
            return self.median(B)
        
        if not B:
            return self.median(A)
            
        if len(A) <= 2 or len(B) <= 2:
            return self.median(sorted(A+B))
        
        A_isleft = self.median(A) > self.median(B)
        a, b = self.shrink(A, B, A_isleft)
        return self.findMedianSortedArrays(a, b)
```




<br>
<br>


###5 Longest Palindromic Substring
>Given a string S, find the longest palindromic substring in S. You may assume that the maximum length of S is 1000, and there exists one unique longest palindromic substring.

**Idea**:

- 1) solution1: use dp, we dp[j][i] == true represents that j...i is a parlindromic substring.
- 2) solution2: for each character s[i], we find the longest substring whose center is s[i] 

**solution1 code**

```java
     public String longestPalindrome(String s) {
        if(s == null || s.length() == 0) return s;
        boolean[][] dp = new boolean[s.length()+1][s.length() + 1];
        dp[0][0] = true;
        int max = 0;
        String res = "";
        for(int i = 0; i < s.length(); i++){
            for(int j = 0; j <= i; j++){
                if(s.charAt(i) == s.charAt(j) && (i - j <= 2 || dp[j+1][i-1])){
                    dp[j][i] = true;
                    if(i - j + 1 > max){
                        max = i-j+1;
                        res = s.substring(j, i+1);
                    }
                }
                
            }
        }
        return res;
  	}

```


**solution2 code**

```java

    public String longestPalindrome(String s) {
        if(s == null || s.length() <= 1) return s;
        int max = 0;
        String res = "";
        for(int i = 0; i < s.length(); i++){
            String mid = helper(s, i-1, i+1);
            String left =  helper(s, i-1, i);
            String right =  helper(s, i, i+1);
            String temp = mid.length() > left.length() ? mid : left;
            temp = temp.equals(mid) ? (mid.length() > right.length() ? mid : right) : (left.length() > right.length() ? left : right);
            if(temp.length() > max){
                max = temp.length();
                res = temp;
            }
        }
        return res;
  	}
  	
  	public String helper(String s, int l, int r){
  	    while(l >= 0 && r < s.length()){
  	        if(s.charAt(l) == s.charAt(r)) {
  	            l--;
  	            r++;
  	        }else{
  	            return s.substring(l+1, r);
  	        }
  	    }
  	    return s.substring(l+1, r);
  	}
  	

```

###6 Zigzag Conversion
>The string "PAYPALISHIRING" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)
<pre>

P   A   H   N
A P L S I I G
Y   I   R

</pre>
And then read line by line: "PAHNAPLSIIGYIR"
Write the code that will take a string and make this conversion given a number of rows:

string convert(string text, int nRows);
convert("PAYPALISHIRING", 3) should return "PAHNAPLSIIGYIR".


** Idea**: 

size of zigzag: 2 * nRows - 2;

index of middle element : size - i + j - i ; i is the row number, j is the starting index of each row.

**code**:

```java

    public String convert(String s, int nRows) {
        if(s == null || nRows == 1) return s;
        StringBuilder res = new StringBuilder();
        int size = nRows * 2 - 2;
        for(int i = 0; i < nRows; i++){
            for(int j = i; j < s.length(); j += size){
                res.append(s.charAt(j));
                if(i != 0 && i != nRows-1 && ((size - i + j - i) < s.length()))
                    res.append(s.charAt(size - i + j - i));
            }
        }
        return res.toString();
    }

```

<br>
<br>

###7 Reverse Integer

> Reverse digits of an integer.

>Example1: x = 123, return 321

>Example2: x = -123, return -321

**Idea**: Record the sign of the number then take abs of the number. Move the lsb to the msb each time until the number change to 0.

**Attention**: After reverse, the number might overflow, then we need to check during reverse. When overflow, we return 0;

```java
    public int reverse(int x) {
        if(x <= 9 && x >= -9) return x;
        int res = 0;
        boolean positive = x > 0 ? true : false;
        x = Math.abs(x);
        while(x > 0 && (Integer.MAX_VALUE - x % 10) / 10 >= res){
            int mod = x % 10;
            res = res * 10 + mod;
            x = x / 10;
        }
        if(x > 0) return 0;
        return positive ?  res : -res;
    }

```





###8 String to Integer atoi

>Implement atoi to convert a string to an integer.

>Hint: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases.

>Notes: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front.


**Some rules**: 

1) if can not convert, return 0;

2) if value if out of range, return INT_MAX or INT_MIN

3) discard any whitespace until first non-whitespace character is found

4) takes as many characters as possible to form a valid character until encounter an unvalid

```java
    public int myAtoi(String str) {
        if (str == null) {
            return 0;
        }
        str = str.trim();
        int res = 0;
        boolean isPositive = true; 
        for (int i = 0; i < str.length(); i++) {
            char c = str.charAt(i);
            if (i == 0 && (c == '-' || c == '+')) {
                if (c == '-') {
                    isPositive = false;
                }
                continue;
            }
            if (!isNum(c)) {
                break;
            } else if (res > (Integer.MAX_VALUE - (c - '0')) / 10) {
                return isPositive ? Integer.MAX_VALUE : Integer.MIN_VALUE;
            } else {
                res = res * 10 + (c - '0');
            }
        }
        return isPositive ? res : -res;
    }
    
    public boolean isNum(char c) {
        return c >= '0' && c <= '9';
    }

```

5) python accepts integer larger than INT_MAX and integer smaller than INT_MIN, so make an if-else on that.

``` python
class Solution:
    INT_MIN = -2147483648
    INT_MAX = 2147483647

    if num < self.INT_MIN:
        return self.INT_MIN
    elif num > self.INT_MAX:
        return self.INT_MAX
```

<br>
<br>


###9 Palindrome Number

> Determine whether an integer is a palindrome. Do this without extra space.


**Idea**: Just like check if a string is a palindrom, we need to have two pointers, one from beginning and one from end. The difference is that for a integer, we can not use charAt. But we can still get the number of the two pointers use divide and mod. 


**Jave Code**

```java

    public boolean isPalindrome(int x) {
        if(x < 0) return false;
	    if(x <= 9) return true;
	    int divide = 1;
	    while((divide < Integer.MAX_VALUE/10) && (divide * 10) <= x){
	        divide *= 10;
	    }
	    while(x != 0){
	        int ms = x/divide;
	        int ls = x%10;
	        if(ms != ls) return false;
	        x = (x % divide) / 10;
	        divide  = divide / 100;
	    }
	    return true;
	}

```

<br>
<br>


###10 Regular Expression Matching


>Implement regular expression matching with support for '.' and '*'.

<pre>
'.' Matches any single character.
'*' Matches zero or more of the preceding element.

The matching should cover the entire input string (not partial).

The function prototype should be:
bool isMatch(const char *s, const char *p)

Some examples:
isMatch("aa","a") → false
isMatch("aa","aa") → true
isMatch("aaa","aa") → false
isMatch("aa", "a*") → true
isMatch("aa", ".*") → true
isMatch("ab", ".*") → true
isMatch("aab", "c*a*b") → true

</pre>

**Idea**:

-  Solution1: We divide it into two cases: 1) p[j+1] == '\*'  2)p[j+1] != '\*'. In the first case, it's a little complicated. Because * can match 0 or more characters. Thus we need to check match(s, p, i, j+2), match(s, p, i+1, j+2)....... In the second case we just need to compare s[i] and p[j], if s[i] == p[j] or p[j] == '.', we continue to compare(s, p, i+1, j+1).


**Solution1 code**:

```java

	public boolean isMatch(String s, String p) {
        if((s == null && p == null) || p.equals(".*")) return true;
        return helper(s, p, 0, 0);
    }
    public boolean helper(String s, String p, int i, int j){
        if(j == p.length()) return i == s.length();
         if(j+1 == p.length() || p.charAt(j+1) != '*'){
            if(i < s.length() && (s.charAt(i) == p.charAt(j) || p.charAt(j) == '.')) return helper(s, p, i+1, j+1);
            else return false;
         }
         while(i < s.length() && (p.charAt(j) == '.' || p.charAt(j) == s.charAt(i))){
             if(helper(s, p, i++, j+2)) return true;
         }
         return helper(s, p, i, j+2);
    }
```


**Solution2**:

```java
    public boolean isMatch(String s, String p) {
        if((s == null && p == null) || p.equals(".*")) return true;
        boolean[][] dp = new boolean[s.length()+1][p.length()+1];
        dp[0][0] = true;
        for(int i = 2; i <= p.length(); i++){
            if(p.charAt(i-1) == '*') dp[0][i] = dp[0][i-2];
        }
        for(int i = 1; i <= s.length(); i++){
            for(int j = 1; j <= p.length(); j++){
                if(p.charAt(j-1) != '*'){
                    if(s.charAt(i-1) == p.charAt(j-1) || p.charAt(j-1) == '.') dp[i][j] = dp[i-1][j-1];
                }else{
                   if(j > 1 && (s.charAt(i-1) == p.charAt(j-2) || p.charAt(j-2) == '.'))
                         dp[i][j] = dp[i][j-2] || dp[i-1][j];
                   else dp[i][j] = dp[i][j-2];
                }
            }
        }
        return dp[s.length()][p.length()];
     }

```


 

<br>
<br>

###11 Container with Most Water

>Given n non-negative integers a1, a2, ..., an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.
Note: You may not slant the container.

**Idea**: Thea easiest way we can do is brute force. We calcuate the possible value with element with all the values after it. The time complexity is O(n^2). Have have another efficient way. We set a window, l = 0, r = size -1. Each time we calculate the container of l r, then we compare the height[l] and height[r]. if(height[l] > height[r]), r--. Because we know that height[l] > height[r], if we move l pointer, then the volumn would decrease.


```java

    public int maxArea(int[] height) {
    	if(height == null || height.length == 0) return 0;
    	int left = 0;
    	int right = height.length-1;
    	int max = 0;
    	while(left < right){
    		max = Math.max(max, Math.min(height[left], height[right]) * (right-left));
    		if(height[right] > height[left]) left++;
    		else right--;
    	}
    	return max;
    }


```



<br>
<br>

###12 Integer to Roman

>Given an integer, convert it to a roman numeral.

>Input is guaranteed to be within the range from 1 to 3999.


**Some rules about Roman**:

*Numbers*:

- I : 1
- V : 5
- X : 10
- L : 50
- C : 100
- D : 500
- M : 1000


*specific rules*: 

- When a larger number add some smaller numbers on its right side: larger + smaller
- when a larger number add some smaller numbers on its left side : larger - smaller
- when add a line on top of roman number, it means the number * 1000
- The same roman code can repeat at most three times eg: XL: 40, we cannot write it as XXXX


**Some Example**:

- I : 1
- II : 2
- III : 3
- IV : 4
- V : 5
- VI : 6
- VII: 7
- VIII : 8
- IX : 9
- X: 10
- XI : 11
- ......
- XC: 90
- CD : 400
- DCCC: 800
- .....

**Idea**:

- 1) Solution1: The most straight forward way is we add the value of each character. There are two cases to consider. 1. character I 2. character V, X....... For the first case, we just need to add I to the result. For the second case, we need to check if there are smaller characters before it. For example IV if 4, we need first add 1 then add 5 -2.

- 2)  Solution2 : We add a map for each pair. These additional space can help make our code more concisely.

**Solution1 code**:

```java
    public int romanToInt1(String s) {
        if(s == null || s.length() == 0) return 0;
        int res = 0;
        for(int i = 0; i < s.length(); i++){
            char c = s.charAt(i);
            if(c == 'I') res += 1;
            else if( c == 'V'){
                if(i > 0 && s.charAt(i-1) == 'I') res += 3;
                else res += 5;
            }else if(c == 'X'){
                if(i > 0 && s.charAt(i-1) == 'I') res += 8;
                else res += 10;
            }else if(c == 'L'){
                if(i > 0 && s.charAt(i-1) == 'X') res += 30;
                else res += 50;
            }else if(c == 'C'){
                if(i > 0 && s.charAt(i-1) == 'X') res += 80;
                else res += 100;
            }else if(c == 'D'){
                if(i > 0 && s.charAt(i-1) == 'C') res += 300;
                else res += 500;
            }else if (c == 'M'){
                if(i > 0 && s.charAt(i-1) == 'C') res += 800;
                else res += 1000;
            }
        }
        return res;
    }

```


**Solution2 code**: Use hashmap

```java

    public int romanToInt(String s) {
        if(s == null || s.length() == 0) return 0;
        int res = 0;
        Map<Character, Integer> map = new HashMap<Character, Integer>();
        map.put('I', 1);
        map.put('V', 5);
        map.put('X', 10);
        map.put('L', 50);
        map.put('C', 100);
        map.put('D', 500);
        map.put('M', 1000);
        for(int i = 0; i < s.length(); i++){
            char c = s.charAt(i);
            if(c == 'I') {
                res += map.get(c);
                continue;
            }
            if(i > 0 && map.get(s.charAt(i-1)) < map.get(c)) res = res + map.get(c) - 2 * map.get(s.charAt(i-1));
            else res += map.get(c);
        }
        return res;
    }

```



<br>

<br>


###13 Roman to Integer 

**Rules**:

See detailed rules at [12 Integer to Roman](#12-integer-to-roman)

**Idea**: Just calculate each digit and append it to result string.

**Code**:

```java
    public String intToRoman1(int num) {
        if(num <= 0 || num >= 4000) return "";
        int divide = 1000;
        int[] digits = new int[4];
        StringBuilder res = new StringBuilder();
        for(int i = 3; i >= 0 && num > 0; i--){
            digits[i] = num/divide;
            num = num % divide;
            divide /= 10;
        }
        res.append(helper(digits[3], 'M', ' ', ' '));
        res.append(helper(digits[2], 'C', 'D', 'M'));
        res.append(helper(digits[1], 'X', 'L', 'C'));
        res.append(helper(digits[0], 'I', 'V', 'X'));
        return res.toString();
    }
    
    public String helper(int i, char one, char five, char ten){
        StringBuilder res = new StringBuilder();
        switch(i){
            case 9: res.append(one + "" + ten); break;
            case 8: res.append(five + "" + one + "" + one + "" + one); break;
            case 7: res.append(five + "" + one + "" + one); break;
            case 6: res.append(five + "" + one); break;
            case 5: res.append(five); break;
            case 4: res.append(one + "" + five); break;
            case 3: res.append(one + "" + one + "" + one); break;
            case 2: res.append(one + "" + one); break;
            case 1: res.append(one);
        }
        return res.toString();
    }
```


**Better code on appending part**:

```java

    public String intToRoman(int num) {
    	if(num <= 0 || num >= 4000) return "";
    	int divide = 1000;
    	int[] digits = new int[4];
    	for(int i = 3; i >= 0 && num > 0; i--){
             digits[i] = num/divide;
             num = num % divide;
             divide /= 10;
         }
    	StringBuilder result = new StringBuilder();
    	result.append(convert(digits[3], 'M', ' ', ' '));
    	result.append(convert(digits[2], 'C', 'D', 'M'));
    	result.append(convert(digits[1], 'X', 'L', 'C'));
    	result.append(convert(digits[0], 'I', 'V', 'X'));
        
    	return result.toString();
    }
    
    public String convert(int digit, char one, char five, char ten){
    	StringBuilder result = new StringBuilder();
    	switch(digit)
    	{
    		case 9:
    			result.append(one);
    			result.append(ten);
    			break;
    		case 8:
    		case 7:
    		case 6:
    		case 5:
    			result.append(five);
    			for(int i = 5; i < digit; i++) result.append(one);
    			break;
    		case 4: 
    			result.append(one);
    			result.append(five);
    			break;
    		case 3:
    		case 2:
    		case 1:
    			for(int i = 0; i < digit; i++) result.append(one);
    			break;
    		default:
    			break;
    	}
    	return result.toString();
    }

```


<br>

<br>

###14 Longest Common Prefix

> Write a function to find the longest common prefix string amongst an array of strings.

**Idea**: Choose the first string, then compare each of its character with the strings in strs. Return result when a mismatch happens.

**Time complexity**: O(n * m), n is the length of prefix string. M is the length of strs. 


**Java code**:


```java

    public String longestCommonPrefix(String[] strs) {
        if(strs == null || strs.length == 0) return "";
        StringBuilder res = new StringBuilder();
        String s = strs[0];
        for(int i = 0; i < s.length(); i++){
            char c = s.charAt(i);
            for(int j= 1; j < strs.length; j++){
                if((i < strs[j].length() && c != strs[j].charAt(i)) || i >= strs[j].length()) return res.toString();
            }
            res.append(c);
        }
        return res.toString();
    }


```


<br>

<br>


###15 3Sum

>Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.

>Note:

- Elements in a triplet (a,b,c) must be in **non-descending order**. (ie, a ≤ b ≤ c)

- The solution set **must not contain duplicate triplets**.
    
    
    
  		For example, given array S = {-1 0 1 2 -1 -4},
    	A solution set is:
    	(-1, 0, 1)
    	(-1, -1, 2)
    
**Idea**: We need to find the three numbers triplets that sum to 0. We can change to this problem to two subproblems. Target + (-target) = 0, num1 + num2 = - target.
Thus we can use the method in two sum to solve this problem. For each number num1 in the array, we find the other two numbers that sum to -num1. 

We first need to sort the array, then use two pointers to find the two sum numbers sum to -num1.

**Time** O(n ^ 2)

**Space** O(n ^ 2)

**Attention**: 

1) Silly check: num is null or num's length less than 3

2) *Duplication*: Both the threeSum and twoSum helper function need to check the duplication. If just need to check if the current is equal to the number before it. 

3) Non-descending order

```java
    public List<List<Integer>> threeSum(int[] num) {
        List<List<Integer>> list = new ArrayList<List<Integer>>();
        if(num == null || num.length < 3) return list;
        Arrays.sort(num);
        for(int i = 0; i <= num.length - 3; i++){
            if(i != 0 && num[i] == num[i-1]) continue;
            List<List<Integer>> current = twoSum(num, i+1, -num[i]);
            if(current.size() > 0){
                for(List<Integer> l : current ){
                    l.add(0, num[i]);
                }
                list.addAll(current);
            }
        }
        return list;
    }
    
    public List<List<Integer>> twoSum(int[] num, int start, int target){
        int r = num.length -1;
        List<List<Integer>> list = new ArrayList<List<Integer>>();
        int l = start;
        while(l < r){
            if(target == num[l] + num[r]){
                List<Integer> cur = new ArrayList<Integer>();
                cur.add(num[l]);
                cur.add(num[r]);
                list.add(cur);
                l++;
                r--;
                while(l < r && num[l] == num[l-1]) l++;
                while(l < r && num[r] == num[r+1]) r--;
            }else if(target < num[l] + num[r])
                r--;
            else l++;
        }
        return list;
    }
   
```


<br>
<br>


###16 3Sum Closest


>Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. **You may assume that each input would have exactly one solution**.

    For example, given array S = {-1 2 1 -4}, and target = 1.

    The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).
    
**Idea**: It's much similar with the method in three sum, the only difference here is that we calculate the minimum difference use the twosum helper funtion for each item in the array. 

**Attention**: 

1) Each time we compare the **abs** of the difference 

**Time** O(n ^ 2)

**Space** O(1)

```java
    public int threeSumClosest(int[] num, int target) {
	    if(num == null || num.length == 0) return 0;
	    int res = Integer.MAX_VALUE;
	    Arrays.sort(num);
	    for(int i = 0; i <= num.length -3; i++){
	        if(i != 0 && num[i] == num[i-1]) continue;
	        int dif = twoSumClosest(num, i + 1, target-num[i]);
	        if(Math.abs(dif) < Math.abs(res)) res = dif;
	    }
	    return res+target;
	}
	
	public int twoSumClosest(int[] num, int start, int target){
	    int r = num.length - 1;
	    int l = start;
	    int res = Integer.MAX_VALUE;
	    while(l < r){
	        if(Math.abs(num[l] + num[r] - target) < Math.abs(res))
	            res = num[l] + num[r] - target;
	        if(num[l] + num[r] == target)
	            return 0;
	        else if(num[l] + num[r] > target)
	            r--;
	        else 
	            l++;
	        
	    }
	    return res;
	}
	
```


<br>
<br>



###17 Number Combinations of a Phone Number

>  Given a digit string, return all possible letter combinations that the number could represent.

> A mapping of digit to letters (just like on the telephone buttons) is given below.

<pre>

Input:Digit string "23"
Output: ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].

</pre>

> Note:

> Although the above answer is in lexicographical order, your answer could be in any order you want.


**Idea**: This problem is much similar to calculate the combinations. Each time we add each character of a string to all existing strings in the set. Then we go to the next String.

**Time Complexity** : O(k ^ n), k is possible choice of each digit, n is the length of digits


```java

    public List<String> letterCombinations(String digits) {
        List<String> res = new ArrayList<String>();
        if(digits == null || digits.length() == 0) return res;
        for(int i = 0; i < digits.length(); i++){
            String cur = getLetters(digits.charAt(i));
            List<String> temp = new ArrayList<String>();
            if(res.size() == 0){
                for(int j = 0; j < cur.length(); j++){
                    res.add(cur.charAt(j) + "");
                }
            }else{
                for(String s : res){
                    for(int k = 0; k < cur.length(); k++){
                        temp.add(s + cur.charAt(k));
                    }
                }
                res = temp;      
            }
        }
        return res;
        
    }
    
    public String getLetters(char digit){
        switch(digit){
            case '9' : return "wxyz";
            case '8' : return "tuv";
            case '7' : return "pqrs";
            case '6' : return "mno";
            case '5' : return "jkl";
            case '4' : return "ghi";
            case '3' : return "def";
         case '2' : return "abc";
            default: return "";
        }
    }

```

<br>

<br>

###18 4Sum

>Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.

>Note:

- Elements in a quadruplet (a,b,c,d) must be in **non-descending order**. (ie, a ≤ b ≤ c ≤ d)

- The solution set must **not contain duplicate quadruplets**.
 
 
 For example, given array S = {1 0 -1 0 -2 2}, and target = 0.

        A solution set is:
   	    (-1,  0, 0, 1)
        (-2, -1, 1, 2)
        (-2,  0, 0, 2)
    
<br>

**Idea**: Use the 3Sum to calculate 4Sum. 

**Time** O(n ^ 3)

**Space** O(n ^ 2)
```java
    public List<List<Integer>> fourSum(int[] num, int target) {
        List<List<Integer>> list = new ArrayList<List<Integer>>();
        if(num == null || num.length <= 3) return list;
        Arrays.sort(num);
        for(int i = 0; i <= num.length - 4; i++){
            if(i != 0 && num[i] == num[i-1]) continue;
            List<List<Integer>> current = threeSum(num, i+1, target - num[i]);
            for(List<Integer> l : current){
                l.add(0, num[i]);
            }
            list.addAll(current);
        }
        return list;
    }
    
    public List<List<Integer>> threeSum(int[] num, int start, int target){
         List<List<Integer>> list = new ArrayList<List<Integer>>();
         for(int i = start; i <= num.length - 3; i++){
             if(i != start && num[i] == num[i-1]) continue;
             List<List<Integer>> current = twoSum(num, i+1, target - num[i]);
              for(List<Integer> l : current){
                l.add(0, num[i]);
            }
            list.addAll(current);
         }
         return list;
    }
    
    public List<List<Integer>> twoSum(int[] num, int start, int target){
         List<List<Integer>> list = new ArrayList<List<Integer>>();
         int r = num.length -1;
         int l = start;
         while(l < r){
             if(num[l] + num[r] == target){
                 List<Integer> cur = new ArrayList<Integer>();
                 cur.add(num[l]);
                 cur.add(num[r]);
                 list.add(cur);
                 l++;
                 r--;
                 while(l < r && num[l] == num[l-1]) l++;
                 while(l < r && num[r] == num[r+1]) r--;
             }else if(num[l] + num[r] < target) l++;
             else r--;
         }
         return list;
    }
 
``` 
 
 **Other Idea**: 
 
 we can twoSum combine twoSum to calculate 4Sum. Time complexity would be O(n^2 * lgn)
 

    

<br>
<br>



###19 Remove Nth Node From End of List
>Given a linked list, remove the nth node from the end of list and return its head.

For example,

   Given linked list: 1->2->3->4->5, and n = 2.

After removing the second node from the end, the linked list becomes 1->2->3->5.
Note:

Given n will always be valid.
Try to do this in one pass.

**Idea**: Use two pointers, p1, p2. First move p1 k steps, then move p1 and p2 together until p1 change to null. At this time, p2 points to the node we need to delete. 

**Attention**: 

- 1) if after k steps, p1 is null, then return head.next
- 2) record pre

<br>
```java
    public ListNode removeNthFromEnd(ListNode head, int n) {
    	if(head == null) return null;
    	ListNode l1 = head;
    	ListNode l2 = head;
    	while(n > 0){
    	    l1 = l1.next;
    	    n--;
    	}
    	if(l1 == null) return head.next;
    	ListNode pre = null;
    	while(l1 != null){
    	    pre = l2;
    	    l2 = l2.next;
    	    l1 = l1.next;
    	}
    	pre.next = l2.next;
    	return head;
    }

```


<br>
<br>

###20 Valid Parentheses

> Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.

> The brackets must close in the correct order, "()" and "()[]{}" are all valid but "(]" and "([)]" are not.


**Idea**: Use a stack to record parentheses. When encounter ( , [, { push to stack.
when encounter ), ], } pop corresponding parentheses.


**Java code**:


```java


    public boolean isValid(String s) {
        if(s == null || s.length() == 0) return true;
        Stack<Character> stack = new Stack<Character>();
        for(int i = 0; i < s.length(); i++){
            char c = s.charAt(i);
            if(stack.isEmpty() && (c == ')' || c == ']' || c == '}')) return false;
            if(c == '(' || c == '[' || c == '{') stack.push(c);
            else if(c == ')' || c == ']' || c == '}'){
                if((c == ')' && stack.peek() != '(') || (c == ']' && stack.peek() != '[') || (c == '}' && stack.peek() != '{')) 
                    return false;
                else stack.pop();
            }
        }
        return stack.isEmpty();
    }


```



<br>


<br>



###21 Merge Two Sorted Lists

> Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.

**Attention**:

- 1) Use a fake head, thus we don't need to check if head is null


```java
       public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
	    if(l1 == null) return l2;
	    if(l2 == null) return l1;
	    ListNode fakeHead = new ListNode(-1);
	    ListNode temp = fakeHead;
	    while(l1 != null && l2 != null){
	        if(l1.val > l2.val){
	            temp.next = l2;
	            l2 = l2.next;
	        }else{
	            temp.next = l1;
	            l1 = l1.next;
	        }
	        temp = temp.next;
	    }
	    if(l1 != null) temp.next = l1;
	    if(l2 != null) temp.next = l2;
	    return fakeHead.next;
    }  
```


<br>
<br>


###22 Generate Parentheses

> Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.

> For example, given n = 3, a solution set is:

> "((()))", "(()())", "(())()", "()(())", "()()()"

**Idea**: insert "\(\)" to possible spots of every parentheses string. eg : (), we have three spaces to insert. Inspite of duplicates, there are two possible ()() or (()). 

**Iterative code **:

```java
    public List<String> generateParenthesis(int n) {
        List<String> res = new ArrayList<String>();
        res.add("");
        if(n <= 0) return res;
        for(int i = 0; i < n; i++){
            List<String> cur = new ArrayList<String>();
            for(String s : res){
                for(int j = 0; j <= s.length(); j++){
                    String temp =  s.substring(0, j) + "()" + s.substring(j, s.length());
                    if(!cur.contains(temp)) cur.add(temp);
                }
            }
            res = cur;
        }
        return res;
    }

```


**Recursion**:

```java

    public List<String> generateParenthesis1(int n) {
    	List<String> list = new ArrayList<String>();
    	if(n == 0){
    		list.add("");
    		return list;
    	}else if (n == 1){
    		list.add("()");
    		return list;
    	}
    	
    	return helper(n);
    	
    }
    
    public List<String> helper(int n){
    	if(n == 0){
    		List<String> list = new ArrayList<String>();
    		list.add("");
    		return list;
    	}
    	List<String> list  = helper(n-1);
    	List<String> result = new ArrayList<String>();
    	for(String s : list){
    		for(int i = 0, len = s.length(); i <= len; i++){
    			String newS = s.substring(0, i) + "()" + s.substring(i, s.length());
    			if(!result.contains(newS)) result.add(newS);
    		}
    	}
    	return result;
    }

```

<br>

<br>


###23 Merge k Sorted Lists

> Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.

**Idea**:

1) Solution1:

Use priorityqueue, add the head of k lists two queue, each time poll the smallest element from the queue then add the smallest.next to the queue until queue is empty. We need to to give another another parameter to priorityqueue when initialize.

```java

	PriorityQueue queue = new PriorityQueue(size, new Comparator<ListNode>(){
		public int compare(ListNode arg1, ListNode arg2){
			return arg1 - arg2;
		}
	});
	
```	


**Time complexity: nklgk** (lgk for insert element, nk elements).

**Space** O(k)

2) Solution2:

Use the idea in merge sort and use the method in [21 Merge Two Sorted Lists](#21-merge-two-sorted-lists) to merge two elements.

**Time**: O(knlgk)

**Solution1 code**:

<br>
```java
    public static ListNode mergeKLists(List<ListNode> lists){
        if(lists == null || lists.size() == 0) return null;
        ListNode res = new ListNode(-1);
        ListNode h1 = res;
        PriorityQueue<ListNode> queue = new PriorityQueue<ListNode>(lists.size(),new Comparator<ListNode>(){
            public int compare(ListNode l1, ListNode l2){
                return l1.val - l2.val;
            }
        });
        for(ListNode l : lists){
            if(l != null) queue.add(l);
        }
        while(!queue.isEmpty()){
            ListNode current = queue.poll();
            h1.next = current;
            h1 = h1.next;
            if(current.next != null)
                queue.offer(current.next);
        }
        return res.next;
	}
```

**Solution 2 code**
```java
	public  ListNode mergeKLists1(List<ListNode> lists){
		  if(lists == null || lists.size() == 0) return null;
		  return helper(lists, 0, lists.size()-1);
		}
		public ListNode helper(List<ListNode> lists, int start, int end){
		    if(start >= end) return lists.get(start);
		    int mid = (start + end)/2;
		    return mergeTwoLists(helper(lists, start, mid), helper(lists, mid+1, end));
		}
		
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
	    if(l1 == null) return l2;
	    if(l2 == null) return l1;
	    ListNode fakeHead = new ListNode(-1);
	    ListNode temp = fakeHead;
	    while(l1 != null && l2 != null){
	        if(l1.val > l2.val){
	            temp.next = l2;
	            l2 = l2.next;
	        }else{
	            temp.next = l1;
	            l1 = l1.next;
	        }
	        temp = temp.next;
	    }
	    if(l1 != null) temp.next = l1;
	    if(l2 != null) temp.next = l2;
	    return fakeHead.next;
    }
```

**Brute force** time limit exceeded

```java
method1: each time find the minimum from the k nodes, and add it to the result list. Time k * n * k = O(k^2*n)

	 /* Brute force: time limit exceeded*/
		public  ListNode mergeKLists2(List<ListNode> lists){
		    if(lists == null || lists.size() == 0) return null;
		    ListNode head = new ListNode(-1);
		    ListNode temp = head;
		    List<ListNode> l = new ArrayList<ListNode>();
		    for(int i = 0; i < lists.size(); i++){
		        if(lists.get(i) != null) l.add(lists.get(i));
		    }
		    while(l.size() > 0){
		    	int min = 0;
		        for(int i = 0; i < l.size(); i++){
		            if(l.get(i) == null) l.remove(i);
		            else {
		            	if(l.get(i).val < l.get(min).val) min = i;
		            }
		        }
		        if(l.size() > 0){
		        	temp.next = l.get(min);
		        	if(l.get(min).next != null) l.set(min,l.get(min).next);
		        	else l.remove(min);
		        	temp = temp.next;
		        }
		    }
		    return head.next;
		}
	
```

method2: each time merge two lists, until all lists are merged.
```java
	/*Brute force, use merge2 method */
	public  ListNode mergeKLists3(List<ListNode> lists) {
		if( lists == null || lists.size() == 0) return null;
		ListNode result = lists.get(0);
		for(int i = 1; i < lists.size(); i++){
			ListNode currentList = lists.get(i);
			result = mergeTwoLists(result, currentList);

		}
		
		return result;
	}

```



<br>
<br>


###24 Swap Nodes in Pairs

>Given a linked list, swap every two adjacent nodes and return its head.

For example,
Given 1->2->3->4, you should return the list as 2->1->4->3.

Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed.

**Idea**: Just swap pair each time until end. 

**Attention**: If the number of nodes is odd, we need to add the last node to the list.

```java
   public ListNode swapPairs(ListNode head) {
	    if(head == null || head.next == null) return head;
	    ListNode fakeHead = new ListNode(-1);
	    ListNode temp = fakeHead;
	    while(head != null && head.next != null){
	        ListNode nextnext = head.next.next;
	        temp.next = head.next;
	        temp.next.next = head;
	        temp = head;
	        head = nextnext;
	    }
	    temp.next = head;
	    return fakeHead.next;
	  }
```




<br>
<br>


###25 Reverse Nodes in kGroup

> Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.
>
>If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.
>
>You may not alter the values in the nodes, only nodes itself may be changed.
>
>Only constant memory is allowed.
>

>For example,

>Given this linked list: 1->2->3->4->5

>For k = 2, you should return: 2->1->4->3->5

>For k = 3, you should return: 3->2->1->4->5r



**Idea**: Reverse k nodes each time then catenenate the current reverse list with the previous reverse list.


**Attention**:

- 1)the left-out nodes less than k nodes should remain the same.
- 2)For the first node of each reverse list, we should set it's next to null to avoid cycle or double linked list. 



```java

    public ListNode reverseKGroup(ListNode head, int k) {
        if(head == null || head.next == null || k <= 1) return head;
        int len = 0;
        ListNode temp = head;
        while(temp != null){
            len++;
            temp = temp.next;
        }
        if(k > len) return head;
        ListNode res = null, cur = null, pre = null, next = null, savehead = null;
        for(int i = 1; i <= len && i + k <= len+1; i += k){
            savehead = head;
            for(int j = 1; j <= k; j++){
                next = head.next;
                if(cur == null) {
                    cur = head;
                    cur.next = null;
                }else{
                    head.next = cur;
                    cur = head;
                }
                head = next;
            }
            if(res == null) res = cur;
            else{
                pre.next = cur;
            }
            pre = savehead;
            cur = null;
        }
        
        if(head != null) pre.next = head;
        return res;
    }

```



<br>

<br>



### 26 Remove Duplicates from Sorted Array

>Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.
>
>Do not allocate extra space for another array, you must do this in place with constant memory.
>
>For example,
>
>Given input array A = [1,1,2],
>
>Your function should return length = 2, and A is now [1,2].

**Idea**: Record an index, all element before this index contains no duplicates. Insert the new unduplicate element at index. 


**Java code**:

```java

    public int removeDuplicates(int[] A) {
        if(A == null) return 0;
        if(A.length <= 1) return A.length;
        int count = 1;
        int pre = A[0];
        for(int i = 1; i < A.length; i++){
            if(A[i] == pre) continue;
            A[count++] = A[i];
            pre = A[i];
        }
        return count;
    }

```


<br>

<br>


###27 Remove Element

>Given an array and a value, remove all instances of that value in place and return the new length.

>The order of elements can be changed. It doesn't matter what you leave beyond the new length

**Idea**: if A[i] != elem, copy element to record index. 

**Java Code**:


```java

    public int removeElement(int[] A, int elem) {
        if(A == null || A.length == 0) return 0;
        int count = 0;
        for(int i = 0; i < A.length; i++){
            if(A[i] == elem) continue;
            A[count++] = A[i];
        }
        return count;
    }


```

<br>

**Related**: Remove Adjacent Repeated Characters

> eg: “aaaabbbc” : “abc”

**Idea**: Left and right pointer

```java
  public String deDup(String input) {
    if (input == null || input.length() == 0) {
      return input;
    }
    char[] arr = input.toCharArray();
    int l = 0;
    int r = 1;
    while (r < input.length()) {
      if (arr[r] == arr[l]) {
        r++;
      } else {
        arr[l + 1] = arr[r++];
        l++;
      }
    } 
    return new String(arr, 0, l+1);
  } 

```

<br>

**Related**: Remove spaces

> eg: “   I     love MTV ” --> “I love MTV”

```java
  public String removeSpaces(String input) {
    if (input == null || input.length() == 0) {
      return input;
    }
    char[] arr = input.toCharArray();
    int r = 0;
    for (int i = 0; i < arr.length; i++) {
      if ((i == 0 || arr[i-1] == ' ') && arr[i] == ' ') {
        continue;
      }
      arr[r++] = arr[i];
    }
    // check if last character is " "
    if (r != 0 && arr[r - 1] == ' ') {
      return new String(arr, 0, r - 1);
    }
    return new String(arr, 0, r);
  }

```
<br>

**Related**: remove certain characters:

>eg: input = "abcd", t = "ab" ===> "cd".

```java
  public String remove(String input, String t) {
    if (input == null || t == null || t.length() == 0) {
      return input;
    }
    char[] arr = input.toCharArray();
    int r = 0;
    for (int i = 0; i < input.length(); i++) {
      boolean found = false;
      for (int j = 0; j < t.length(); j++) {
        if (arr[i] == t.charAt(j)) {
          found = true;
          break;
        }
      }
      if (!found) {
        arr[r++] = arr[i];
      }
    }
    return new String(arr, 0, r);
  }

```

<br>
**Related**: Remove Adjacent Repeated Characters

> eg: "abbbaaccz" → "aaaccz" → "ccz" → "z"

```java
  public String deDup(String input) {
    if (input == null || input.length() <= 1) {
      return input;
    }
    char[] arr = input.toCharArray();
    int r = 0;
    for (int i = 1; i < input.length(); i++) {
      if (r == -1 || arr[i] != arr[r]) {
        arr[++r] = arr[i];
      } else {
        --r;
        while (i < input.length() - 1 && arr[i] == arr[i+1]) {
          i++;
        } 
      }
    }
    return new String(arr, 0, r + 1);
  }
```


<br>

<br>


###28 Implement strStr

> Implement strStr().
>
>Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.
>
>Update (2014-11-02):

>The signature of the function had been updated to return the index instead of the pointer. If you still see your function signature returns a char * or String, please click the reload button  to reset your code definition.

**Idea**: It asks us to implement a function like indexOf(string) in java. The easiest way is a O(n^2) solution, just like the time complexity of indexOf. We begin from the first chracter of haystack, check if it has the needle begin at index i. We can also use KMP string match algorithm to implement it in O(n) time. See detail at [kmp](http://wishyouhappy.github.io/2014/12/26/kmp%20algorithm\(knuth-morris-pratt\)).

**Code of solution1**: O(n^2)


```java
	public int strStr(String haystack, String needle) {
        if (haystack == null || needle == null) {
            return -1;
        }
        boolean contain = true;
        for (int i = 0; i <= haystack.length() - needle.length(); i++){
            for (int j = i; j < i + needle.length(); j++){
                if (haystack.charAt(j) != needle.charAt(j-i)){
                    contain = false;
                    break;
                } 
            }
            if (contain) {
                return i;
            }
            contain = true;
        }
        return -1;
    }

```
**Code of solution2**: O(n^2), use the library substring method

```java

    public int strStr(String haystack, String needle) {
       if (haystack == null || needle == null) {
           return -1;
       }
       for (int i = 0; i <= haystack.length() - needle.length(); i++) {
           String temp = haystack.substring(i, needle.length() + i);
           if (temp.equals(needle)) {
               return i;
           }
       }
       return -1;
    }

```

**Code of solution3**: O(n)
 
```java

	public int strStr(String haystack, String needle){
		if (haystack == null || needle == null || (haystack.length() < needle.length())) { 
		    return -1;
		}
		if (needle.equals("")) {
		    return 0;
		}
		int[] helper = getHelperArray(needle);
		int i = 0;
		int j = 0;
		int textLen = haystack.length();
		int patternLen = needle.length();
		while (i < textLen && j < patternLen){
			if(haystack.charAt(i) == needle.charAt(j)){
				j++;
				i++;
			}
			if(j == patternLen){
				return i - patternLen;
				//j = helper[j-1]; //if we want find all matches. 
			} else if ((i < textLen && j < patternLen) &&haystack.charAt(i) != needle.charAt(j)){
				if(j != 0) {
				    j = helper[j-1];
				} else {
				    i++;
				}
			}
		}
		return -1;
	}
	
	public int[] getHelperArray(String pattern){
		int i = 1; //suffix
		int	j = 0; //prefix
		int len = pattern.length();
		int[] helper = new int[len];
		helper[0] = 0;
		
		while (i < len){
			if (pattern.charAt(i) == pattern.charAt(j)) {
				j++;
				helper[i] = j;
				i++;
			} else {
				if (j != 0) {
				    j = helper[j-1];
				} else{
					helper[i] = 0;
					i++;
				}
			}
		}
		return helper; 
	}

```

<br>

<br>




###29 Divide Two Integers

>Divide two integers without using multiplication, division and mod operator.

If it is overflow, return MAX_INT.


**Idea**: Each integer can be represent as binary format, so n = (0 or 1) * 2 ^ n +(0 or 1) * 2 ^ (n-1) + ......

We can respresent the result = (0 or 1) * 2 ^ n +(0 or 1) * 2 ^ (n-1) + ......

Thus [(0 or 1) * 2 ^ n +(0 or 1) * 2 ^ (n-1) + ......)] * divisor = dividend

Thus, we can calculate (0 or 1) * 2 ^ i, i from n to 0, and combine them together.


**Time complexity** : O(lgn)

**Space**: O(1)

**Attention**:

- abs (Integer.MIN_VALUE) = Integer.MIN_VALUE
- when calculate n, eg:  while(divisor <= (dividend >> 1)) we can not change to while((divisor<<1) <= dividend). It might overflow and keep loop forever.
- Take care of some corner case, eg: dividend = Integer.MIN_VALUE or divisor = Integer.MIN_VALUE


<br>

```java
	public int divide( int dividend, int divisor){
	       if(divisor == 0) return Integer.MAX_VALUE;
	       int result = 0;
	       boolean positive = ((dividend ^ divisor) >>> 31) == 0;
	       if(divisor == Integer.MIN_VALUE){
	           if(dividend == Integer.MIN_VALUE) return 1;
	           else return 0;
	       }
	       if(dividend == Integer.MIN_VALUE){
	           if(divisor == 1) return Integer.MIN_VALUE;
	           else if(divisor == -1) return Integer.MAX_VALUE;
	           dividend += Math.abs(divisor);
	           result += 1;
	       }
	       
	       dividend = Math.abs(dividend);
	       divisor = Math.abs(divisor);
	       
	       int count = 0;
	       while(divisor <= (dividend >> 1)){
	           count++;
	           divisor <<= 1;
	       }
	       
	       while(count >= 0){
	           if(dividend >= divisor){
	               result += 1 << count;
	               dividend -= divisor;
	           }
	           divisor >>= 1;
	           count --;
	       }
	       return positive ? result : -result;
	    }


```


<br>

<br>


###30 SubString with Concatenation of All Words

> You are given a string, S, and a list of words, L, that are all of the same length. Find all starting indices of substring(s) in S that is a concatenation of each word in L exactly once and without any intervening characters.

<pre>
For example, given:
S: "barfoothefoobarman"
L: ["foo", "bar"]
</pre>

You should return the indices: [0,9].
(order does not matter).

**Idea**: Store a dictionary of L. We use map to record each word of L and their occurence. Then for each index of S from 0, check if there is matches. 


**Java Code**:

```java

    public List<Integer> findSubstring(String S, String[] L) {
    	List<Integer> list = new ArrayList<Integer>();
    
    	if(S == null || S.length() == 0 || L == null || L.length == 0) return list;
    	if(S.length() < L.length * L[0].length()) return list;
    	
    	Map<String, Integer> map = new HashMap<String, Integer>();
    	for(int i = 0, len = L.length; i < len; i++){
    		String current = L[i];
    		if(map.containsKey(current)) map.put(current, map.get(current)+1);
    		else map.put(current, 1);
    	}
    	
    	int unitLen = L[0].length();
    	int sLen = S.length();
    	int totalStr = L.length;
    	int i = 0;
    	
    	while(sLen - i >= unitLen * totalStr){
    		Map<String, Integer> tempMap = new HashMap<String, Integer>(map);
    		for(int j = 0; j < totalStr; j++){
    			String current = S.substring(i+j*unitLen, i + (j+1)*unitLen);
    			if(!tempMap.containsKey(current)) break;
    			if(tempMap.get(current) == 1) tempMap.remove(current);
    			else tempMap.put(current,tempMap.get(current)-1);
    		}
			if(tempMap.size() == 0) list.add(i);
    		i++;
    	}
    	
    	return list;   
    }


```






<br>

<br>


###31 Next Permutation

>Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.

>If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).

>The replacement must be in-place, do not allocate extra memory.

>Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.

<pre>
1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1
</pre>


**Idea**: The next permutation is the permutation that larger than the original permutation and the immediate larger one. We can also think this as a successor. We can find the next permutation by the following steps:

- 1) from the end, find the first non-increasing element, eg 1 2 3 5 4. Then we need to find is 3. Record this index. If it's -1, say 5, 4, 3, 2, 1., in this case we can reverse the array to 1, 2, 3, 4, 5 and end the function.

- 2) from the index1 we record in step 1, we find the smallest element larger than num[index1]. Record this index2.

- 3) swap element at index1 and index2, then reverse element after index1. 

For example. a permutation of 1 2 3 4 5 would be:

1 2 3 4 5

1 2 3 5 4

1 2 4 3 5

1 2 4 5 3

1 2 5 3 4

1 2 5 4 3

1 3 2 4 5

1 3 2 5 4

1 3 4 2 5

1 3 4 5 2 

.......


**Attention**

- 1) for step 1, when find the non-inceasing element we allow the equal element. eg: 1 2 5 4 4 3. We should find 2, the index1. Consider test case "[1 1]"
- 2) for step 2, we should find element larger than num[index1]. If change to >=, then it doesn't work. Consider test case "[1, 5, 1]"

**Java code**:

```java
public void nextPermutation(int[] num) {
    if(num == null || num.length == 0) {
        return;
    }
    int i = num.length - 2;
    while (i >= 0 && num[i] >= num[i+1]) {
        i--;
    }
    int index1 = i;
    if (i == -1) {
        reverse(num, 0);
        return;
    }
    i = num.length - 1;
    while (i >= 0 && num[i] <= num[index1]) {
        i--;
    }
    swap(num, index1, i);
    reverse(num, index1 + 1);
}

public void reverse(int[] num, int i) {
    for (int j = i; j < (num.length - i) / 2 + i; j++) {
        swap(num, j, num.length + i - j - 1);
    }
}
public void swap(int[] num, int i, int j) {
    int temp = num[i];
    num[i] = num[j];
    num[j] = temp;
}

```



<br>

<br>


###32 Longest Valid Parentheses


>Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring.

>For "(()", the longest valid parentheses substring is "()", which has length = 2.

>Another example is ")()())", where the longest valid parentheses substring is "()()", which has length = 4.


**Idea**: This problem has some similarities with the valid parentheses, we need to use the method in that problem to check if the current sequence of parentheses is valid. We use a stack to match the parentheses. The difference is that we store the **index** of the parenthese other than index. Because there is only one type of parentheses, so it's ok to store just the index. 

Then how to calculate the longest valid parentheses? Like the valid parentheses problem, everytime, we encounter a '(', we push the current index. Then if the parentheses is ')', Obviously, if the stack is empty, then the previous parentheses sequence cannot be a valid parentheses, so we update the valid parentheses start position. Otherwise, we need to calculate the local longest parentheses. 

**Attention**: When we calculate the local longest, we need to compare the max with i-stack.peek() after we pop an element from the stack because we need to count in the previous valid sequences. Eg: (()(). 


**Java code**:

```java
    public int longestValidParentheses(String s) {
        if(s == null || s.length() == 0) return 0;
        int max = 0;
        int start = 0;
        Stack<Integer> stack = new Stack<Integer>();
        for(int i = 0; i < s.length(); i++){
            if(stack.isEmpty() && s.charAt(i) == ')') start = i+1;
            else if(s.charAt(i) == ')'){
                stack.pop();
                max = stack.isEmpty()?Math.max(max, i -start+1) : Math.max(max, i-stack.peek());
            } 
            else if(s.charAt(i) == '(') stack.push(i);
        }
        return max;
    }


```


<br>

<br>



###33 Search in Rotated Sorted Array


>Suppose a sorted array is rotated at some pivot unknown to you beforehand.

>(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).

>You are given a target value to search. If found in the array return its index, otherwise return -1.

>You may assume no duplicate exists in the array.

**Idea**: There is no duplicate, so after rotation, the array can be look as two parts, and these two parts are all in ascending order. Thus we can use the binary search method, and update the l and r pointer based on the comparison. See details of comparison on the code.


**Java code**: 


**Time**: O(lgn)

```java

	    public int search(int[] A, int target) {
        if(A == null || A.length == 0) {
        	return -1;
        }
        int l = 0;
        int r = A.length-1;
        while(l <= r){
           int mid = l + (r - l) / 2;
           if (A[mid] == target) {
               return mid;
           } else if (A[mid] >= A[l]) {
               if (A[l] <= target && A[mid] > target) {
                   r = mid - 1;
               } else {
                   l = mid + 1;
               }
           } else {
               if (A[mid] < target && A[r] >= target) {
                   l = mid + 1;
               } else {
                   r = mid - 1;
               }
           }
        }
        return -1;
    }

```

**Another way**: It can handle duplicates, but this is not lg(n) at worst case. 


```java
       public int search(int[] A, int target) {
        if(A == null || A.length == 0) {
            return -1;
        }
        int l = 0;
        int r = A.length-1;
        while(l <= r){
            int mid = (l+r)/2;
            if(A[mid] == target) {
                return mid;
            } else if(A[mid] > target && A[mid] < A[r]) {
                r = mid-1;
            } else if(A[mid] < target && A[mid] > A[l]) {
                l = mid + 1;
            } else if (A[l] != target) {
                l++;
            } else {
                return l;
            }
        }
        return -1;
    }
```

<br>
<br>



###34 Search for a Range

>Given a sorted array of integers, find the starting and ending position of a given target value.

>Your algorithm's runtime complexity must be in the order of O(log n).

>If the target is not found in the array, return [-1, -1].

>For example,

>Given [5, 7, 7, 8, 8, 10] and target value 8,

>return [3, 4].

<br>

**Idea**: We need to find the range in O(lgn), thus binary search comes to mind. We could use binary search to find the target, then for the left and right part, we do binary search again to find the left boundary and right boundary.

The second solution is similar to the first one, the differce is that we do twice binary search to do the left boundary and right boundary. Remember to check the value of the two boundaries. Because in this method, we might not find the target element. 


**Solution1**:


```java
     public int[] searchRange(int[] A, int target) {
       int[] res = {-1, -1};
       int l = 0;
       int r = A.length - 1;
       while ( l <= r) {
           int mid = l + (r - l) / 2;
           if (target > A[mid]) {
               l = mid + 1;
           } else if (target < A[mid]) {
               r = mid - 1;
           } else {
               int lr = mid;
               int rl = mid;
               while (l <= lr) {
                   int mid1 = l + (lr - l) / 2;
                   if (target <= A[mid1]) {
                       lr = mid1 - 1;
                   } else {
                       l = mid1 + 1;
                   }
               }
               res[0] = l;
               while (rl <= r) {
                   int mid2 = rl + (r - rl) / 2;
                   if (target >= A[mid2]) {
                       rl = mid2 + 1;
                   } else {
                       r = mid2 - 1;
                   }
               }
               res[1] = r;
               return res;
           }
           
       }
       return res;
    }    

```


**Solution 2**:

```java
    public int[] searchRange(int[] A, int target) {
       int[] res = {-1, -1};
       int ll = 0;
       int lr = A.length - 1;
       int rl = 0;
       int rr = A.length - 1;
       while (ll <= lr) {
           int mid1 = ll + (lr - ll) / 2;
           if (A[mid1] >= target) {
               lr = mid1 - 1;
           } else {
               ll = mid1 + 1;
           }
       }
       while (rl <= rr) {
           int mid2 = rl + (rr - rl) / 2;
           if (A[mid2] <= target) {
               rl = mid2 + 1;
           } else {
               rr = mid2 - 1;
           }
       }
       if (ll <= rr) {
           res[0] = ll;
           res[1] = rr;
       }
       return res;
    }
```


**Related: first occurrence:**

```java
public int firstOccur(int[] array, int target) {
    // Write your solution here
    if (array == null || array.length == 0) {
      return -1;
    }
    int l = 0;
    int r = array.length - 1;
    while (l <= r) {
      int mid = l + (r - l) / 2;
      if (array[mid] >= target) {
        r = mid - 1;
      } else {
        l = mid + 1;
      }
    }
    return (l < array.length && array[l] == target) ? l : -1;
}

```


**Related: last occurrence**:

```java
public int lastOccur(int[] array, int target) {
    // Write your solution here
    if (array == null || array.length == 0) {
      return -1;
    }
    int l = 0;
    int r = array.length - 1;
    while (l <= r) {
      int mid = l + (r - l) / 2;
      if (array[mid] <= target) {
        l = mid + 1;
      } else {
        r = mid - 1;
      }
    }
    return (r >= 0 && array[r] == target) ? r : -1;
}
```

**Related: find k closest**:
```java
public int[] kClosest(int[] array, int target, int k) {
    // Write your solution here
    if (array == null || array.length == 0) {
      return array;
    }
    int[] res = new int[k];
    int l = 0;
    int r = array.length - 1;
    while (l <= r) {
      int mid = l + (r - l) / 2;
      if (array[mid] == target) {
        l = mid;
        break;
      } else if (array[mid] > target) {
        r = mid - 1;
      } else {
        l = mid + 1;
      }
    }
    int indexL = l - 1;
    int indexR = l;
    
    for (int i = 0; i < k; i++) {
      if (indexL >= 0 && indexR < array.length) {
        res[i] = Math.abs(array[indexL] - target) - Math.abs(array[indexR] - target) > 0 ? array[indexR++] : array[indexL--];
      } else if (indexL >= 0) {
        res[i] = array[indexL--];
      } else {
        res[i] = array[indexR++];
      }
    }
    
    return res;
  }
```

**Related: search in unknown size sorted array**:
```java
class Dictionary{
    int[] array = {1, 2, 4, 5, 6, 7, 8, 9, 10};
    public Integer get(int index){
        if (index >= array.length) {
            return null;
        }
        return array[index];
    }
}

public int search(Dictionary dict, int target) {
    // Write your solution here
    int bounds = findBound(dict, target);
    int l = 0;
    int r = bounds;
    while (l <= r) {
      int mid = l + (r - l) / 2;
      if (dict.get(mid) == null || dict.get(mid) > target) {
        r = mid - 1;
      } else if (dict.get(mid) == target) {
        return mid;
      } else{
        l = mid + 1;
      }
    }
    return -1;
  }
  
  public int findBound(Dictionary dict, int target) {
    int i = 1;
    while(true) {
      if (dict.get(i) == null || dict.get(i) > target) {
        return i;
      } else {
        i *= 2;
      }
    }
  }
```

**Related: total occurrence**:

```java
  public int totalOccurrence(int[] array, int target) {
    // Write your solution here
    if (array == null || array.length == 0) {
      return 0;
    }
    int l = 0;
    int r = array.length - 1;
    while (l <= r) {
      int mid = l + (r - l) / 2;
      if (array[mid] >= target) {
        r = mid - 1;
      } else {
        l = mid + 1;
      }
    }
    int l1 = 0;
    int r1 = array.length - 1;
    while (l1 <= r1) {
      int mid = l1 + (r1 - l1) / 2;
      if (array[mid] <= target) {
        l1 = mid + 1;
      } else {
        r1 = mid - 1;
      }
    }
    if (l <= r1) {
      return r1 - l + 1;
    }
    return 0;
  }
```

<br>
<br>


###35 Search Insert Position


>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.

>You may assume no duplicates in the array.

>Here are few examples.

<pre>
[1,3,5,6], 5 → 2
[1,3,5,6], 2 → 1
[1,3,5,6], 7 → 4
[1,3,5,6], 0 → 0
</pre>


<br>
**Idea**: Just like the method used in search range, we use binary search, when l > r, l is the first element larger then the target. 

**Time** : log(n)

```java 
    public int searchInsert(int[] A, int target) {
        if (A == null || A.length == 0) {
            return 0;
        }
        int l = 0;
        int r = A.length - 1;
        while (l <= r) {
            int mid = l + (r - l)/2;
            if (A[mid] == target) {
                return mid;
            } else if (A[mid] < target) {
                l = mid + 1;
            } else {
                r = mid - 1;
            }
        }
        return l;
    }

```

<br>

<br>

###36 Valid Sudoku

>Determine if a Sudoku is valid, according to: Sudoku Puzzles - The Rules.

>The Sudoku board could be partially filled, where empty cells are filled with the character '.'.

**Rules about sudoku**:

- 1) 9×9 grid
- 2) each column, each row, and each of the nine 3×3 sub-grids that compose the grid (also called "boxes", "blocks", "regions", or "sub-squares") contains all of the digits from 1 to 9

**Idea**: Check each row, each column and each 3*3 blocks.


**Java code**:

```java


    public boolean isValidSudoku(char[][] board) {
        if(board == null || board.length != 9 || board[0].length != 9) return false;
        for(int i = 0; i < board.length; i++){
            Set<Character> rset = new HashSet<Character>();
            Set<Character> cset = new HashSet<Character>();
            for(int j = 0; j < board[0].length; j++){
                char rc = board[i][j];
                if((rc != '.' && (rc > '9' || rc < '1')) || rset.contains(rc)) return false;
                if(rc != '.') rset.add(rc);
                char cc = board[j][i];
                if((cc != '.' && (cc > '9' || cc < '1')) || cset.contains(cc)) return false;
                if(cc != '.') cset.add(cc);
            }
        }
        for(int i = 0; i < 3; i++){
            for(int j = 0; j < 3; j++){
                if(!helper(i, j, board)) return false;
            }
        }
        return true;
    }
    public boolean helper(int i, int j, char[][] board){
        Set<Character> set = new HashSet<Character>();
        for(int k = 3*i; k < 3*i+3; k++){
            for(int l = 3*j; l <3*j+3; l++){
                char c = board[k][l];
                if((c != '.' &&(c > '9' || c < '1')) || set.contains(c)) return false;
                if(c != '.') set.add(c);
            }
        }
        return true;
    }

```




<br>

<br>


###37 Sudoku Solver

>Write a program to solve a Sudoku puzzle by filling the empty cells.

>Empty cells are indicated by the character '.'.

>You may assume that there will be only one unique solution.


**Idea**: we solve the sudoku line by line, every time we fill in a filed, we check if is valid. We can use the method in * [36 Valid Sudoku](#36-valid-sudoku) to check the sudoku




**Java code**:

```java

    public void solveSudoku(char[][] board) {
        if(board == null || board.length != 9 | board[0].length != 9) return;
        solverHelper(board, 0, 0);
    }
    
    public boolean solverHelper(char[][] board, int i, int j){
        if(j == 9) return solverHelper(board, i+1, 0);
        if(i == 9) return true;
        if(board[i][j] == '.'){
            for(int k = 1; k <=9; k++){
                board[i][j] = (char)(k+'0');
                if(isValid(board, i, j)){
                   if(solverHelper(board, i, j+1)) return true;
                }
            }
            board[i][j] = '.';
        }else return  solverHelper(board, i, j+1);
        return false;
    }
    public boolean isValid(char[][] board, int i, int j) {
		 for(int k = 0; k < 9; k++){
			 if(k != j && board[i][k] == board[i][j]) return false;
			 if(k != i && board[i][j] == board[k][j]) return false;
		 }
		 
		 for(int r = i/3 *3; r < i/3 *3 +3; r++){
			 for(int c = j/3 * 3; c < j/3 * 3+3; c++){
				 if((r != i || c != j) && board[r][c] == board[i][j]) return false;
			 }
		 }
		 return true;
	 }
	 
```






<br>

<br>





###38 Count and Say
>The count-and-say sequence is the sequence of integers beginning as follows:

>1, 11, 21, 1211, 111221, ...

>1 is read off as "one 1" or 11.

>11 is read off as "two 1s" or 21.

>21 is read off as "one 2, then one 1" or 1211.

>Given an integer n, generate the nth sequence.

>Note: The sequence of integers will be represented as a string.


**Idea**: Calculate the string based on the previous one. Each time count the repeating times of each character. It's similar to compress string based on its repeating times.

**Java code**:


```java

    public String countAndSay(int n) {
        if(n <= 0) return "";
        if(n == 1) return "1";
        StringBuilder res = new StringBuilder();
        res.append(1);
        for(int i = 2; i <= n; i++){
            String temp = res.toString();
            StringBuilder cur = new StringBuilder();
            char pre = temp.charAt(0);
            int count = 1;
            for(int j = 1; j < temp.length(); j++){
                if(pre != temp.charAt(j)){
                    cur.append(count);
                    cur.append(pre);
                    pre = temp.charAt(j);
                    count = 1;
                }else count++;
            }
            cur.append(count);
            cur.append(pre);
            res = cur;
        }
        return res.toString();
    }


```

<br>

<br>

###39 Combination Sum
>Given a set of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.

> **The same repeated number may be chosen from C unlimited number of times.**

>Note:

>All numbers (including target) will be positive integers.

>Elements in a combination (a1, a2, … , ak) must be in non-descending order. (ie, a1 ≤ a2 ≤ … ≤ ak).

>The solution set must not contain duplicate combinations.

>For example, given candidate set 2,3,6,7 and target 7, 

<pre>

A solution set is: 
[7] 
[2, 2, 3] 

</pre>


**Idea**: We need to add combination in non-descending order, thus its better to first sort candidates. Off course, we can handle the duplicates and sequence in latter if we don't sort it. Then we add element to list, minus the current and go to the next recursion.


**Java code**:


```java

public List<List<Integer>> combinationSum(int[] candidates, int target) {
    List<List<Integer>> res = new ArrayList<List<Integer>>();
    if(candidates == null || candidates.length == 0) {
        return res;
    }
    Arrays.sort(candidates);
    combinationSum(candidates, target, res, new ArrayList<Integer>(), 0);
    return res;
}
public void combinationSum(int[] candidates, int target, List<List<Integer>> res, List<Integer> cur, int start){
    if (target < 0) {
        return;
    }
    if (target == 0) {
        res.add(new ArrayList<Integer>(cur));
        return;
    }
    for (int i = start; i < candidates.length; i++) {
        cur.add(candidates[i]);
        combinationSum(candidates, target-candidates[i], res, cur, i);
        cur.remove(cur.size()-1);
    }
}

```


<br>

<br>


###40 Combination Sum II

>Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.

>**Each number in C may only be used once in the combination.**

>Note:

>All numbers (including target) will be positive integers.

>Elements in a combination (a1, a2, … , ak) must be in non-descending order. (ie, a1 ≤ a2 ≤ … ≤ ak).

<pre>

The solution set must not contain duplicate combinations.
For example, given candidate set 10,1,2,7,6,1,5 and target 8, 
A solution set is: 
[1, 7] 
[1, 2, 5] 
[2, 6] 
[1, 1, 6] 

</pre>



**Idea**: The difference with [39 Combination Sum](#39-combination-Sum)] is that in ths problem we can only use each number once. So when go to next recursion, the start position should change to i+1, so that it will add itself again. 

**Java code**:

```java
    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        List<List<Integer>> res = new ArrayList<List<Integer>>();
        if(candidates == null || candidates.length == 0) {
            return res;
        }
        Arrays.sort(candidates);
        combinationSum(candidates, target, res, new ArrayList<Integer>(), 0);
        return res;
    }
    public void combinationSum(int[] candidates, int target, List<List<Integer>> res, List<Integer> cur, int start){
        if (target < 0) {
            return;
        }
        if (target == 0) {
            res.add(new ArrayList<Integer>(cur));
            return;
        }
        for (int i = start; i < candidates.length; i++) {
            if (i > start && candidates[i] == candidates[i - 1]) {
                continue;
            }
            cur.add(candidates[i]);
            combinationSum(candidates, target-candidates[i], res, cur, i + 1);
            cur.remove(cur.size()-1);
        }
    }

```

<br>

<br>


###41 First Missing Positive

>Given an unsorted integer array, find the first missing positive integer.

>For example,

>Given [1,2,0] return 3,

>and [3,4,-1,1] return 2.

>Your algorithm should run in O(n) time and uses constant space.

<br>

**Idea**: This problem has the same idea with the counting sort problem. If no element is missing, then A[A[i]-1] = A[i]. Thus, we just need to put the element to its original place and have another pass to check the miss element.
 


**Java code**:


```java

    public int firstMissingPositive(int[] A) {
        if(A == null || A.length == 0) return 1;
        for(int i = 0; i < A.length; i++){
            if(A[i] > 0 && A[i] - 1 < A.length && A[A[i]-1] != A[i]){
                int temp = A[A[i]-1];
                A[A[i]-1] = A[i];
                A[i] = temp;
                i--;
            } 
        }
        for(int i = 0; i < A.length; i++){
            if(A[i] != i+1) return i+1;
        }
        return A.length+1;
    }

```


<br>
<br>


###42 Trapping Rain Water

>Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.

For example, 
Given [0,1,0,2,1,0,1,3,2,1,2,1], return 6.

**Idea**: 

- 1) Solution1: Like [11 Container with Most Water](#11-container-with-most-water), we record two pointers, l and r, min = min(A[l], A[r]), if A[l] < A[r], we move right, and add water if A[l] < min; similarly, if A[l] > A[r], we move r left, and if A[r] < min, we add water. When l >= r, we get the total volumn. 


```java

 public int trap(int[] A) {
    if(A == null || A.length == 0) return 0;
    int res = 0;
    int l = 0;
    int r = A.length - 1;
    while(l < r){
        int min = Math.min(A[l], A[r]);
        if(A[l] < A[r]){
            l++;
            while(l < r && A[l] < min){
                res += min - A[l++];
            }
        }else{
            r--;
            while(l < r && A[r] < min){
                res += min - A[r--];
            }
        }
    }
    return res;
  }

```

<br>

- 2)solution 2 : we traverse the array two times, left to right and right to left. Then we can get the min(max height on the left of A[i], max height on the right of A[i]). So add the capacity of each bar, we get the total capacity.

```java

	  public int trap(int[] A) {
		if(A == null || A.length == 0) return 0;
		int[] left = new int[A.length];
		int max = 0;
		for(int i = 0; i < A.length; i++){
		    left[i] = max;
		    max = Math.max(max, A[i]);
		}
		
		int res = 0;
		max = 0;
		for(int i = A.length-1; i>=0; i--){
		    res += Math.min(max, left[i]) - A[i] > 0 ? (Math.min(max, left[i]) - A[i]): 0 ;
		    max = Math.max(max, A[i]);
		}
		return res;
	}

```




<br>
<br>




###43 Multiply Strings


>Given two numbers represented as strings, return multiplication of the numbers as a string.

>Note: The numbers can be arbitrarily large and are non-negative.

<br>

**Idea**: If length is n and m, result's length is n+m or n+m-1, result of index i = 0 * i + 1 * i-1 ..... i * 0


**Attention**: We should not add the leftmost zero.



**Java code**:

```java

    public String multiply(String num1, String num2) {
        if(num1 == null || num2 == null) return null;
        if(num1.equals("0") || num2.equals("0")) return "0";
        StringBuilder res = new StringBuilder();
        int cur = 0;
        for(int i= num1.length() + num2.length() -1;i >=0; i--){
            for(int j = Math.min(i-1, num1.length()-1);j >= 0; j--){
                if(j < num1.length() && ((i-j-1) < num2.length())) {
                    cur += (int)(num1.charAt(j) - '0') * (int)(num2.charAt(i-j-1) - '0');
                }
            }
            if(i != 0 || cur > 0) res.insert(0, cur % 10);
            cur = cur / 10;
        }
        return res.toString();
    }


```

<br>
<br>

###44 Wildcard Matching

> Implement wildcard pattern matching with support for '?' and '*'.

<pre>

'?' Matches any single character.
'*' Matches any sequence of characters (including the empty sequence).

The matching should cover the entire input string (not partial).

The function prototype should be:
bool isMatch(const char *s, const char *p)

Some examples:
isMatch("aa","a") → false
isMatch("aa","aa") → true
isMatch("aaa","aa") → false
isMatch("aa", "*") → true
isMatch("aa", "a*") → true
isMatch("ab", "?*") → true
isMatch("aab", "c*a*b") → false

</pre>

**Idea**: This problem is similar with [10 Regular Expression Matching](#10-regular-expression-matching). The difference is that '.' is replace with '?'. And '\*' can match any sequence including empty. We can use the method in [10 Regular Expression Matching](#10-regular-expression-matching). Or we use two pointers to record the return place in s and p when encounter a '\*'

**Iterative Code**:

```java
	 public boolean isMatch(String s, String p) {
   	    if(s == null && p == null || p.equals("*")) return true;
		int i = 0, j = 0, savei = -1, savej = -1;
		while(i < s.length()){
		    if(j < p.length() && (s.charAt(i) == p.charAt(j) || p.charAt(j) == '?')){
		        i++;
		        j++;
		    }else if(j < p.length() && p.charAt(j) == '*'){
		        savei = i;
		        savej = j++;
		    }else if(savej != -1){
		        j = savej + 1;
		        i = ++savei;
		    }else return false;
		}
		while(j < p.length() && p.charAt(j) == '*') j++;
		return j == p.length();
	}

```


**Recursion**: it might exceed the time limit

```java
		
    public boolean isMatch2(String s, String p) {
        if((s == null && p == null) || p.equals("*")) return true;
        return helper(s, p, 0, 0);
    }
    
    public boolean helper(String s, String p, int i, int j){
        if(j == p.length()) return i == s.length();
        if(p.charAt(j) != '*'){
            if(i < s.length() && (s.charAt(i) == p.charAt(j) || p.charAt(j) == '?')) return helper(s, p, i+1, j+1);
            else return false;
        }else{
            while(i < s.length()){
                if(helper(s, p, i++, j+1)) return true;
            }
            return helper(s, p, i, j+1);
        }
    }

```



<br>
<br>

###45 Jump Game II

>Given an array of non-negative integers, you are initially positioned at the first index of the array.Each element in the array represents your maximum jump length at that position.

>Your goal is to reach the last index in the minimum number of jumps.

<pre>

For example:
Given array A = [2,3,1,1,4]

The minimum number of jumps to reach the last index is 2. (Jump 1 step from index 0 to 1, then 3 steps to the last index.)

</pre>
<br>

**Idea**: The basic idea is same with Jump Game. Difference is that in this problem we need to calculate the optimal steps. How can We get the minimum steps? The idea is that we only increase steps when we found that the **current position i is greater than the previous step max**, which means that if you want to reach further, you need to increase steps.  


**Java code**:

```java
    public int jump(int[] A) {
        if(A == null || A.length <= 1) return 0;
        int max = 0;
        int canReach = 0;
        int res = 0;
        for(int i = 0; i < A.length; i++){
            if(i > max) return -1;  // check if you can reach to the end.
            if(i > canReach){
                res++;
                canReach = max;
            }
            max = Math.max(max, i + A[i]);
        }
        return res;
    }

```

<br>
<br>


###46 Permutations

>Given a collection of numbers, return all possible permutations.

**No duplicate number in collection**

<pre>
For example,
[1,2,3] have the following permutations:
[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], and [3,2,1].
</pre>

**Idea**:

Since there is no duplicate, we can add element one by one. For example:

1,

1 2, 2 1

3 1 2, 1 3 2, 1 2 3, 3 2 1, 2 3 1, 2 1 3


**Jave code**:



*Iterative*:


```java
    public List<List<Integer>> permute(int[] num) {
        List<List<Integer>> res = new ArrayList<List<Integer>>();
        if (num == null || num.length == 0) {
            return res;
        }
        List<Integer> first = new ArrayList<Integer>();
        first.add(num[0]);
        res.add(first);
        for (int i = 1; i < num.length; i++) {
            List<List<Integer>> cur = new ArrayList<List<Integer>>();
            for (List<Integer> l : res) {
                for (int j = 0; j <= l.size(); j++) {
                    List<Integer> temp = new ArrayList<Integer>(l);
                    temp.add(j, num[i]);
                    cur.add(temp);
                }
            }
            res = cur;
        }
        return res;
    } 

```

*recursion*:

```java
    public List<List<Integer>> permute(int[] num) {
        List<List<Integer>> list = new ArrayList<List<Integer>>();
        if (num == null || num.length == 0) {
            return list;
        }
        return permute(list, num, 0);
    }
    
    public List<List<Integer>> permute(List<List<Integer>> list, int[] num, int i){
        if (i == num.length) {
            List<Integer> arr = new ArrayList<Integer>();
            list.add(arr);
            return list;
        }
        
        list = permute(list, num, i+1);
        List<List<Integer>> current = new ArrayList<List<Integer>>();
        for (List<Integer> l : list) {
            if (l.size() == 0) {
                List<Integer> arr = new ArrayList<Integer>();
                arr.add(num[i]);
                current.add(arr);
            } else {
                for (int j = 0; j <= l.size(); j++) {
                    List<Integer> arr = new ArrayList<Integer>(l);
                    arr.add(j, num[i]);
                    current.add(arr);
                }
            }
        }
        list = new ArrayList<List<Integer>>(current);
        return list;
    }

```

<br>


<br>


**Another way**: use swap

```java
  public List<String> permutations(String set) {
    List<String> res = new ArrayList<String>();
    if (set == null) {
      return res;
    }
    permutations(res, 0, set.toCharArray());
    return res;
  }
  
  public void permutations(List<String> res, int index, char[] arr) {
    if (index == arr.length) {
      String s = new String(arr);
      res.add(s);
      return;
    }
    for (int i = index; i < arr.length; i++) {
      swap(arr, i, index);
      permutations(res, index + 1, arr);
      swap(arr, i, index);
    }
  }
  
  public void swap(char[] arr, int i, int j) {
    char temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
  }
```
<br>
<br>


###47 Permutations II

>Given a collection of numbers that might **contain duplicates**, return all possible unique permutations.

For example,
[1,1,2] have the following unique permutations:
[1,1,2], [1,2,1], and [2,1,1].
<br>

**Idea**: Since the collection has duplicates, thus each time when we add permutation, we need to consider if it already exists. 

In the following code, the first code snippet use list.contains to check the duplicates. The second code snippet use set to avoid add dupilcates.

These two are accepted, the second one has better time complexity.


**Java code**:

**M1**:

```java

    public List<List<Integer>> permuteUnique(int[] num) {
        List<List<Integer>> res = new ArrayList<List<Integer>>();
        if (num == null || num.length == 0) {
            return res;
        }
        List<Integer> first = new ArrayList<Integer>();
        first.add(num[0]);
        res.add(first);
        Set<String> set = new HashSet<String>();
        for (int i = 1; i < num.length; i++) {
            List<List<Integer>> cur = new ArrayList<List<Integer>>();
            for (List<Integer> l : res) {
                for(int j = 0; j <= l.size(); j++) {
                    List<Integer> temp = new ArrayList<Integer>(l);
                    temp.add(j, num[i]);
                    if(set.add(temp.toString())) {
                        cur.add(temp);
                    }
                }
            }
            res = cur;
        }
        return res;
    }

```
<br>

**M2: Use set, recursion**:


```java

    public List<List<Integer>> permuteUnique(int[] num) {
        List<List<Integer>> list = new ArrayList<List<Integer>>();
        if (num == null || num.length == 0) {
            return list;
        }
        return permuteUnique(list, num, 0);
    }
    
    public List<List<Integer>> permuteUnique(List<List<Integer>> list, int[] num, int i){
        if (i == num.length) {
            List<Integer> arr = new ArrayList<Integer>();
            list.add(arr);
            return list;
        }
        
        list = permuteUnique(list, num, i+1);
        Set<List<Integer>> current = new HashSet<List<Integer>>();
        for (List<Integer> l : list) {
            if(l.size() == 0){
                List<Integer> arr = new ArrayList<Integer>();
                arr.add(num[i]);
                current.add(arr);
            } else {
                for (int j = 0; j <= l.size(); j++) {
                    List<Integer> arr = new ArrayList<Integer>(l);
                    arr.add(j, num[i]);
                    current.add(arr);
                }
            }
        }
        list = new ArrayList<List<Integer>>(current);
        return list;
    }

```

<br>

**M3**: use swap, tle on leetcode

```java
  public List<String> permutations(String set) {
    List<String> res = new ArrayList<String>();
    if (set == null) {
      return res;
    }
    permutations(res, 0, set.toCharArray());
    return res;
  }
  
  public void permutations(List<String> res, int index, char[] arr) {
    if (index == arr.length) {
      String s = new String(arr);
      res.add(s);
      return;
    }
    Set<Character> myset = new HashSet<Character>();
    for (int i = index; i < arr.length; i++) {
      if (!myset.contains(arr[i])) {
        myset.add(arr[i]);
        swap(arr, i, index);
        permutations(res, index + 1, arr);
        swap(arr, i, index);
      }
    }
  }
  
  public void swap(char[] arr, int i, int j) {
    char temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
  }
```

<br>

**M4: use next permutation**: tle on leetcode

```java
    public List<List<Integer>> permuteUnique(int[] num) {
        List<List<Integer>> list = new ArrayList<List<Integer>>();
        if (num == null || num.length == 0) {
            return list;
        }
        Arrays.sort(num);
        list.add(IntStream.of(num).boxed().collect(Collectors.toList()));
        while (nextPermutation(num)) {
            list.add(IntStream.of(num).boxed().collect(Collectors.toList()));
        }
        return list;
    }
    
    private boolean nextPermutation(int[] num) {
        if(num == null || num.length <= 1) {
            return false;
        }
        int i = num.length - 2;
        while (i >= 0 && num[i] >= num[i+1]) {
            i--;
        }
        int index1 = i;
        if (i == -1) {
            return false;
        }
        i = num.length - 1;
        while (i >= 0 && num[i] <= num[index1]) {
            i--;
        }
        swap(num, index1, i);
        reverse(num, index1 + 1);
        return true;
    }
    
    private void reverse(int[] num, int i) {
        for (int j = i; j < (num.length - i) / 2 + i; j++) {
            swap(num, j, num.length + i - j - 1);
        }
    }
    
    private void swap(int[] num, int i, int j) {
        int temp = num[i];
        num[i] = num[j];
        num[j] = temp;
    }

```


<br>
<br>


###48 Rotate Image


>You are given an n x n 2D matrix representing an image.

>Rotate the image by 90 degrees (clockwise).

>Follow up:
>Could you do this in-place?

**Idea**:The easiest way to solve this problem is draw a matrix and rotate it by 90 degrees. Then you'll find the following pattarn.

-   matrix[i][j] = matrix[n-j-1][i];
-   matrix[n-j-1][i] = matrix[n-i-1][n-j-1]
-   matrix[n-i-1][n-j-1] = matrix[j][n-i-1]; 
-   matrix[j][n-i-1] = matrix[i][j]

**Attention**: I made a mistake at the first time, matrix[i][j] should equal to matrix[n-j-1][i] other than matrix[n-j][i]. The other three should follow the same way.

**Java code**:

```java

    public void rotate(int[][] matrix) {
        if(matrix == null || matrix.length == 0 || matrix[0].length == 0) return;
        int n = matrix.length;
        for(int i = 0; i < n/2; i++){
            for(int j = i; j < n - i - 1; j++){
                int temp = matrix[i][j];
                matrix[i][j] = matrix[n-j-1][i];
                matrix[n-j-1][i] = matrix[n-i-1][n-j-1];
                matrix[n-i-1][n-j-1] = matrix[j][n-i-1];
                matrix[j][n-i-1] = temp;
            }
        }
    }

```

<br>
<br>


###49 Anagrams

>Given an array of strings, return all groups of strings that are anagrams.

>Note: All inputs will be in lower-case.


**Ideas**: To solve this problem, we can divide it into two parts

- 1) how to check if two strings are anagrams?

	 we can sort them and check if they are equal

- 2) for a certain string, how to decide if it has anagram in the strs?

	 Use hashmap.

**Time complexity**:

For the first solution use sort + hashmap, suppose string[] length is N, maximum string length is M, then the overall time complexity is O(N * MlgM)

For the second solution, the time complexity is O(N * M), but too many multiplications. 

**Java code**:

```java

    public List<String> anagrams(String[] strs) {
        List<String> res = new ArrayList<String>();
        if(strs == null || strs.length == 0) {
            return res;
        }
        Map<String, List<String>> map = new HashMap<String, List<String>>();
        for (String s : strs){
            char[] arr = s.toCharArray();
            Arrays.sort(arr);
            String sorted = new String(arr);
            if (map.containsKey(sorted)) {
                map.get(sorted).add(s);
            } else {
                List<String> list = new ArrayList<String>();
                list.add(s);
                map.put(sorted, list);
            }
        }
        for (Map.Entry<String, List<String>> e : map.entrySet()) {
            if (e.getValue().size() > 1) {
                res.addAll(e.getValue());
            }
        }
        return res;
    }

```

Here is another similar solution using hashmap, the difference is that it does not use Arrays.sort to sort the strings. It uses some primes numbers to calculate the hash value. This solution is from leetcode discussion. Even though it does not improve the time complexity too much, it's a pretty good idea. 

```java
    public List<String> anagrams(String[] strs) {
        int[] PRIMES = new int[]{2, 3, 5, 7, 11 ,13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 107};
        List<String> list = new LinkedList<>();
        Map<Integer, List<String>> mapString = new HashMap<>();
        int result = -1;
        for (int i = 0; i < strs.length; i++) {
            int mapping = 1;
            for (int j = 0, max = strs[i].length(); j < max; j++) {
                mapping *= PRIMES[strs[i].charAt(j) - 'a'];
            }
            List<String> strings = mapString.get(mapping);
            if (strings == null) {
                strings = new LinkedList<>();
                mapString.put(mapping, strings);
            }
            strings.add(strs[i]);
        }
        for (List<String> mapList : mapString.values()) {
            if (mapList.size() > 1) {
                list.addAll(mapList);
            }
        }
        return list;
    }

```


<br>
<br>

###50 Pow

>Implement pow(x, n).

**Idea**: Dichotomy and calculate recursively. 
```java

    public double myPow(double x, int n) {
        if (n == 0) {
            return 1;
        }
        double result = myPow(x, n/2);
        if (n % 2 == 0) {
            return result * result;
        } else if (n % 2 == 1) {
             return result * result * x;
        } else {
            return result * result / x;
        }
    }
```



<br>

<br>

###51 N Queens


>The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.


>Given an integer n, return all distinct solutions to the n-queens puzzle.

>Each solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space respectively.

<pre>
For example,
There exist two distinct solutions to the 4-queens puzzle:

[
 [".Q..",  // Solution 1
  "...Q",
  "Q...",
  "..Q."],

 ["..Q.",  // Solution 2
  "Q...",
  "...Q",
  ".Q.."]
]

</pre>

**Requirement**: For n queen problem, we can not put queens in the same row or same column or diagonal.

**Idea**: We can use the queen one by one, each one correspond to one row. To find all solutions, we need to try each column on a row. When we finish the last row, we find a solution. Use recursions inside the loops we can find all solutions.



**Java code**:


```java

    public List<String[]> solveNQueens(int n) {
        List<String[]> res = new ArrayList<String[]>();
        if(n <= 0) return res;
        solve(0,n,new int[n],res);
        return res;
    }
    
    public void solve(int r, int n, int[] cols, List<String[]> list){
        if(r == n){
            String[] strs = new String[n];
            for(int i = 0; i < n; i++){
                StringBuilder s = new StringBuilder();
                for(int j = 0; j < n; j++){
                    if(j == cols[i]) s.append("Q");
                    else s.append(".");
                }
                strs[i] = s.toString();
            }
            list.add(strs);
            return;
        }
        for(int i = 0; i < n; i++){
            if(isValid(r, i, cols)){
                cols[r] = i;
                solve(r+1, n, cols, list);
            }
        }  
        
    }
    
    public boolean isValid(int r, int c, int[] cols){
        for(int i = 0; i < r; i++){
            if(c == cols[i] || r - i == Math.abs(cols[i] - c)) return false;
        }
        return true;
    }

```


<br>

<br>


###52 N Queens II

>Follow up for N-Queens problem.

>Now, instead outputting board configurations, return the total number of distinct solutions.

**Idea**: Same with n queen, difference is that we don't need to output the result, we just need to calculate the total number of solutions.


**Java code**:

```java

    public int totalNQueens(int n) {
        if(n <= 0) return 0;
        int[] res = new int[1];
        solve(0,n,new int[n],res);
        return res[0];
    }
    
    public void solve(int r, int n, int[] cols, int[] res){
        if(r == n){
          res[0]++;
        }
        for(int i = 0; i < n; i++){
            if(isValid(r, i, cols)){
                cols[r] = i;
                solve(r+1, n, cols, res);
            }
        }  
        
    }
    
	public boolean isValid(int r, int c, int[] cols){
	    for(int i = 0; i < r; i++){
	        if(c == cols[i] || r - i == Math.abs(cols[i] - c)) return false;
	    }
	    return true;
	}

```


<br>
<br>

###53 Maximum Subarray

>Find the contiguous subarray within an array **(containing at least one number)** which has the largest sum.

For example, given the array [−2,1,−3,4,−1,2,1,−5,4],
the contiguous subarray [4,−1,2,1] has the largest sum = 6.

**Idea**:
- 1) solution1: use dp. Store a local max and global max. Local max represents the max subarray which includes the element A[i]. Thus Local Max = max(local+A[i], A[i]). global = max(global, local).

**Attention**: Because the maxsubarray contains at least one number, thus the max sum might be negative when the array only contains one negative numbers or when all the numbers are negative.



```java

	 public int maxSubArray(int[] A) {
		 if(A == null || A.length == 0) return 0;
		 int local = A[0];
		 int global = A[0];
		 for(int i = 1; i < A.length; i++){
			 local = Math.max(A[i], local+A[i]);
			 global = Math.max(local, global);
		 }
		 return global;
	 }

```

<br>

- 2) solution 2: One pass. When encounter a negative number, record the current max. when sum + A[i] < 0 && A[i] > 0, change the local max to A[i]. 

```java

    public int maxSubArray1(int[] A) {
        if(A == null || A.length == 0) return 0;
        int max = Integer.MIN_VALUE;
        int temp = A[0];
        for(int i = 1; i < A.length; i++){
        	if(temp < 0){
        		max = Math.max(max,temp);
        		temp = A[i];
        	}else{
        		if(A[i] > 0) temp += A[i];
        		else if(temp + A[i] < 0){
        			max = Math.max(max,temp);
            		temp = A[i];
        		}else{
        			max = Math.max(max,temp);
            		temp += A[i];
        		}
        	}
        }
        max = Math.max(max,temp);
        return max;
    }

``` 


<br>
<br>


###54 Spiral Matrix

>Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.

<pre>
For example,
Given the following matrix:

[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]

</pre>

**Idea**:Don't figure out any good solution yet. Just add the element in spiral order one by one.

**Attention**: The row is not necessarily equal to column, thus make sure to check if they are equal. Also, in the following method, I loop Math.min(row, col) / 2 times. what will happen if  Math.min(row, col) is odd? 


**Java code**:


```java

    public List<Integer> spiralOrder(int[][] matrix) {
        List<Integer> res = new ArrayList<Integer>();
        if(matrix == null || matrix.length == 0 || matrix[0].length == 0) 
            return res;
        int row = matrix.length;
        int col = matrix[0].length;
        int loops = (Math.min(row, col)) /2;
        for(int i = 0; i < loops; i++){
            for(int j = i; j < col - i; j++){
                res.add(matrix[i][j]);
            }
            for(int j = i+1; j < row -i; j++){
                res.add(matrix[j][col-i-1]);
            }
            for(int j = col-i-2; j >= i; j--){
                res.add(matrix[row-i-1][j]);
            }
            for(int j = row - (i+2); j >= i+1; j--){
                res.add(matrix[j][i]);
            }
        }
        if(row >= col && col % 2 == 1){
            for(int i = col/2; i < row - col/2; i++){
                res.add(matrix[i][col/2]);
            }
        }
        if(row < col && row % 2 == 1){
            for(int i = row/2; i < col - row/2; i++){
                res.add(matrix[row/2][i]);
            }
        }
         return res;
    }

```

<br>

**Another more straightforward way**: M * N iterarive

```java
  public List<Integer> spiral(int[][] matrix) {
    List<Integer> res = new ArrayList<Integer>();
    if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
      return res;
    }
    int left = 0;
    int right = matrix[0].length - 1;
    int top = 0;
    int bottom = matrix.length - 1;
    while (left < right && top < bottom) {
      for (int i = left; i <= right; i++) {
        res.add(matrix[top][i]);
      }
      for (int i = top + 1; i <= bottom; i++) {
        res.add(matrix[i][right]);
      }
      for (int i = right - 1; i >= left; i--) {
        res.add(matrix[bottom][i]);
      }
      for (int i = bottom - 1; i >= top + 1; i--) {
        res.add(matrix[i][left]);
      }
      left++;
      right--;
      top++;
      bottom--;
    }
    if (left == right && top <= bottom) {
      for (int i = top; i <= bottom; i++) {
        res.add(matrix[i][left]);
      }
    } else if (top == bottom && left <= right) {
      for (int i = left; i <= right; i++) {
        res.add(matrix[top][i]);
      }
    }
    return res;
  }
```
<br>

**Recursive solution**: handle N* N 

```java
  public int[] spiral(int[][] matrix) {
    int[] res = new int[matrix.length * matrix.length];
    spiral(res, matrix, 0, matrix.length, 0);
    return res;
  }
  
  public void spiral(int[] res, int[][] matrix, int offset, int size, int count) {
    if (size == 0) {
      return;
    }
    if (size <= 1) {
      res[count++] = matrix[offset][offset];
      return;
    }
    for (int i = 0; i < size - 1; i++) {
      res[count++] = matrix[offset][i + offset];
    }
    for (int i = 0; i < size - 1; i++) {
      res[count++] = matrix[offset + i][offset + size - 1];
    }
    for (int i = size - 1; i >= 1; i--) {
      res[count++] = matrix[offset + size - 1][offset + i];
    }
    for (int i = size - 1; i >= 1; i--) {
      res[count++] = matrix[offset + i][offset];
    }
    spiral(res, matrix, offset + 1, size - 2, count);
  }
```

<br>
<br>


###55 Jump Game

> Given an array of non-negative integers, you are initially positioned at the first index of the array.

>Each element in the array represents your maximum jump length at that position.

>Determine if you are able to reach the last index.

<pre>
For example:
A = [2,3,1,1,4], return true.

A = [3,2,1,0,4], return false.
</pre>

**Idea**: We need to figure out the max-position we can reach. If max >= A.length-1, then we can reach to the end. Note that we need to check if at certain step if index i > max, then we can not reach to the end. Because in some cases the A[i] might be 0, thus we might not able to go to the next step.


**Java code**:


```java


    public boolean canJump(int[] A) {
        if(A == null || A.length <= 1) return true;
        int max = A[0];
        for(int i = 0; i < A.length && i <= max; i++){
            max = Math.max(max, i+A[i]);
            if(max >= A.length-1) return true;
        }
        return max >= A.length-1;
    }

```

<br>
<br>


###56 Merge Intervals

> Given a collection of intervals, merge all overlapping intervals.

<pre>
For example,
Given [1,3],[2,6],[8,10],[15,18],
return [1,6],[8,10],[15,18].
</pre>


**Idea**: First sort then merge.

- 1) For sort, we can use Collections.sort(list, comparator). And when interval1.start == interval2.start, we compare interval1.end and interval2.end.
Otherwise, we compare interval1.start and interval2.start
- 2) For merge, if current.start > last.end, just add interval.
Otherwise, we need to compare the end of two intervals. If current.end > last.end, we need to update last.end. 


**Java code**:

```java

    public List<Interval> merge(List<Interval> intervals) {
        if(intervals == null || intervals.size() == 0) return intervals;
        List<Interval> res = new ArrayList<Interval>();
        Comparator<Interval> comp = new Comparator<Interval>(){
          public int compare(Interval arg1, Interval arg2){
              if(arg1.start == arg2.start) return arg1.end - arg2.end;
              else return arg1.start - arg2.start;
          }
        };
        Collections.sort(intervals, comp);
        res.add(intervals.get(0));
        for(int i = 1; i < intervals.size(); i++){
            Interval cur = intervals.get(i);
            if(cur.start > res.get(res.size() -1).end) 
                res.add(cur);
            else {
                if(cur.end > res.get(res.size() -1).end)
                    res.get(res.size() -1).end = cur.end;
            }
        }
        return res;
    }
    
```

<br>

<br>


###57 Insert Interval

>Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).

>You may assume that the intervals were initially sorted according to their start times.

>Example 1:


>Given intervals [1,3],[6,9], insert and merge [2,5] in as [1,5],[6,9].


>Example 2:

>Given [1,2],[3,5],[6,7],[8,10],[12,16], insert and merge [4,9] in as [1,2],[3,10],[12,16].

>This is because the new interval [4,9] overlaps with [3,5],[6,7],[8,10].


**Idea**:

- solution 1 : There are three possible relations between two intervals. Consider interval i1 and interval i2,

	* case 1: i1.end < i2.start
	
	* case 2:  i1.start > i2.end
	
	* case 3: i1 includes i2, or i2 includes i1, or i1.start < i2.start and i1.end < i2.end, or i1.start > i2.start and i1.end > i2.end
	
	In case 1: we just need to add i1 to result,
	In case 2: we add i2 to result, and change newInterval to i1,
	In case 3: We might need to update the start or end of the newInterval.
	
	
- solution 2: First find the place to insert the newInterval, then do merge intervals for the remain intervals. How to find the place to insert the newInterval? If we find a interval that its end is >= newInterval.start, then it is the place to insert the newInterval. After insert, we merge the intervals. 



**java code**:


*Solution 1*:

```java

    public List<Interval> insert(List<Interval> intervals, Interval newInterval) {
        List<Interval> res = new ArrayList<Interval>();
        for(Interval interval : intervals){
            if(interval.end < newInterval.start){
                res.add(interval);
            }else if(interval.start > newInterval.end){
                res.add(newInterval);
                newInterval = interval;
            }else if(newInterval.end >= interval.start || newInterval.start <= interval.end ){
                newInterval.start = Math.min(interval.start, newInterval.start);
                newInterval.end = Math.max(interval.end, newInterval.end);
            }
        }
        res.add(newInterval);
        return res;
    }
    

```



*Solution 2*: 

```java

    public List<Interval> insert(List<Interval> intervals, Interval newInterval) {
        List<Interval> res = new ArrayList<Interval>();
        int i = 0;
        for(; i < intervals.size(); i++){
            Interval cur = intervals.get(i);
            if(cur.end >= newInterval.start){
                break;
            }
            res.add(cur);
        }
        
        res.add(newInterval);
        
        for(; i < intervals.size(); i++){
            Interval cur = intervals.get(i);
            Interval last = res.get(res.size()-1);
            if(cur.start > last.end){
                res.add(cur);
            }else{
                last.start = Math.min(last.start, cur.start);
                last.end = Math.max(last.end, cur.end);
            }
        }
        return res;
    }

```

<br>
<br>

###58 Length of Last Word


>Given a string s consists of upper/lower-case alphabets and empty space characters ' ', return the length of last word in the string.

>If the last word does not exist, return 0.

>Note: A word is defined as a character sequence consists of non-space characters only.

>For example, 

>Given s = "Hello World",

>return 5.

**Idea**:

- solution1 : split the string by spaces, then return the length of the last word. Be careful, before you split, you should first trim the string to remove the front and back spaces in the string. Otherwise, you might get the wrong answer.

- solution2 : trim the spaces, then find from the end of the string, until we find the first space, then we can return the length.




**Java code**:


*Method 1*:

```java


    public int lengthOfLastWord(String s) {
        if(s == null || s.length() == 0) return 0;
        s = s.trim();
        String[] words = s.split("\\s+");
        return words[words.length -1].length();
    }


```



*Method 2*:


```java

    
	public int lengthOfLastWord1(String s) {
		if(s == null || s.length() == 0) return 0;
    	s = s.trim();
    	int len = 0;
    	for(int i = s.length()-1; i>=0; i--){
    		if(s.charAt(i) != ' '){
    			len++;
    		}else break;
    	}
    	return len;
	}


```


<br>

**Related**: reverse words in a sentence


```java
  public String reverseWords(String input) {
    if (input == null || input.length() == 0) {
      return input;
    }
    input = input.trim();
    String[] arr = input.split("\\s+");
    StringBuilder res = new StringBuilder();
    for (int i = arr.length - 1; i >= 0; i--) {
      res.append(arr[i]);
      res.append(" ");
    }
    return res.toString().trim();
  }

```




<br>
<br>

###59 Spiral Matrix II

>Given an integer n, generate a square matrix filled with elements from 1 to n2 in spiral order.

<pre>
For example,
Given n = 3,

You should return the following matrix:
[
 [ 1, 2, 3 ],
 [ 8, 9, 4 ],
 [ 7, 6, 5 ]
]
</pre>

**Idea**: The idea is similar with spiral matrix. Actually, it's easier then the spiral matrix. Because now we can make sure that the matrix is a square matrix, thus we don't need to consider some corner cases like we did in spiral matrix. 


**Java code**:


```java

    public int[][] generateMatrix(int n) {
        int[][] matrix = new int[n][n];
        int num = 1;
        for(int i = 0; i < n/2+1; i++){
            for(int j = i; j < n - i; j++){
               matrix[i][j] = num++ ;
            }
            for(int j = i+1; j < n -i; j++){
               matrix[j][n-i-1] = num++;
            }
            for(int j = n-i-2; j >= i; j--){
               matrix[n-i-1][j] = num++;
            }
            for(int j = n - (i+2); j >= i+1; j--){
               matrix[j][i] = num++;
            }
       }
       return matrix;
    }

```

<br>
<br>

###60 Permutation Sequence

>The set [1,2,3,…,n] contains a total of n! unique permutations.

>By listing and labeling all of the permutations in order,
We get the following sequence (ie, for n = 3):

<pre>
"123"
"132"
"213"
"231"
"312"
"321"

</pre>

Given n and k, return the kth permutation sequence.

Note: Given n will be between 1 and 9 inclusive.



**Idea**: for each begin character, it has (n-1)! permutations, k/(n-1)! we know the begin character
	 
	 
**Attention**: How to decide add which num to the permutation? We use k/(n-1)!. There are boundary between permutation (n-1)! when add num to permutation. For example, n = 3, k = 4, k /(2!) = 2, should we add 2 or 3 to the permutation? 
Thus k-- can simplify the index.  

**Java code**:


```java

      public String getPermutation(int n, int k) {
            if(n <= 0) return "";
            
            /* create factorial,nums for permutation and ressult stringbuilder*/
            List<Integer> nums = new ArrayList<Integer>();
            int factorial = 1;
            for(int i = 1; i <= n; i++){
                nums.add(i);
                factorial *= i;
            }
            factorial /= n;
            StringBuilder res = new StringBuilder();
            
            /* to simplify the boundary, we can k--. Consider n = 4, k = 18, 18 / 6 = 3, then we need to add nums[i-1]*/ 
            k--;
            
            /*create permutation one digit per time*/
            while(n > 0){
                int index = k / factorial;
                res.append(nums.get(index));
                nums.remove(index);
                k %= factorial;
                if(n > 1) {
                    factorial = factorial / (n-1);
                }
                n--;
            }
            return res.toString();
        }
	

```



<br>
<br>


###61 Rotate List

> Given a list, rotate the list to the right by k places, where k is non-negative.

<pre>
For example:
Given 1->2->3->4->5->NULL and k = 2,
return 4->5->1->2->3->NULL.
</pre>

**Idea**: First calculate the length of list and record the tail, then move len - n steps. Connect tail and head, disconnect the (len-n)th and (len-n+1)th node.

**Attention**: 

- 1) we need to mode n = n%len
- 2) Take care of null pointer


code:
```java
      public ListNode rotateRight(ListNode head, int n) {
        if(n < 0 || head == null) return head;
        ListNode temp = head;
        int len = 0;
        ListNode tail = null;
        while(temp != null){
            len++;
            tail = temp;
            temp = temp.next;
        }
        n = n % len;
        len = len - n;
        if(n == 0 || len == 0) return head;
        temp = head;
        ListNode pre = null;
        while(len > 0){
            pre = temp;
            temp = temp.next;
            len--;
        }
        pre.next = null;
        tail.next = head;
        return temp;
    }

```


<br>
<br>


###62 Unique Paths

> A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).

>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).

>How many possible unique paths are there?

**Idea**: There are several ways to solve this problem. Let's discuss four methods. 

**Solution 1**

This problem is much similar to fibonacci number or the climb steps. We can easily solve this problem in recursion. But the time complexity is bad. The code is below(would be time exceeded on leetcode):

```java

    public int uniquePaths1(int m, int n) {
    	if (n <= 0 || m <= 0) {
    		return 0;
    	}
    	return helper(m-1, n-1);
    }
    
    public int helper(int m, int n){
    	if (m == 0 && n == 0) {
    		return 1;
    	} else if ( m < 0 || n < 0) {
    		return 0;
    	}
    	return helper(m-1, n)+helper(m, n-1);
    }


```
<br>

**Solution 2**

Simply to the climb stairs problem, we can solve this problem use dynamic programming. Use dynamic programming. dp[m][n] = dp[m-1][n-1]. 

In dp, the initial value is really important. In this problem, how do we initialize the dp array? Generally, the initianization would be dp[0][0] or dp[0][i] or dp[i][0], or other. In this problem, we need to initialize dp[0][i] dp[i][0] to 1, because they all have single path. The code is below:

*Dp, 2 dimensional array*

```java
    public int uniquePaths(int m, int n) {
        if (m < 0 || n < 0 || (m == 0 && n == 0)) {
            return 0;
        }
        
        int[][] dp = new int[m][n];
        for (int i = 0; i < m; i++) {
            dp[i][0] = 1;
        }
        for (int i = 0; i < n; i++) {
            dp[0][i] = 1;
        }
        
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }
        
        return dp[m-1][n-1];
    }
```

<br>


**Solution 3**

In the above dp code, the formula is  dp[i][j] = dp[i-1][j] + dp[i][j-1]. We can easily find that dp[i][j] is only related to the previous line. Thus we can use an one dimensional array to solve this problem.

```java


 public int uniquePaths(int m, int n) {
        if (m < 0 || n < 0 || (m == 0 && n == 0)) {
            return 0;
        }
        
        int[] dp = new int[n];
        dp[0] = 1;
        for (int i = 0; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[j] = dp[j] + dp[j-1];
            }
        }
        
        return dp[n-1];
 }


```


**Solution 4**

We can also use combination to solve this problem. We need to walk m+n-2 steps. m-1 steps down and n-1 steps right. 

**Note that the numbers will because really big after a few steps. Remember to use double or big integers.**

```java

	 public int uniquePaths3(int m, int n) {
		 int small = m < n ? m-1 : n-1;
		 int large = small == m-1 ? n-1 : m-1;
		 /* if use int, when m, n > 10, will overflow and get wrong answer*/
		 double up = 1;
		 double down = 1;
		 for (int i = 1; i <= small; i++) {
			 down *= i;
			 up *= small + large + 1 -i;
		 }
		 return (int) (up/down);
		 
	 }

```


<br>
<br>


###63 Unique Paths II

>Follow up for "Unique Paths":

>Now consider if some obstacles are added to the grids. How many unique paths would there be?

>An obstacle and empty space is marked as 1 and 0 respectively in the grid.

<pre>
For example,
There is one obstacle in the middle of a 3x3 grid as illustrated below.

[
  [0,0,0],
  [0,1,0],
  [0,0,0]
]
The total number of unique paths is 2.

Note: m and n will be at most 100.

</pre>


**Idea**: The basic Idea is similar to **62 Unique path**. Only difference is that we can not run through obstacles in this problem. So when we encounter obstacles, we need to set path through that lattice to 0.

Similarly, we can use one dimensional array or two dimensional array to solve this problem. 

**Attention**: *For the two dimensional array solution we need to take attention to the dp array initialization. Note that if one lattice if blocked, like grid[2][0] == 1, then all lattices after grid[2][0] such ad grid[3][0] ... should set dp[i][0] to 0.*


**Java code**:

**Two dimensional array**:

```java

public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        if (obstacleGrid == null || obstacleGrid.length == 0 || obstacleGrid[0].length == 0 || obstacleGrid[0][0] == 1) {
            return 0;
        }
        int[][] dp = new int[obstacleGrid.length][obstacleGrid[0].length];
        boolean blocked = false;
        for (int i = 0; i < obstacleGrid.length; i++) {
            if (obstacleGrid[i][0] == 1) {
                blocked = true;
            }
            if (!blocked) {
                dp[i][0] = 1;
            }
        }
        blocked = false;
        for (int i = 0; i < obstacleGrid[0].length; i++) {
            if (obstacleGrid[0][i] == 1) {
                blocked = true;
            }
            if (!blocked) {
                dp[0][i] = 1;
            }
        }
        for (int i = 1, rlen = obstacleGrid.length; i < rlen; i++) {
            for (int j = 1, clen = obstacleGrid[0].length; j < clen; j++) {
                if (obstacleGrid[i][j] == 0) {
                    dp[i][j] = dp[i][j-1] + dp[i-1][j];
                }
            }
        }
        return dp[obstacleGrid.length - 1][obstacleGrid[0].length - 1];
    }

```


**One dimensional array**:

```java
  public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int m = obstacleGrid.length;
        int n = obstacleGrid[0].length;
        if (obstacleGrid == null || m == 0 || n == 0 || obstacleGrid[0][0] == 1) {
            return 0;
        }
        int[] dp = new int[n];
        dp[0] = 1;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (obstacleGrid[i][j] == 0 && j > 0) {
                    dp[j] = dp[j-1] + dp[j];
                }else if (obstacleGrid[i][j] == 1) {
                    dp[j] = 0;
                }
            }
        }
        return dp[n - 1];
    }
```




<br>
<br>


###64 Minimum Path Sum

>Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.

>Note: You can only move either down or right at any point in time.


**Idea**: If you have figure out how to solve the unique path problem :

* [62 Unique Paths](#62-unique-paths)
* [63 Unique Paths II](#63-unique-paths-ii)

you will find that we can solve this problem in the same way. We can use recursion, 2 dimensonal dp, 1 dimensional dp to solve this problem. 

**Here is the 2 dimensional dp solution in java:**


```java

    public int minPathSum(int[][] grid) {
        if (grid == null || grid.length == 0 || grid[0].length == 0) {
            return 0;
        }
        int m = grid.length; 
        int n = grid[0].length;
        int[][] dp = new int[m][n];
        dp[0][0] = grid[0][0];
        for (int i = 1; i < n; i++) {
            dp[0][i] = dp[0][i-1] + grid[0][i];
        }
        for (int i = 1; i < m; i++) {
            dp[i][0] = dp[i-1][0] + grid[i][0];
        }
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = Math.min(dp[i-1][j] + grid[i][j], dp[i][j-1] + grid[i][j]);
            }
        }
        return dp[m-1][n-1];
    }

```


**Here is the 1 dimensional dp solution in java:**

```java

 public int minPathSum(int[][] grid) {
        if (grid == null || grid.length == 0 || grid[0].length == 0) {
            return 0;
        }
        int m = grid.length; 
        int n = grid[0].length;
        int[] dp = new int[n];
        dp[0] = grid[0][0];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (j == 0 && i == 0) {
                    continue;
                } else if (i == 0) {
                    dp[j] = dp[j-1] + grid[i][j];
                } else if (j == 0) {
                    dp[j] = dp[j] + grid[i][j];
                } else {
                     dp[j] = Math.min(dp[j], dp[j-1]) + grid[i][j];
                }
            }
        }
        return dp[n-1];
    }


```

<br>
<br>

###65 Valid Number
>Validate if a given string is numeric.

>Some examples:

>"0" => true

>" 0.1 " => true

>"abc" => false

>"1 a" => false

>"2e10" => true

>Note: It is intended for the problem statement to be ambiguous. You should gather all requirements up front before implementing one.


**Need to consider before start**:

<pre>

- In a number it could include 0, 1-9, ., e E, + - Thus if other character appears, then the number is invalid

- The right place of the above characters: 

	- 0-9:  0-9 is valid in any place. 
	
	- . 
		* can not after e or E
		* must has a number before it or after it 
		
	- - and + :
		* must at the beginning or after e or E
		* must has a number or . after it.

	- e or E:
		* must be the first time appear, that is, there should not be any e or E before it
		* e should not at the beginning
		* it must be a integer after e (we can have + or 1 after e)
	
</pre>


**Some case**:

<pre>

"1 " true
"  " false
"-1." true
"6e6.5" false
" 005047e+6" true

</pre>


**Java code**

```java



    public boolean isNumber1(String s) {
        if (s == null || s.trim().length() == 0) {
            return false;
        }
        s = s.trim();
        boolean eE = false;
        boolean dot = false;
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            //check if character valid, if e|E at the beginning , if -|+ at the end
            if (!isValidCharacter(c) || (i == 0 && (c == 'e' || c == 'E')) || (i == s.length() -1  && (c == '-' || c == '+'))) {
               return false;
            }
            //if e|E, e|E must hasn't existed before, must be a number of + - after it
            if ((c == 'e' || c == 'E')) {
                if (eE || (i == s.length() -1 || (!isNumber(s.charAt(i+1)) && s.charAt(i+1) != '-' && s.charAt(i+1) != '+'))) {
                    return false;
                }
                eE = true;
            }
            //if -|+, must at the beginning or after e|E, must be a . or number after it
            if ((c == '-' || c == '+')) {
                if((!isNumber(s.charAt(i+1)) && s.charAt(i+1) != '.') || (i != 0 && s.charAt(i-1) != 'e' && s.charAt(i-1) != 'E')) {
                    return false;
                }
            }
            // if ., .|e|E must hasn't existed before, must has a number before it or after it. 
           if (c == '.'){
               if (dot || eE ||  s.length() == 1 || (i == 0 && !isNumber(s.charAt(i+1))) || ( i == s.length() - 1 && !isNumber(s.charAt(i-1))) || (i != 0 && i != s.length() -1 && !isNumber(s.charAt(i-1)) && !isNumber(s.charAt(i+1)))) {
                   return false;
               } 
               dot = true;
           }
        }
        return true;
    }
    
    public boolean isNumber(char c) {
        if (c >= '0' && c <= '9') {
            return true;
        }
        return false;
    }
    
    public boolean isValidCharacter(char c) {
        if (isNumber(c) || c == '-' || c == '+' || c == '.' || c == 'e' || c == 'E') {
            return true;
        }
        return false;
    }


```


If use switch


```java

 public boolean isNumber(String s) {
        if (s == null || s.trim().length() == 0) {
            return false;
        }
        s = s.trim();
        boolean eE = false;
        boolean dot = false;
        for (int i = 0; i < s.length(); i++) {
           switch(s.charAt(i)) {
               case 'e':
               case 'E':
                    if (eE || i == s.length() -1 || i == 0) {
                    return false;
                }
                    eE = true;
                    break;
                case '-':
                case '+':
                     if ((i == s.length() -1 || !((s.charAt(i+1) >= '0' && s.charAt(i+1) <= '9') || s.charAt(i+1) == '.') || (i != 0 && s.charAt(i-1) != 'e' && s.charAt(i-1) != 'E'))) {
                    return false;
                    }
                    break;
                case '.':
                    if (dot || eE || s.length() == 1 || (i == 0 && !isNumber(s.charAt(i+1))) || ( i == s.length() - 1 && !isNumber(s.charAt(i-1))) || (i != 0 && i != s.length() -1 && !isNumber(s.charAt(i-1)) && !isNumber(s.charAt(i+1)))) {
                   return false;
                    } 
                    dot = true;
                    break;
                case '0':
        		case '1':
        		case '2':
        		case '3':
        		case '4':
        		case '5':
        		case '6':
        		case '7':
        		case '8':
        		case '9':
        			break;
            	default:
            			return false;
           }
        }
        return true;
    }
    
    public boolean isNumber(char c) {
        if (c >= '0' && c <= '9') {
            return true;
        }
        return false;
    }
   
```



<br>
<br>

###66 Plus One

>Given a non-negative number represented as an array of digits, plus one to the number.

>The digits are stored such that the most significant digit is at the head of the list.



**Idea**: Since the most significant digit is at the head of the list, thus we need to add from the end. Thus problem is really similar to add two numbers, the other number in the two number is 1. We just need to take care of the carry. 

There are two cases:

- If carry is not 1 at the end, what should we  do? Definitely the original array is not big enough to store the result. Thus we need to enlarge the array by creating a new array. So the most straight forward thing to do is store the carry at index 0 and copy the original array, like the **First try solution** below.

It seems that it's a pretty good solution. Well, actually, we just need to store carry in index 0. **Why? Because if there are carry at the end, then the other digits must be 0**.  See detail on the **better solution** below. 


**Java code**:


**First try**:

```java

 public int[] plusOne(int[] digits) {
        if (digits == null || digits.length == 0) {
            return digits;
        }
        int carry = 0;
        for (int i = digits.length - 1; i >= 0; i--) {
            int digit = digits[i];
            if (i == digits.length -1) {
                digit += 1;
            }
            digit += carry;
            digits[i] = digit % 10;
            carry = digit / 10;
        }
        if (carry == 0) {
            return digits;
        } else {
            int[] res = new int[digits.length + 1];
            res[0] = carry;
            for (int i = 0; i < digits.length; i++){
                res[i+1] = digits[i];
            }
            return res;
        }
        
    }


```


**Better solution**:

```java
    public int[] plusOne(int[] digits) {
        if (digits == null || digits.length == 0) {
            return digits;
        }
        int carry = 0;
        for (int i = digits.length - 1; i >= 0; i--) {
            int digit = digits[i];
            if (i == digits.length -1) {
                digit += 1;
            }
            digit += carry;
            digits[i] = digit % 10;
            carry = digit / 10;
        }
        if (carry == 0) {
            return digits;
        } else {
            int[] res = new int[digits.length + 1];
            res[0] = carry;
            return res;
        }
    }

```


<br>
<br>



###67 Add Binary

>Given two binary strings, return their sum (also a binary string).

>For example,

>a = "11"

>b = "1"

>Return "100".


**Idea**:


**Solution**:




<br>

<br>

###69 Sqrt

>Implement int sqrt(int x).

>Compute and return the square root of x.


**Idea**: The result = x/result, so each time we can give a better guess result = (result + x/result)/2 until we get the correct answer.

```java
  public int mySqrt(int x) {
        if (x < 1) {
            return 0;
        }
        double res = 1;
        while (true) {
            if (Math.abs(res - x/res) < 0.00000001) {
                return (int)res;
            }
            res = (res + x / res) / 2;
        }
    }
```	
**Other Idea**: Dichotomy. l = smallest possible result, r the largest possible result. mid = (l + r)/2 , check the relationship between mid and result

**Attention**: mid <= x/mid && (mid + 1) > x/(mid+1) can not change to mid * mid <= x && (mid+1) * (mid+1) > x. Because, when **mid * mid overflows**, the result might change, also, it might lead to Time limit exceeded.

```java
    public int mySqrt(int x) {
        if (x < 1) {
            return 0;
        }
        int l = 1;
        int r = x/2 + 1;
        while (l <= r) {
           int mid = l + (r - l) / 2;
           if (mid <= x / mid && (mid + 1) > x / (mid + 1)) {
               return mid;
           } else if (mid > x / mid) {
               r = mid - 1;
           } else {
               l = mid + 1;
           }
        }
        return 0;
    }

```	
 


<br>

<br>

###70 Climbing Stairs

>You are climbing a stair case. It takes n steps to reach to the top.

Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?

**Idea**: Each time we can climb 1 steps or 2 steps, thus Fn = Fn-1 + Fn-2. It's just a fibonacci sequence. 

**Solution1** Use dp, Time O(n), Space O(1)

```java
 public int climbStairs(int n){
        if(n == 0) return 1;
        if(n == 1) return 1;
        int n1 = 1;
        int n2 = 1;
        int n3 = 0;
        for(int i = 2; i <= n; i++){
            n3 = n1 + n2;
            n1 = n2;
            n2 = n3;
        }
        return n3;
    }
```    
 
 
 **Solution2**: Use matrix, O(lgn) time.
 
 ```java
 
   public int climbStairs2(int n){
        if(n < 0) return 0;
        if(n <= 1) return 1;
        int[][] res = {{1, 0}, {0, 1}};
        int[][] m = {{1, 1}, {1, 0}};
        while(n > 0){
            if(n % 2 == 1) res = multiplyMatrix(res, m);
            n = n/2;
            m = multiplyMatrix(m, m);
        }
        return res[0][0];
    }
    
    
    public int[][] multiplyMatrix(int[][] m, int[][]n){
        int a = m[0][0] * n[0][0] + m[0][1] * n[1][0];
        int b = m[0][0] * n[0][1] + m[0][1] * n[1][1];
        int c = m[1][0] * n[0][0] + m[1][1] * n[1][0];
        int d = m[1][0] * n[0][1] + m[1][1] * n[1][1];
        int[][] res = {{a, b}, {c, d}};
        return res;
    }
 
```

**Solution 3** : recursion, O(2 ^ n) time.
```java
    public int climbStairs(int n) {
        if(n < 0) return 0;
        if(n == 1 || n == 0) return 1;
        return climbStairs(n-1)+climbStairs(n-2);
    }
    
```

We see that the value of Fibonacci increases exponentially. If we use int, then we can only compute to F47, if we use long, we can compute to F96. So if our required numbers are big, it's unreasonable to use in/long as return value. We can use BigInteger in java. Eg:

```java

	public static String bigFib(int n){
    	if(n <= 0) return "0";
    	if(n == 1) return "1";
    	BigInteger n1 = new BigInteger("0");
    	BigInteger n2 = new BigInteger("1");
    	BigInteger n3 = new BigInteger("0");
        for(int i = 2; i <= n; i++){
        	n3 = n1.add(n2);
        	n1 = n2;
        	n2 = n3;
        }
        return n3.toString();
    	
    }
    

```

<br>
<br>

###73 Set Matrix Zeroes

>Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in place.

**Idea**: The easiest way to do this problem is record the rows of columns needed to be set to 0. We can use extra array to record the rows and columns. The space complexity would ba O(m+n). If we use one row and one column that are supposed to set to 0s to stroe the information, we can get O(1) space complexity.

**Java code**:

```java
public void setZeroes(int[][] matrix) {
        if(matrix == null || matrix.length == 0 || matrix[0].length == 0) return;
        int[] rzeros = new int[matrix.length];
        int[] czeros = new int[matrix[0].length];
        
        for(int i = 0; i < matrix.length; i++){
            for(int j = 0; j < matrix[0].length; j++){
                if(matrix[i][j] == 0) {
                    rzeros[i] = 1;
                    czeros[j] = 1;
                }
            }
        }
        for(int i = 0; i < rzeros.length; i++){
            if(rzeros[i] == 1){
                for(int j = 0; j < matrix[0].length; j++){
                    matrix[i][j] = 0;
                }
            } 
        }
        for(int i = 0; i < czeros.length; i++){
            if(czeros[i] == 1){
                for(int j = 0; j < matrix.length; j++){
                    matrix[j][i] = 0;
                }
            }
        }
    }

```



<br>
<br>

###74 Search a 2D Matrix
>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:

>Integers in each row are sorted from left to right.
The first integer of each row is greater than the last integer of the previous row.
For example,

>Consider the following matrix:

<pre>
[
  [1,   3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]
Given target = 3, return true.

</pre>

**Idea**:

*Solution 1*: We can search from the top-right, if the target is larger than current, then we move to next row. If the target is smaller, then we move to left.

*Solution 2*: We use the method in solution 1 to find the target row, then apply binary search on that row.

Solution 3*: Use binary search to find the row, then in that row, use binary search to find the target.

**Attention: In binary search, when loop ends, if target is not found, then l points to the first element larger than the target and r points to the first element smaller than target.** 

**java code**:

**Solution 1**: Time: O(m + n)

```java
    public boolean searchMatrix(int[][] matrix, int target) {
        if(matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return false;
        }
        for (int i = 0, row = matrix.length; i < row; i++) {
            for (int j = matrix[0].length - 1; j >= 0; j--) {
                if (matrix[i][j] == target) {
                    return true;
                } else if (matrix[i][j] < target) {
                    break;
                }
            }
        }
      return false;
    }
```

**Solution 2**: Time: O(m) + O(lgn)

```java
    public boolean searchMatrix(int[][] matrix, int target) {
        if(matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return false;
        }
        for (int i = 0, row = matrix.length; i < row; i++) {
            for (int j = matrix[0].length - 1; j >= 0; j--) {
                if (matrix[i][j] == target) {
                    return true;
                } else if (matrix[i][j] < target) {
                    break;
                } else {
                    //do binary search 
                    int l = 0;
                    int r = j - 1;
                    while (l <= r) {
                        int mid = l + (r - l) / 2;
                        if (matrix[i][mid] == target) {
                            return true;
                        } else if (matrix[i][mid] > target) {
                            r = mid - 1;
                        } else {
                            l = mid + 1;
                        }
                    }
                    return false;
                }
            }
        }
      return false;
    }
```

**Solution 3**: Time complexity: O(lgm) + O(lgn)

***There are two ways below, can you find out the big difference here? ***

1) search from right. 

```java
   public boolean searchMatrix(int[][] matrix, int target) {
        if(matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return false;
        }
        
        int row = matrix.length;
        int col = matrix[0].length;
        int l = 0;
        int r = row - 1;
        //Find row
        while (l <= r) {
            int mid = l + (r - l) / 2;
            if (matrix[mid][col - 1] == target) {
                return true;
            } else if (matrix[mid][col - 1] > target) {
                r = mid - 1;
            } else {
                l = mid + 1;
            }
        }
        //find target in that row
        if (l >= row || l < 0) {
            return false;
        }
        int ll = 0;
        int rr = col - 1;
        while (ll <= rr) {
            int midcol = ll + (rr -ll) / 2;
            if (matrix[l][midcol] == target) {
                return true;
            } else if (matrix[l][midcol] < target) {
                ll = midcol + 1;
            } else {
                rr = midcol - 1;
            }
        }
      return false;
    }
```

2) Search from left 


```java
    public boolean searchMatrix(int[][] matrix, int target) {
        if(matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return false;
        }
        
        int row = matrix.length;
        int col = matrix[0].length;
        int l = 0;
        int r = row - 1;
        //Find row
        while (l <= r) {
            int mid = l + (r - l) / 2;
            if (matrix[mid][0] == target) {
                return true;
            } else if (matrix[mid][0] > target) {
                r = mid - 1;
            } else {
                l = mid + 1;
            }
        }
        //find target in that row
        if (r >= row || r < 0) {
            return false;
        }
        int ll = 0;
        int rr = col - 1;
        while (ll <= rr) {
            int midcol = ll + (rr -ll) / 2;
            if (matrix[r][midcol] == target) {
                return true;
            } else if (matrix[r][midcol] < target) {
                ll = midcol + 1;
            } else {
                rr = midcol - 1;
            }
        }
      return false;
    }
```

<br>
<br>

###75 Sort Colors


> Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue.

>Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.

>Note:
>You are not suppose to use the library's sort function for this problem. 

**Idea**:

- Solution 1: Use counting sort, we can count the numbers of 0, 1, 2, then refill numbers into A. **Note that this is not inplace**
- Solution 2: Use two pointers for 0 and 1, if we encounter 0, A[count1++] = 1, A[count0++] = 0, if we encounter 1, count1++

**Attention**: 

- 1) For the second method, the sequence of count1++ and count0++ is impoertant, we need first A[count1++] = 1
- 2) Everytime before we move the two pointers, we need to assgin A[i] = 2. Because we don't maintain a pointer for 2, thus the last part would be 2.

**Time complexity**

Use method1 need two pass. Method 2 only need one pass. 


**Java code Solution1**:

```java

    public void sortColors(int[] A) {
    	if(A == null || A.length == 0) return;
    	int count0 = 0;
    	int count1 = 0;
    	for(int i = 0; i < A.length; i++){
    		if(A[i] == 0) count0++;
    		else if(A[i] == 1) count1++;
    	}
    	for(int i = 0; i < A.length; i++){
    		if(i < count0) A[i] = 0;
    		else if(i >= count0 && i < count0+count1) A[i] = 1;
    		else A[i] = 2;
    	}
    }
    

```


**Java code solution 2**:

```java

    public void sortColors(int[] A) {
        if(A == null || A.length == 0) return;
        int count0 = 0, count1 = 0;
        for(int i = 0; i < A.length; i++){
            if(A[i] == 0){
                A[i] = 2;
                A[count1++] = 1;
                A[count0++] = 0;
            }else if(A[i] == 1){
                A[i] = 2;
                A[count1++] = 1;
            }
        }

    }
```



<br>
<br>

###77 Combinations

>Given two integers n and k, return all possible combinations of k numbers out of 1 ... n.

<pre>
For example,
If n = 4 and k = 2, a solution is:

[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
</pre>



**Idea**: Same idea with combination sum, difference is that here we use k to determine the recursion termination condition

**Solution**: Recursion

```java
    public List<List<Integer>> combine(int n, int k) {  
        List<List<Integer>> res = new ArrayList<List<Integer>>();  
        if (n <= 0 || n < k) {
            return res;
        }
        combine(n, k, 1, new ArrayList<Integer>(), res);  
        return res;  
    }  
    private void combine(int n, int k, int start, List<Integer> item, List<List<Integer>> res)  {  
        if (item.size() == k) {  
            res.add(new ArrayList<Integer>(item));  
            return;  
        }  
        for (int i = start; i <= n; i++) {  
            item.add(i);  
            combine(n, k, i + 1, item, res);  
            item.remove(item.size() - 1);  
        }  
    } 

```

<br>
<br>

###78 Subsets


>Given a set of distinct integers, nums, return all possible subsets.

>Note:
>Elements in a subset must be in non-descending order.
>The solution set must not contain duplicate subsets.

<pre>
For example,
If nums = [1,2,3], a solution is:

[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]

</pre>



**Idea**: 

- Non-decsending order --sort the array first
- step:
	- []
	- []     [1]
	- [] [1]       [2] [1, 2]
	- [] [1] [2] [1, 2]        [3] [1, 3] [2, 3] [1, 2, 3]

From the subsets creation steps above, you must find a way to solve this problem.
The Subset begin with [], after insert 1, it becomes [] [1], you need to combine the original [] and new created[1]. Then add [2] [3] by step. 

**Attention** : What is the time complexity of this problem? Note that the number of subsets increase exponentially.


**Iterative**:


```java

    public List<List<Integer>> subsets1(int[] nums) {
        List<List<Integer>> res = new ArrayList<List<Integer>>();
        res.add(new ArrayList<Integer>());
        if (nums == null || nums.length == 0) {
            return res;
        }
        Arrays.sort(nums);
        for (int i = 0; i < nums.length; i++) {
            List<List<Integer>> cur = new ArrayList<List<Integer>>();
            for (List<Integer> l : res) {
                List<Integer> temp = new ArrayList<Integer>(l);
                temp.add(nums[i]);
                cur.add(temp);
            }
            res.addAll(cur);
        }
        return res;
    }


```


**Recursive**:



```java
    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> res = new ArrayList<List<Integer>>();
        res.add(new ArrayList<Integer>());
        if (nums == null || nums.length == 0) {
            return res;
        }
        Arrays.sort(nums);
        helper(nums, 0, res);
        return res;
    }
    
    public void helper(int[] nums, int start, List<List<Integer>> res) {
        if (start == nums.length) {
            return;
        }
        List<List<Integer>> cur = new ArrayList<List<Integer>>();
        for (List<Integer> l : res) {
            List<Integer> temp = new ArrayList<Integer>(l);
            temp.add(nums[start]);
            cur.add(temp);
        }
        res.addAll(cur);
        helper(nums, start + 1, res);
    }
```


<br>

**Similar DFS solution for string**:

```java
  public List<String> subSets(String set) {
    List<String> res = new ArrayList<String>();
    if (set == null) {
      return res;
    }
    char[] arr = set.toCharArray();
    subSets(arr, 0, res, new StringBuilder());
    return res;
  }
  
  public void subSets(char[] arr, int index, List<String> res, StringBuilder sb) {
    if (index == arr.length) {
      res.add(sb.toString());
      return;
    }
    subSets(arr, index + 1, res, sb);
    subSets(arr, index + 1, res, sb.append(arr[index]));
    sb.deleteCharAt(sb.length() - 1);
  }
```

<br>

**Related**: **subsets of string**

> eg: Set = "abc":  [“”, “a”, “ab”, “abc”, “ac”, “b”, “bc”, “c”]

> Set = "":  [""]

> Set = null: []

**Idea**: Same with List. 

**Solution**:

```java
  public List<String> subSets(String set) {
    List<String> res = new ArrayList<String>();
    if (set == null) {
      return res;
    }
    res.add("");
    for (int i = 0; i < set.length(); i++) {
      List<String> current = new ArrayList<String>();
      char c = set.charAt(i);
      for (int j = 0; j < res.size(); j++) {
         String s = res.get(j);
         String newS = concatenate(s, s.length(), c);
         current.add(newS);
      }
      res.addAll(current);
    }
    return res;
  }
  
  public String concatenate(String s, int i, char c) {
    if (s == null || s.length() < i || i < 0) {
      return null;
    }
    return s.substring(0, i) + c + s.substring(i, s.length());
  }
```

<br>

**What if we treat "ac" and "ca"  different?**

**Idea**: Add one more loop, insert each character to each possible index of the all existed strings.

**Solution**:

```java
  public List<String> subSets(String set) {
    List<String> res = new ArrayList<String>();
    if (set == null) {
      return res;
    }
    res.add("");
    for (int i = 0; i < set.length(); i++) {
      List<String> current = new ArrayList<String>();
      char c = set.charAt(i);
      for (int j = 0; j < res.size(); j++) {
         String s = res.get(j);
         for (int k = 0; k <= s.length(); k++) {
           String newS = concatenate(s, k, c);
           current.add(newS);
         }
      }
      res.addAll(current);
    }
    return res;
  }
  
  public String concatenate(String s, int i, char c) {
    if (s == null || s.length() < i || i < 0) {
      return null;
    }
    return s.substring(0, i) + c + s.substring(i, s.length());
  }

```  



<br>
<br>

###80 Remove Duplicates From Sorted Array II

>Follow up for "Remove Duplicates":
>
>What if duplicates are allowed at most twice?
>
>For example,
>
>Given sorted array A = [1,1,1,2,2,3],
>
>Your function should return length = 5, and A is now [1,1,2,2,3].

**Idea**: It's the same method with [26 Remove Duplicates from Sorted Array](#26-remove-duplicates-from-sorted-array). Only diffence is that we need to compare with previous and previous previous element. 

**Java Code**:


```java

    public int removeDuplicates(int[] A) {
        if(A == null) return 0;
        if(A.length <= 2) return A.length;
        int count = 2;
        int pre = A[1];
        int prepre = A[0];
        for(int i = 2; i < A.length; i++){
            if(A[i] == pre && A[i] == prepre) continue;
            A[count++] = A[i];
            prepre = pre;
            pre = A[i];
        }
        return count;
    }
	

```



<br>
<br>

###81 Search in Rotated Sorted Array II

>Follow up for "Search in Rotated Sorted Array":
**What if duplicates are allowed?**

>Would this affect the run-time complexity? How and why?

>Write a function to determine if a given target is in the array.


**Idea**: In * [33 Search in Rotated Sorted Array](#33-search-in-rotated-sorted-array), we can make sure that each time we cut half of the array, thus the totla time complexity is O(lgn). In this problem, since the existence of dulicates, thus the A[mid] might equals to A[l] and A[r]. From this information, we don't know which half we should go. Thus the worst case would be **O(n)** 

How to solve this problem? We can use the second method in * [33 Search in Rotated Sorted Array](#33-search-in-rotated-sorted-array). If we can not find an increasing  interval of A[l]-A[mid] and A[mid]-A[r], we can just move one step right or one step left by l++ or r--



**Solution 1 
**:


```java
 public boolean search(int[] A, int target) {
        if(A == null || A.length == 0) {
            return false;
        }
        int l = 0;
        int r = A.length-1;
        while(l <= r){
           int mid = l + (r - l) / 2;
           if (A[mid] == target) {
               return true;
           } else if (A[mid] > A[l]) {
               if (A[l] <= target && A[mid] > target) {
                   r = mid - 1;
               } else {
                   l = mid + 1;
               }
           } else if (A[mid] < A[l]){
               if (A[mid] < target && A[r] >= target) {
                   l = mid + 1;
               } else {
                   r = mid - 1;
               }
           } else {
            l++;
           }
        } 
        return false;
    }

```


**Solution 2**:  Even though in worst cast this solution is same with solution 1, in saome cases solution 1 has better time complexity

```java

  public boolean search(int[] A, int target) {
        if(A == null || A.length == 0) {
            return false;
        }
        int l = 0;
        int r = A.length-1;
        while(l <= r){
            int mid = (l+r)/2;
            if(A[mid] == target) {
                return true;
            } else if(A[mid] > target && A[mid] < A[r]) {
                r = mid-1;
            } else if(A[mid] < target && A[mid] > A[l]) {
                l = mid + 1;
            } else if (A[l] != target) {
                l++;
            } else {
                return true;
            }
        }
        return false;
    }


```


<br>
<br>



###82 Remove Duplicates from Sorted List

>Given a sorted linked list, delete all duplicates such that each element appear only once.

For example,
Given 1->1->2, return 1->2.
Given 1->1->2->3->3, return 1->2->3.

**Idea**: It's simple compare to * [83 Remove Duplicates from Sorted List II](#83-remove-duplicates-from-sorted-list-ii). Because there are less corner cases related to null pointers. Just if head != null, start from the head.next, when encounter duplicates, delete that node. 

```java
   public ListNode deleteDuplicates(ListNode head) {
        if(head == null) return null;
        ListNode pre = head;
        ListNode temp = head.next;
        while(temp != null){
            if(temp.val == pre.val) {
                pre.next = temp.next;
                temp = temp.next;
            }else{
                pre = temp;
                temp = temp.next;
            }
        }
        return head;
    }

```    

<br>
<br>

###83 Remove Duplicates from Sorted List II

>Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.

<pre>
For example,
Given 1->2->3->3->4->4->5, return 1->2->5.
Given 1->1->1->2->3, return 2->3.
</pre>

**Idea**:

1) Compare each node with it's next, count++ if duplicate is found. if head.val != head.next.val, then check if count == 1. If yes, add node, else reset head to 1 and  continue.


**Attention**: Remember to check count at the end. If count == 1, add the last node. else set result's tail.next = null. 

```java
    public ListNode deleteDuplicates(ListNode head) {
        if(head == null) return head;
        ListNode feakHead = new ListNode(-1);
        ListNode h1 = feakHead;
        int count = 1;
        while(head != null && head.next != null){
            if(head.val == head.next.val){
                head = head.next;
                count++;
            }else{
                if(count == 1){
                    h1.next = head;
                    head = head.next;
                    h1 = h1.next;
                }else{
                    head = head.next;
                    count = 1;
                }
            }
        }
        if(count == 1) h1.next = head;
        else h1.next = null;
        return feakHead.next;
    }
```




<br>
<br>

###86 Partition List

>Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.

You should **preserve the original relative order** of the nodes in each of the two partitions.

<pre>
For example,
Given 1->4->3->2->5->2 and x = 3,
return 1->2->2->4->3->5.
</pre>

**Idea**: We need to preserve the original order, thus we can maintain two pointers, h1 and tail. h1 is the place we need to insert the element which smaller than x. tail is the end of the result list from which we add the elements equal or larger than x. 

**Attention**: We need to 
```java
    public ListNode partition(ListNode head, int x) {
        if (head == null) {
            return null;
        }
        ListNode feakHead = new ListNode(-1);
        ListNode h = feakHead;
        ListNode tail = feakHead;
        while (head != null){
            if (head.val >= x) {
                tail.next = head;
                head = head.next;
                tail = tail.next;
                tail.next = null;
            } else{
                 ListNode saveH = h;
                 ListNode temp = h.next;
                 h.next = head;
                 head = head.next;
                 h = h.next;
                 h.next = temp;
                 if (tail.equals(saveH)) {
                    tail = h;
                 }
            }
        }
        return feakHead.next;
    }

```

**Another solution**: much similar to the first one

```java
  public ListNode partition(ListNode head, int target) {
    // write your solution here
    if (head == null || head.next == null) {
      return head;
    }
    ListNode fakeHead1 = new ListNode(-1);
    ListNode fakeHead2 = new ListNode(-1);
    ListNode smaller = fakeHead1; // position to insert elements smaller than target
    ListNode larger = fakeHead2; // position to insert elements larger than target
    ListNode temp = head;
    while (temp != null) {
      ListNode next = temp.next;
      temp.next = null;
      if (temp.value < target) {
        smaller.next = temp;
        smaller = smaller.next;
      } else {
        larger.next = temp;
        larger = larger.next;
      }
      temp = next;
    }
    smaller.next = fakeHead2.next;
    return fakeHead1.next;
  }
```

<br>
<br>

###89 Gray Code
>The gray code is a binary numeral system where two successive values differ in only one bit.

>Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.

>For example, given n = 2, return [0,1,3,2]. Its gray code sequence is:

>00 - 0

>01 - 1

>11 - 3

>10 - 2

>Note:
>For a given n, a gray code sequence is not uniquely defined.

>For example, [0,2,3,1] is also a valid gray code sequence according to the above definition.

>For now, the judge is able to judge based on one instance of gray code sequence. Sorry about that.

Let's first see a few example of gray code and find the laws to create gray code

	n = 1: 0 
		   1
	
	n = 2: 00 
		   01
		   11
		   10

	n = 3: 000
	       001
	       011
	       010
	       110
	       111
	       101
	       100
	       
	 n = 4: 0000
	 	    0001
	 	    0011
	 	    0010
	 	    0110
	 	    0111
	 	    0101
	 	    0100
	 	    1100
	 	    1101
	 	    1111
	 	    1110
	 	    1010
	 	    1011
	 	    1001
	 	    1000
		   
**Some laws from above** : we can find that the first half of  2 ^ n numbers could be create by add a 0 to 2 ^ (n-1) numbers. For the last half of 2 ^ n, we can add 1 to the reversed order number of 2 ^ (n-1). 

For example, based on 2 bit gray code, we can get the first half of 3 bit gray code by adding 0, eg: 000 001 011 010, for the last half, we first reverse the order 10, 11, 01, 00, then add 1 to each of them, we can get 110 111 101 100.

**Time Complexity**: we have 2 ^ n gray code numbers, thus the time complexity is 2 ^ n
**Space**: 2 ^ n
```java
    public List<Integer> grayCode(int n) {
        List<Integer> list = new ArrayList<Integer>();
        if(n < 0) return list;
        list.add(0);
        if(n == 0) return list;
        list.add(1);
        for(int i = 2; i <= n; i++){
            for(int j = list.size()-1; j >= 0; j--){
                list.add(list.get(j) + (1 <<(i-1)));
            }
        }
        return list;
     }
```
**Related Questions** : check if two bytes can be put successively in a gray code sequence.

**Idea**: we know that the neighbor gray code numbers is different with 1 bit. We need to check if these two numbers have only one bit diffenence.

```java
	public boolean isSuccesive(byte b1, byte b2){
		int count = 0;
		while(b1 > 0 || b2 > 0){
			if((b1 & 1) != (b2 & 1))
				count++;
			b1 >>>= 1;
			b2 >>>= 1;
		}
		return count == 1;
	}
```

If the numbers are unsigned numbers, we can first ^ then check if it is the power of 2
```java	
	temp = b1 ^ b2;
	
	return (temp > 0) && ((temp & -temp) == temp); 
	
	return (temp > 0) && ((temp & (temp -1)) == 0);
	
```	
<br>
<br>


###90 Subsets II

>Given a collection of integers that might contain duplicates, nums, return all possible subsets.

<pre>
Note:
Elements in a subset must be in non-descending order.
The solution set must not contain duplicate subsets.
For example,
If nums = [1,2,2], a solution is:

[
  [2],
  [1],
  [1,2,2],
  [2,2],
  [1,2],
  []
]
</pre>


**Idea**: The different with * [78 Subsets](#78-subsets) is that in this problem the nums might contain duplicates.

How to handle duplicates? 

Consider the above case [1, 2, 2], then the steps are below:

- []
- []      [1]
- [][1]   [2][1,2]
- [][1][2][1,2]  [2,2][1, 2, 2]

You might make a mistake that if duplicates occur, we just need to insert new element into the last half of the pre subsets. This seems true at first glance. 

Consider the case [2, 2, 2, 2, 2]

- [] 
- []   [2]
- [][2]   [2,2]
- [][2][2,2]   [2,2,2]
- [][2][2,2][2,2,2]    [2,2,2,2]
- .......

Actually, the start position we need to insert is the size of the prev subsets result. 

Here are he solutions.


**Iterative**:


```java
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        List<List<Integer>> res = new ArrayList<List<Integer>>();
        res.add(new ArrayList<Integer>());
        if (nums == null || nums.length == 0) {
            return res;
        }
        Arrays.sort(nums);
        int prevSize = 0;
        for (int i = 0; i < nums.length; i++) {
            List<List<Integer>> cur = new ArrayList<List<Integer>>();
            int startPos = 0;
            if (i > 0 && nums[i] == nums[i-1]) {
                startPos = prevSize;
            } 
           for (;startPos< res.size(); startPos++) {
                List<Integer> temp = new ArrayList<Integer>(res.get(startPos));
                temp.add(nums[i]);
                cur.add(temp);
            }
            prevSize = res.size();
            res.addAll(cur);
        }
        return res;
    }
```


**Resursion**:


```java
 public List<List<Integer>> subsetsWithDup(int[] nums) {
	        List<List<Integer>> res = new ArrayList<List<Integer>>();
	        res.add(new ArrayList<Integer>());
	        if (nums == null || nums.length == 0) {
	            return res;
	        }
	        Arrays.sort(nums);
	        helper(nums, 0, res, 0);
	        return res;
	    }
	    
	    public void helper(int[] nums, int start, List<List<Integer>> res, int lastSize) {
	        if (start == nums.length) {
	            return;
	        }
	        List<List<Integer>> cur = new ArrayList<List<Integer>>();
	        int insertPos = 0;
	        if (start > 0 && nums[start] == nums[start-1]) {
	            insertPos = lastSize;
	        }
	        for (; insertPos < res.size(); insertPos++) {
	            List<Integer> temp = new ArrayList<Integer>(res.get(insertPos));
	            temp.add(nums[start]);
	            cur.add(temp);
	        }
	        lastSize = res.size();
	        res.addAll(cur);
	        helper(nums, start + 1, res, lastSize);
	    }
    

```


<br>
<br>

###92 Reverse Linked List II

>Reverse a linked list from position m to n. Do it in-place and in one-pass.

<pre>

For example:
Given 1->2->3->4->5->NULL, m = 2 and n = 4,

return 1->4->3->2->5->NULL.

Note:
Given m, n satisfy the following condition:
1 ≤ m ≤ n ≤ length of list.
	
</pre>

**Idea**: 1) Find begining node of reverse. 2) reverse m-n 3) concatenate 

**Attention**:

- 1) when concatenate, take care of null pointer. ***(When use node.next, always check if node is null)***
- 2) If m == 1, what should we return? So check the previous node of the reverse list's head, if it's null, just return the reverse head. 
- 3) Take care of the steps. We need to move ***m-1*** steps to find the beginning of the reverse. We need take another ***n-m+1*** steps to reverse the nodes. 
```java
    public ListNode reverseBetween1(ListNode head, int m, int n) {
        if(head == null || head.next == null || (m == n)) return head;
        ListNode saveHead = head;
        ListNode preReverse = null;
        while(m-1 > 0){
            preReverse = head;
            head = head.next;
            m--;
            n--;
        }
        ListNode reverseHead = null;
        ListNode reverseTail = null;
        ListNode next = null;
        while(n-1 >= 0){
            n--;
            if(reverseHead == null){
                reverseHead = head;
                reverseTail = head;
                head = head.next;
                continue;
            }
            next = head.next;
            head.next = reverseHead;
            reverseHead = head;
            head = next;
        }
        if(preReverse != null) preReverse.next = reverseHead;
        if(reverseTail != null) reverseTail.next = head;
        if(preReverse == null) return reverseHead;
        return saveHead;
      }
```   
   <br>
 
     

Pretty much the save with the above, just change while to for:
```java
  public ListNode reverseBetween(ListNode head, int m, int n) {
    	if(head == null) return null;
    	if(m < 0) m = 0;
    	if(m > n){
    		int tempValue = m;
    		m = n;
    		n = tempValue;
    	}
    	
    	ListNode temp = head;
    	ListNode previousM = null;
    	
    	/* find node at m */
    	for(int i = 1; i < m && temp != null; i++){
    		previousM = temp;
    		temp = temp.next;
    	}
    	ListNode saveTemp = temp;
    	
    	/* reverse node between m and n */
    	ListNode pre = null;
    	ListNode next = null;
    	for(int i = m; i <= n && temp != null; i++){
    		next = temp.next;
    		temp.next = pre;
    		pre = temp;
    		temp = next;
    	}
    	
    	/* concatenate */
    	if(previousM != null) previousM.next = pre;
    	if(saveTemp != null) saveTemp.next = temp;
    	
    	if(m == 1) return pre; 
    	return head;
     }
     
``` 


<br>
<br>


###94 Binary Tree Inorder Traversal

> Given a binary tree, return the inorder traversal of its nodes' values.

<pre>
For example:
Given binary tree {1,#,2,3},
   1
    \
     2
    /
   3
return [1,3,2].

</pre>

> Note: Recursive solution is trivial, could you do it iteratively?

**Idea**: 

- 1) Solution 1: Recursion. It's the simplest method. Just visit in left, root, right order.

- 2) Solution 2: Iterative. Use a stack to record the parant node, so we can go to it and its right child after visit its left child.

- 3) Solution 3 : Morris Traversal. Use a pointer to go back to its parent after visit it's left child. Note that use this method we only need O(1) space. Want to know more about Morris traversal click on this link. [Morris Traversal](http://wishyouhappy.github.io/2014/12/17/morris%20traversal-traverse%20a%20binary%20tree%20without%20stack/). 


**Solution 1, Recursion**:


```java
public List<Integer> inorderTraversal(TreeNode root) {
    List<Integer> res = new ArrayList<Integer>();
    if (root == null) {
        return res;
    }
    inorderTraversal(root, res);
    return res;
}
public void inorderTraversal(TreeNode root, List<Integer> res) {
    if (root == null) {
        return;
    }
    inorderTraversal(root.left, res);
    res.add(root.val);
    inorderTraversal(root.right, res);
}
```



**Solution 2, Iterative**:

```java
public List<Integer> inorderTraversal(TreeNode root) {
    List<Integer> res = new ArrayList<Integer>();
    if (root == null) {
        return res;
    }
    Stack<TreeNode> stack = new Stack<TreeNode>();
    while (root != null || !stack.isEmpty()) {
        if (root != null) {
            stack.push(root);
            root = root.left;
        } else {
            root = stack.pop();
            res.add(root.val);
            root = root.right;
        }
    }
    return res;
}
```



**Solution 3: Morris Traversal**:

```java

public List<Integer> inorderTraversal(TreeNode root) {
    List<Integer> res = new ArrayList<Integer>();
    TreeNode pre = null;
    while (root != null) {
        if (root.left == null) {
            res.add(root.val);
            root = root.right;
        } else {
            pre = root.left;
            while (pre.right != null && pre.right != root) {
                pre = pre.right;
            }
            if (pre.right == null) {
                pre.right = root;
                root = root.left;
            } else {
                pre.right = null;
                res.add(root.val);
                root = root.right;
            }
        }
    }
    return res;
}

```


<br>
<br>

**Related**: Get Keys In Binary Search Tree In Given Range

>Get the list of keys in a given binary search tree in a given range[min, max] in ascending order, both min and max are inclusive.

```java
  public List<Integer> getRange(TreeNode root, int min, int max) {
    List<Integer> res = new ArrayList<Integer>();
    if (root == null) {
      return res;
    }
    getRange(root, min, max, res);
    return res;
  }
  public void getRange(TreeNode root, int min, int max, List<Integer> res) {
    if (root == null) {
      return;
    }
    if (root.key >= min) {
      getRange(root.left, min, max, res);
    }
    if (root.key >= min && root.key <= max) {
      res.add(root.key);
    }
    if (root.key <= max) {
      getRange(root.right, min, max, res);
    }
  }
```

<br>
<br>

###95 Unique Binary Search Trees

> Given n, how many structurally unique BST's (binary search trees) that store values 1...n?

> For example,

> Given n = 3, there are a total of 5 unique BST's.

<pre>


   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3


</pre>



**Idea**: Consider a binary rooted at certain node node1, the number of unique binary trees would be #left sub-BST * #right sub-BST. So the total number of binary search tree would be sum of binary trees rooted at each node. 

This is similar to the [catalan numbers](http://en.wikipedia.org/wiki/Catalan_number). In this problem, we could use dynamic programming to store middle results.  

Cn+1 = Sum (ci * c[n-i]), i = 0, 1, 2,....nwq   
  

**Java code**:

```java
    public int numTrees(int n) {
       int[] res = new int[n+1];
       res[0] = 1;
       res[1] = 1;
       for (int i = 2; i <= n; i++) {
           for (int j = 0; j < i; j++) {
               res[i] += res[j] * res[i - j - 1];
           }
       }
       return res[n];
    }

```


<br>
<br>


###96 Unique Binary Search Trees II

> Given n, generate all structurally unique BST's (binary search trees) that store values 1...n.

<pre>
For example,
Given n = 3, your program should return all 5 unique BST's shown below.

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
confused what "{1,#,2,3}" means? > read more on how binary tree is serialized on OJ.

</pre>

**Idea**: The basic Idea is same as [95 Unique Binary Search Trees](#95-unique-binary-search-trees). We still need to create the left sub-BST and right sub-BST, then combine it with the root. 

This is a bottom up approach, we create the trees from leaves. The time complexity is not polynomial. 

**Attention**: In order to create all the combinations in the for loop. So when left subtree is null, we still need to add null to list. 

```java
	public List<TreeNode> generateTrees(int n) {
        List<TreeNode> res = new ArrayList<TreeNode>();
        if (n < 0) {
           return res;
        }  
        return generateTrees(1, n);
    }
    public List<TreeNode> generateTrees(int l,  int r) {
        List<TreeNode> res = new ArrayList<TreeNode>();
        if (l > r) {
            res.add(null);
            return res;
        }
        for (int i = l; i <= r; i++) {
            List<TreeNode> lList = generateTrees(l, i-1);
            List<TreeNode> rList = generateTrees(i+1, r);
            for (int j = 0; j < lList.size(); j++) {
                for (int k = 0; k < rList.size(); k++) {
                    TreeNode root = new TreeNode(i);
                    root.left = lList.get(j);
                    root.right = rList.get(k);
                    res.add(root);
                }
            }
        }
        return res;
    }
```




<br>
<br>




###98 Validate Binary Search Tree

>Given a binary tree, determine if it is a valid binary search tree (BST).

Assume a BST is defined as follows:

The left subtree of a node contains only nodes with keys **less than** the node's key.
The right subtree of a node contains only nodes with keys **greater than** the node's key.
Both the left and right subtrees must also be binary search trees.

**Idea**: We know that if a tree is a binary search tree, then it's inorder traversal is sequential. Thus we can traverse the tree inorder to check if everynode's predecessor is less than the node. We can also traverse the tree inorder and save the sequence, then check if there is out of order nodes. But it will require addtional space. 

**Time**: O(n) **Space**: O(lgn)


**Note**: Remember to check if pre is null before compare pre.val and root.val

```java
  public boolean isValidBST(TreeNode root) {
    // Write your solution here.
    if (root == null) {
      return true;
    }
    boolean[] res = new boolean[1];
    res[0] = true;
    isBST(root, res, new TreeNode[1]);
    return res[0];
  }
  
  public void isBST(TreeNode root, boolean[] res, TreeNode[] pre) {
    if (root == null) {
      return;
    }
    isBST(root.left, res, pre);
    if (pre[0] != null && pre[0].val >= root.val) {
      res[0] = false;
    }
    pre[0] = root;
    isBST(root.right, res, pre);
  }
```


**Other idea**: We record the lower bound and upper bound for each node. If a node's value is not between the lower bound and upper bound, return false. There is a problem with this method: if the tree contains nodes with value of Integer.MIN_VALUE AND Integer.MAX_VALUE. 

```java

    public boolean isValidBST(TreeNode root) {
        return isValidBST(root, Integer.MIN_VALUE, Integer.MAX_VALUE);
    }
    public boolean isValidBST(TreeNode root, int min, int max) {
        if (root == null) {
            return true;
        }
        if (root.val <= min || root.val >= max) {
            return false;
        }
        return isValidBST(root.left, min, root.val) && isValidBST(root.right, root.val, max);
    }
	

```

**Wrong answer**: The following code just check if each node maintains node.val > node.left.val and node.val < node.right.val. However, even though each node satisfies this condition, it might not be a binary search tree. Eg: 10,5,15,#,#,6,20

```java
  public boolean isValidBST1(TreeNode root) {
        if (root == null || (root.left == null && root.right == null)) {
            return true;
        }
        if ((root.left != null && root.left.val >= root.val) || (root.right != null && root.right.val <= root.val)) {
            return false;
        }
        return isValidBST(root.left) && isValidBST(root.right);
   }

```
<br>
<br>


###99 Recover Binary Search Tree

> Two elements of a binary search tree (BST) are swapped by mistake.

> Recover the tree without changing its structure.

> Note:

> A solution using O(n) space is pretty straight forward. Could you devise a constant space solution?

**Idea**: We can traverse the tree inorder to find the misplaced TreeNode. If we use recursion, we need O(n) space. If we use morris traversal, we can solve this problem in constant space. 


**Solution 1: O(n) space.**

```java
    public void recoverTree(TreeNode root) {
        if (root == null) {
            return;
        }
        TreeNode[] arr = new TreeNode[3];
        recoverTree(root, arr);
        int temp = arr[0].val;
        arr[0].val = arr[1].val;
        arr[1].val = temp;
    }
    
    public void recoverTree(TreeNode root, TreeNode[] arr) {
        if(root == null) {
            return;
        }
        recoverTree(root.left, arr);
        if (arr[2] != null && arr[2].val > root.val) {
            if(arr[0] == null) {
                arr[0] = arr[2];
            }
            arr[1] = root;
        }
        arr[2] = root;
        recoverTree(root.right, arr);
    }

```

**Solution2 : morris**

```java
	/*Morris traversal O(1) */
       public void recoverTree(TreeNode root) {
        if (root == null) {
            return;
        }
        TreeNode[] arr = new TreeNode[3];
        recoverTree(root, arr);
        int temp = arr[0].val;
        arr[0].val = arr[1].val;
        arr[1].val = temp;
    }
    
    public void recoverTree(TreeNode root, TreeNode[] arr){
        if(root == null) {
            return;
        }

        TreeNode pre = null; /* predecessor*/
        TreeNode previous = null;
        while (root != null) {
            if (root.left == null) {
                if (previous != null && previous.val > root.val) {
                    if(arr[0] == null) {
                        arr[0] = previous;
                    }
                    arr[1] = root;
                }
                previous = root;
                root = root.right;
            }else{
                /* find predecessor */
                pre = root.left;
                while (pre.right != null && pre.right != root) {
                    pre = pre.right;
                }

                /* if predecessor's right == null, set current node as its right child */
                if (pre.right == null) {
                    pre.right = root;
                    root = root.left;
                } else {
                    /* recover tree, when return to parent node the second time */
                    pre.right = null;
                    if (previous != null && previous.val > root.val) {
                        if(arr[0] == null) {
                            arr[0] = previous;
                        }
                        arr[1] = root;
                    }   
                    previous = root;
                    root = root.right;
                }
            }
        }
    }
```

<br>
<br>


###100 Same Tree

> Given two binary trees, write a function to check if they are equal or not.

>Two binary trees are considered equal if they are structurally identical and the nodes have the same value.


**Idea**: We can choose any traverse method to visit each node and check if they are the same. We need to check the val, the left child and the right child.

**Java code**:


```java
 public boolean isSameTree(TreeNode one, TreeNode two) {
    if (one == null && two == null) {
      return true;
    }
    if (one == null || two == null || one.val != two.val) {
      return false;
    }
    return isSameTree(one.left, two.left) && isSameTree(one.right, two.right);
  }
```

**Time complexity analysis**:

- 1) way 1 : T(n) = 2 T(n/2) + 1. Use master theory, we got T = O(n)
- 2) way 2 : recursion tree. T(n) = 2 ^ log2(n) = O(n)

<br>

<br>

**Related**: Tweaked Identical Binary Trees

> Determine whether two given binary trees are identical assuming any number of ‘tweak’s are allowed. A tweak is defined as a swap of the children of one node in the tree

**Idea**: basically, it's the same idea with same tree or symmetric tree. If it's same or tweaked, we return true

**solution**:

```java
  public boolean isTweakedIdentical(TreeNode one, TreeNode two) {
    if (one == null && two == null) {
      return true;
    }
    if (one == null || two == null || one.key != two.key) {
      return false;
    }
    return (isTweakedIdentical(one.left, two.left) && isTweakedIdentical(one.right, two.right)) || (isTweakedIdentical(one.right, two.left) && isTweakedIdentical(one.left, two.right));
  }

```

**Time complexity analysis**:

- 1) way 1 : T(n) = 4 T(n/2) + 1. Use master theory, we got T = O(n^2)
- 2) way 2 : recursion tree. T(n) = 4 ^ log2(n) = 2 ^ (2 log2(n)) = 2 ^ log2(n^2) = O(n^2)

<br>
<br>



###101 Symmetric Tree

> Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).

<pre>
For example, this binary tree is symmetric:

    1
   / \
  2   2
 / \ / \
3  4 4  3
But the following is not:
    1
   / \
  2   2
   \   \
   3    3

</pre>
Note:
Bonus points if you could solve it both recursively and iteratively.

**Idea**: 

- 1) root is null, then return true
- 2) left and right child are both null return true;
- 3) left and right only one is null, return false
- 4) left and right both exist, check if their value equals
- 5) go to next level, check the relatin of left.left and right.right , left.right and right.left

**Solution 1**: Recursive

```java
  public boolean isSymmetric(TreeNode root) {
    if (root == null || (root.left == null && root.right == null)) {
      return true;
    }
    return isSymmetric(root.left, root.right);
  }
  
  public boolean isSymmetric(TreeNode l, TreeNode r) {
    if (l == null && r == null) {
      return true;
    }
    if (l == null || r == null || l.val != r.val) {
      return false;
    }
    return isSymmetric(l.left, r.right) && isSymmetric(l.right, r.left);
    
  }

```

**Solution 2**: Iterative

```java
  public boolean isSymmetric(TreeNode root) {
    if (root == null || (root.left == null && root.right == null)) {
      return true;
    }
    if (root.left == null || root.right == null) {
        return false;
    }
    Queue<TreeNode> queueL = new LinkedList<TreeNode>();
    Queue<TreeNode> queueR = new LinkedList<TreeNode>();
    queueL.offer(root.left);
    queueR.offer(root.right);
    while (!queueL.isEmpty() && !queueR.isEmpty()) {
        TreeNode l = queueL.poll();
        TreeNode r = queueR.poll();
        if (l.val != r.val) {
            return false;
        }
        if (l.left != null) {
            if (r.right == null) {
                return false;
            }
            queueL.offer(l.left);
            queueR.offer(r.right);
        } else {
            if (r.right != null) {
                return false;
            }
        }
        if (l.right != null) {
            if (r.left == null) {
                return false;
            }
            queueL.offer(l.right);
            queueR.offer(r.left);
        } else {
            if (r.left != null) {
                return false;
            }
        }
    } 
    return true;
  }
```

**Solution 3**: concise version

```java
public boolean isSymmetric(TreeNode root) {
    if (root == null || (root.left == null && root.right == null)) {
      return true;
    }
    Queue<TreeNode> queueL = new LinkedList<TreeNode>();
    Queue<TreeNode> queueR = new LinkedList<TreeNode>();
    queueL.offer(root.left);
    queueR.offer(root.right);
    while (!queueL.isEmpty() && !queueR.isEmpty()) {
        TreeNode l = queueL.poll();
        TreeNode r = queueR.poll();
        if (l == null && r == null) {
            continue;
        }
        if ((l == null && r != null) || (l != null && r == null) || l.val != r.val) {
            return false;
        }
        queueL.offer(l.left);
        queueR.offer(r.right);
        queueL.offer(l.right);
        queueR.offer(r.left);
    } 
    return true;
  }
```

<br>
<br>
###102 Binary Tree Level Order Traversal

>Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).

<pre>
For example:
Given binary tree {3,9,20,#,#,15,7},
    3
   / \
  9  20
    /  \
   15   7
return its level order traversal as:
[
  [3],
  [9,20],
  [15,7]
]
</pre>

**Idea**: 

-1) Breadth first search -> Queue

-2) each time not just poll one node from queue, but poll a level of nodes from queue


**Solution**:

```java
public List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> res = new ArrayList<List<Integer>>();
    if (root == null) {
        return res;
    }
    Queue<TreeNode> queue = new LinkedList<TreeNode>();
    queue.offer(root);
    while (!queue.isEmpty()) {
        int size = queue.size();
        List<Integer> cur = new ArrayList<Integer>();
        for (int i = 0; i < size; i++) {
            TreeNode temp = queue.poll();
            if (temp.left != null) {
                queue.offer(temp.left);
            }
            if (temp.right != null) {
                queue.offer(temp.right);
            }
            cur.add(temp.val);
        }
        res.add(cur);
    }
    return res;
}

```


<br>
<br>

###103 Binary Tree Zigzag Level Order Traversal

>Given a binary tree, return the zigzag level order traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between).


<pre>
For example:
Given binary tree {3,9,20,#,#,15,7},
    3
   / \
  9  20
    /  \
   15   7
return its zigzag level order traversal as:
[
  [3],
  [20,9],
  [15,7]
]

</pre>


**Idea**: Maintain a boolean variable to help indicate the add direction of the zigzag. Two cases based on this boolean variable, add at the end or add at index 0;


**Solution**:


```java
public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
    List<List<Integer>> res = new ArrayList<List<Integer>>();
    if (root == null) {
        return res;
    }
    Queue<TreeNode> queue = new LinkedList<TreeNode>();
    queue.offer(root);
    boolean zig = true;
    while (!queue.isEmpty()) {
        int size = queue.size();
        List<Integer> cur = new ArrayList<Integer>();
        for (int i = 0; i < size; i++) {
            TreeNode temp = queue.poll();
            if (temp.left != null) {
                queue.offer(temp.left);
            }
            if (temp.right != null) {
                queue.offer(temp.right);
            }
            if (zig) {
                cur.add(temp.val);
            } else {
                cur.add(0, temp.val);
            }
        }
        res.add(cur);
        zig = !zig;
    }
    return res;
}
```
<br>
<br>

###104 Maximum Depth of Binary Tree


**Idea**:

- 1) solution 1: recursive, max depth of root = max(max depth of left child, max depth of right child) + 1

- 2) the levels of the binary search tree is its max depth

**Solution 1**: recursive

```java
public int maxDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }
    return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
}
```

**Solution 2**: iterative

```java
public int maxDepth(TreeNode root){
    if(root == null) {
        return 0;
    }
    int level = 0;
    Queue<TreeNode> queue = new LinkedList<TreeNode>();
    queue.offer(root);
    while (!queue.isEmpty()) {
        int size = queue.size();
        for (int i = 0; i < size; i++) {
            TreeNode temp = queue.poll();
            if (temp.left != null) {
                queue.offer(temp.left);
            }
            if (temp.right != null) {
                queue.offer(temp.right);
            }
        }
        level++;
    }
    return level;
    }
```
<br>
<br>

###105 Construct Binary Tree from Preorder and Inorder Traversal

>Given preorder and inorder traversal of a tree, construct the binary tree.

Note:
You may assume that duplicates do not exist in the tree.



**Idea**: 

**Solution 1**:

- 1) in preorder, the first element is root, then left subtree, right subtree

- 2) in inorder, left subtree, root, right subtree. 

Thus we can use this index to recursively build the binary search tree. 

**Time complexity**:

T(n) = 2 T(n/2) + O(n). Solve it we get T(n) = O(nlgn)

**Solution 2**:

If we use a map to store the value and index relation of inorder array, we can get a better time complexity:

**Time** :

T(n) = 2 T(n/2) + 1. Solve it we get T(n) = O(n)


**Solution 1 code **:

```java
public TreeNode buildTree(int[] preorder, int[] inorder) {
    if (preorder == null || preorder.length == 0) {
        return null;
    }
    return buildTree(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1);
}

public TreeNode buildTree(int[] preorder, int pStart, int pEnd, int[] inorder, int iStart, int iEnd) {
    if (pStart > pEnd) {
        return null;
    }
    TreeNode root = new TreeNode(preorder[pStart]);
    int rootIndex = 0;
    for (int i = iStart; i <= iEnd; i++) {
        if (preorder[pStart] == inorder[i]) {
            rootIndex = i;
            break;
        }
    }
    int leftLen = rootIndex - iStart;
    root.left  = buildTree(preorder, pStart + 1, pStart + leftLen, inorder, iStart, rootIndex - 1);
    root.right = buildTree(preorder, pStart + leftLen + 1, pEnd, inorder, rootIndex + 1, iEnd);
    return root;
}
```

<br>


**Solution 2 code**:

```java
public TreeNode buildTree(int[] preorder, int[] inorder) {
    if (preorder == null || preorder.length == 0) {
        return null;
    }
    Map<Integer, Integer> map = new HashMap<Integer, Integer>();
    for (int i = 0; i < inorder.length; i++) {
        map.put(inorder[i], i);
    }
    return buildTree(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1, map);
}

public TreeNode buildTree(int[] preorder, int pStart, int pEnd, int[] inorder, int iStart, int iEnd, Map<Integer, Integer> map) {
    if (pStart > pEnd) {
        return null;
    }
    TreeNode root = new TreeNode(preorder[pStart]);
    int rootIndex = map.get(preorder[pStart]);
    int leftLen = rootIndex - iStart;
    root.left  = buildTree(preorder, pStart + 1, pStart + leftLen, inorder, iStart, rootIndex - 1, map);
    root.right = buildTree(preorder, pStart + leftLen + 1, pEnd, inorder, rootIndex + 1, iEnd, map);
    return root;
}
```



<br>
<br>

###106 Construct Binary Tree from Inorder and Postorder Traversal

>Given inorder and postorder traversal of a tree, construct the binary tree.

Note:
You may assume that duplicates do not exist in the tree.



**Idea**: Here is the O(n) solution use hashmap, if you want a O(nlgn) solution, you can refer to 105 Construct Binary Tree from Preorder and Inorder Traversal.

For inorder: left subtree | root | right subtree
For postorder: left subtree | right subtree | root

Thus we can use the index relation to recursively build the tree. s

**Solution**:

```java
public TreeNode buildTree(int[] inorder, int[] postorder) {
    if (inorder.length == 0) {
        return null;
    }
    Map<Integer, Integer> map = new HashMap<Integer, Integer>();
    for (int i = 0; i < inorder.length; i++) {
        map.put(inorder[i], i);
    }
    return buildTree(inorder, 0, inorder.length - 1, postorder, 0, postorder.length - 1, map);
}
public TreeNode buildTree(int[] inorder, int iStart, int iEnd, int[] postorder, int pStart, int pEnd, Map<Integer, Integer> map) {
    if (iStart > iEnd) {
        return null;
    }
    TreeNode root = new TreeNode(postorder[pEnd]);
    int rootIndex = map.get(postorder[pEnd]);
    root.left = buildTree(inorder, iStart, rootIndex - 1, postorder, pStart, pStart + (rootIndex - 1 - iStart), map);
    root.right = buildTree(inorder, rootIndex + 1, iEnd, postorder, pStart + (rootIndex - iStart), pEnd - 1, map);
    return root;
}
```

<br>
<br>

###107 Binary Tree Level Order Traversal II

**Idea**: The solution below is same with 102  Binary Tree Level Order Traversal. The only difference is that when insert into list of list, we insert at index 0. Is there any other better solution other than the this method and recursion version of level order traverse? 


**Solution**:

```java
public List<List<Integer>> levelOrderBottom(TreeNode root) {
    List<List<Integer>> res = new ArrayList<List<Integer>>();
    if (root == null) {
        return res;
    }
    Queue<TreeNode> queue = new LinkedList<TreeNode>();
    queue.offer(root);
    while (!queue.isEmpty()) {
        int size = queue.size();
        List<Integer> cur = new ArrayList<Integer>();
        for (int i = 0; i < size; i++) {
            TreeNode temp = queue.poll();
            if (temp.left != null) {
                queue.offer(temp.left);
            }
            if (temp.right != null) {
                queue.offer(temp.right);
            }
            cur.add(temp.val);
        }
        res.add(0, cur);
    }
    return res;
}
```


<br>
<br>


    
###108 Convert Sorted Array to Binary Search Tree  

>Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.

**Idea**: 

Just find the mid of the list each time and create the tree from root.

root = mid

root.left = mid of (0, mid -1)

root.right = mid of (mid + 1, end)

**Time: O(n)**, because we need to traverse all the nodes. 

**Space** O(lg(n)) for recursion. 
```java

    public TreeNode sortedArrayToBST(int[] nums) {
        if (nums == null || nums.length == 0) {
            return null;
        }
        return sortedArrayToBST(nums, 0, nums.length - 1);
    }
    
    public TreeNode sortedArrayToBST(int[] nums, int start, int end) {
        if (start > end) {
            return null;
        }
        int mid = start + (end - start) / 2;
        TreeNode root = new TreeNode(nums[mid]);
        root.left = sortedArrayToBST(nums, start, mid - 1);
        root.right = sortedArrayToBST(nums, mid + 1, end);
        return root;
    }
```


<br>
<br>
 
###109 Convert Sorted List to Binary Search Tree
>Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.

**Idea**: 

1) solution1: Bottom-up

The list is sorted and we need to convert it to a **balanced BST**. When visit the linkedlist, we can only visit node by node. Thus we visit the nodes in ascending order: **Inorder Traversal !**. Thus, we create the binary tree **Bottom-up**. The bottom-up approach enables us to access the list in its order while creating nodes.

**Time O(n)**

**Space**: O(n) + O(lgn) = O(n)


2) solution2 : Top-down

Just find the mid of the list each time and create the tree from root.
root = mid
root.left = mid of (0, mid -1)
root.right = mid of (mid + 1, end)

**Time: O(nlgn)**  T(n) = 2 * T(n/2) + O(n). Solve it we get T(n) = O(nlgn)

**Space**: O(n) + O(lgn) = O(n)

3) solution3: 

Store all the nodes in an array, then use the array to create the BST. just like the method in  * [108 Convert Sorted Array to Binary Search Tree](#108-convert-sorted-array-to-binary-search-tree). However, not recommend this method. If we do in this way, then this question is meaningless. 

**Time: O(n)**

**Space**: O(n) + O(lgn) = O(n)

*Solution1 code:*

<br>
```java
public TreeNode sortedListToBST(ListNode head) {
    if (head == null) {
        return null;
    }
    int len = 0;
    ListNode temp = head;
    while (temp != null) {
        temp = temp.next;
        len++;
    }
    ListNode[] h = new ListNode[1];
    h[0] = head;
    return sortedListToBST(h, 0, len - 1);
}

public TreeNode sortedListToBST(ListNode[] h, int start, int end) {
    if (start > end) {
        return null;
    }
    int mid = start + (end - start) / 2;
    TreeNode left = sortedListToBST(h, start, mid - 1);
    TreeNode root = new TreeNode(h[0].val);
    h[0] = h[0].next;
    root.left = left;
    root.right = sortedListToBST(h, mid + 1, end);
    return root;
}
	 
```		 
*solution 2 code*

```java
public TreeNode sortedListToBST(ListNode head) {
    if(head == null) {
        return null;
    }
    if(head.next == null) {
        return new TreeNode(head.val);
    }
    ListNode pre = getMidPre(head);
    ListNode mid = pre.next;
    pre.next = null;
    TreeNode root= new TreeNode(mid.val);
    root.left = sortedListToBST(head);
    root.right = sortedListToBST(mid.next);
    return root;
 }
 
 public ListNode getMidPre(ListNode head) {
    ListNode fast = head;  
    ListNode pre = head;  
    while (fast!=null) {  
        fast = fast.next;  
        if (fast != null) {
            fast = fast.next;  
            pre = head;  
            head = head.next;  
        } 
    }  
    return pre;  
 }

```			 	 


<br>
<br>

###110 Balanced Binary Tree

>Given a binary tree, determine if it is height-balanced.

>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.

**Idea**: Check the height diffrence of  subtrees. If difference greater than 1, return false

**Solution 1** : time O(nlgn)

**Time analysis**: 

- 1) master theory: getHeight complexity is O(n), thus T(n) = 2T(n/2) + n. Solve it we get T = O(nlgn)
- 2) recursion tree: O(n) + O(n) ......., lgn layers. Thus the total time is nlgn

```java
  public boolean isBalanced(TreeNode root) {
    // Write your solution here.
    if (root == null) {
      return true;
    }
    if (Math.abs(getHeight(root.left) - getHeight(root.right)) > 1) {
      return false;
    }
    return isBalanced(root.left) && isBalanced(root.right);
  }
  
  public int getHeight(TreeNode root) {
    if (root == null) {
      return 0;
    }
    return Math.max(getHeight(root.left), getHeight(root.right)) + 1;
  }
```
<br>
**Solution 2**: time : O(n)

In this method, we omit repeated getheight part. Thus the time is better than the fist solution

**Time analysis**: 

- 1) master theory: thus T(n) = 2T(n/2) + 1. Solve it we get T = O(n)
- 2) recursion tree: 2 ^ lgn  = O(n)


```java
    public boolean isBalanced(TreeNode root){
        return helper(root) >= 0;
    }

    public int helper(TreeNode root){
        if (root == null) {
            return 0;
        }
        int left = helper(root.left);
        int right = helper(root.right);
        if (left < 0 || right < 0 || Math.abs(left - right) > 1) {
            return -1;
        }
        return Math.max(left, right) + 1;
    }
```
<br>
<br>

###111 Minimum Depth of Binary Tree

>Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.

**Idea**: The * [104 Maximum Depth of Binary Tree](#104-maximum-depth-of-binary-tree) let us to calculate the max depth of the binary tree. 

Thus max depth = Math.max(maxDepth(root.left), maxDepth(root.left)) + 1

In this problem, we need to calculate the minumum depth. Is the minimum depth = Math.min(minDepth(root.left), minDepth(root.left)) + 1.

This is partly true. When the left child and right child all exist, this is true. What if only left child or right child exist? 

In these two cases:

min depth = minDepth(root.left) + 1 when right child does not exist

min depth = minDepth(root.right) + 1 when left child does not exist


**Solution**:


```java
public int minDepth(TreeNode root) {
    if (root == null) {
      return 0;
    }
    if (root.left == null) {
        return minDepth(root.right) + 1;
    }
    if (root.right == null) {
        return minDepth(root.left) + 1;
    }
    return Math.min(minDepth(root.left), minDepth(root.right)) + 1;
}
```

<br>
<br>

###114 Flatten Binary Tree to Linked List
>Given a binary tree, flatten it to a linked list **in-place**.

<pre>
For example,
Given

         1
        / \
       2   5
      / \   \
     3   4   6
The flattened tree should look like:
   1
    \
     2
      \
       3
        \
         4
          \
           5
            \
             6

</pre>


**Idea**: From the structure of the original tree and result tree, we know that we need to traverse the tree preorder. We can solve it recursively or use a stack to record the right child. 

**Attention**: 

- 1) we can use a fake node pre so that each time we can add the current node to the right of pre, set pre.left = null and recursively solve this problem. 

- 2) We need to save the right child, because the right child has changed when we visit the left child. 

*Reversion code* : 

```java
public void flatten(TreeNode root){
    if (root == null) {
        return;
    }
    TreeNode[] pre = new TreeNode[1];
    pre[0] = new TreeNode(-1);
    flatten(root, pre);
}

public void flatten(TreeNode root, TreeNode[] pre) {
    if (root == null) {
        return;
    }
    TreeNode right = root.right;
    pre[0].left = null;
    pre[0].right = root;
    pre[0] = root;
    flatten(root.left, pre);
    flatten(right, pre);
}
```

*Stack*:

```java
public void flatten(TreeNode root){
   if (root == null) {
       return;
   }
   TreeNode pre = new TreeNode(-1);
   Stack<TreeNode> stack = new Stack<TreeNode>();
   while (!stack.isEmpty() || root != null) {
       if (root != null) {
           pre.right = root;
           pre.left = null;
           pre = root;
           stack.push(root.right);
           root = root.left;
       } else {
           root = stack.pop();
       }
   }
}


```



<br>
<br>

###118 Pascal Triangle

>Given numRows, generate the first numRows of Pascal's triangle.

<pre>
For example, given numRows = 5,
Return

[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]

</pre>


**Idea**: First row : 1. Then each row is calculated based on the last row. In each row the first element and the last element is 1. Thus val = j == 0 || j == pre.size() ? 1 : pre.get(j-1)+pre.get(j);

```java
            public List<List<Integer>> generate(int numRows) {
	        List<List<Integer>> list = new ArrayList<List<Integer>>();
	        if(numRows <= 0) return list;
	        List<Integer> firstR = new ArrayList<Integer>();
	        firstR.add(1);
	        list.add(firstR);
	        for(int i = 1; i < numRows; i++){
	            List<Integer> current = new ArrayList<Integer>();
	            List<Integer> pre = list.get(list.size()-1);
	            for(int j = 0; j <= pre.size(); j++){
	                int val = j == 0 || j == pre.size() ? 1 : pre.get(j-1)+pre.get(j);
	                current.add(val);
	            }
	            list.add(current);
	        }
	        return list;
	    }
	    

```


<br>
<br>


###119 Pascal Triangle II

>Given an index k, return the kth row of the Pascal's triangle.

For example, given k = 3,
Return [1,3,3,1].

Note:
Could you optimize your algorithm to use only O(k) extra space?

**Idea**: If we can only use O(k) space, then we need to store all rows info in a single array. So the current row is calculated based on the last row. Eg: the last row is 1 2 1, we need to replace it with 1 3 3 1. We can ignore the first 1. Then 3 = 1 + 2 = pre + list.get(j). We need to store the current elment before we overwrite it. 

If there is no other requirements, then we can just use the result in [118 Pascal Triangle](#118-pascal-triangle) and get the last row. 


**Attention**:

- 1) k = 3, we return the fourth row.
- 2) we need to store the current elment before we overwrite it. 

<br>

```java
     public List<Integer> getRow(int rowIndex) {
	List<Integer> list = new ArrayList<Integer>();
    	if(rowIndex < 0) return list;
    	list.add(1);
    	for(int i = 0; i < rowIndex; i++){
    	    int pre = 1;
    	    int current = 0;
    	    for(int j = 0; j < list.size(); j++){
    	        if(j == 0) continue;
    	        current = list.get(j);
    	        list.set(j, pre + list.get(j));
    	        pre = current;
    	    } 
    	    list.add(1);
    	}
        return list;
	}

```


<br>
<br>

###120 Triangle

>Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.

<pre>
For example, given the following triangle
[
     [2],
    [3,4],
   [6,5,7],
  [4,1,8,3]
]
The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).

Note:
Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.
</pre>

**Idea**: Begin from the second-last layer, calculate the min sum of the last layer and last second layer, then continue the second-last layer and third-last layer....eg: the sum of last layer and last-second layer: min(4, 1) + 6, min(1, 8) + 5, min(8, 3) + 7. If we are only allowed to use O(n) space, then we need to replace the sum each time.

For example: Assume we use int[] res = new int[triangle.get(triangle.size()-1).size()] to store the sum

<pre>

Original triangle:             

[							   
     [2],					   
    [3,4],					  
   [6,5,7],					   
  [4,1,8,3]                  
] 


res array:
11
9, 10
7, 6, 10
4, 1, 8, 3

</pre>

**Space**: O(n)


We can also calculate from the top layer, then go down. It's similar to the method above. It's easier to handle the index if we begin from the last layer.

```java
	public int minimumTotal(List<List<Integer>> triangle) {
	    if(triangle == null || triangle.size() == 0) return 0;
	    int[] res = new int[triangle.get(triangle.size()-1).size()];
	    for(int i = 0; i < res.length; i++){
	        res[i] = triangle.get(triangle.size()-1).get(i);
	    }
	    for(int i = triangle.size()-2; i >= 0; i--){
	        List<Integer> current = triangle.get(i);
	        for(int j = 0; j < current.size(); j++){
	            res[j] = Math.min(res[j], res[j+1]) + current.get(j);
	        }
	    }
	    return res[0];
	 }
```

**Solution 2**: From top to bottom:

```java
	/* from top to bottom */
	 public int minimumTotal1(List<List<Integer>> triangle) {
		   if(triangle == null || triangle.size() == 0) return 0;
		   int[] sum = new int[triangle.get(triangle.size()-1).size()];
		   sum[0] = triangle.get(0).get(0);
		   int min = Integer.MAX_VALUE;
		   for(int i = 1; i < triangle.size(); i++){
		       List<Integer> cur = triangle.get(i);
		       for(int j = cur.size() -1 ; j >= 0; j--){
		          if(j == cur.size()-1) sum[j] = cur.get(j) + sum[j-1];
		          else if(j == 0) sum[j] = cur.get(j) + sum[0];
		          else sum[j] = cur.get(j) + Math.min(sum[j], sum[j-1]);
		       }
		   }
		   for(int i = 0; i < sum.length; i++){
		       if(min > sum[i]) min = sum[i];
		   }
		   return min;
		 }
    


```



<br>
<br>

###121 Best Time to Buy and Sell Stock
>Say you have an array for which the ith element is the price of a given stock on day i.

> If you were only permitted to complete **at most one transaction** (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.

**Idea:** We are allowed at most one transaction. Thus we only need to maintain a local  min stock price before prices[i]. Traverse prices one pass to get the max profit.

**max = Math.max(max, prices[i] - min)** 

**min = Math.min(min, prices[i])**

**Time complexity**: O(n)
 
**Space** : O(1)

```java
	public int maxProfit(int[] prices){
		if(prices == null || prices.length == 0) return 0;
		int max = 0;
		int min = prices[0];
		for(int i = 1; i < prices.length; i++){
			max = Math.max(max, prices[i] - min);
			min = Math.min(min, prices[i]);
		}
		return max;
	}
```



	
<br>
<br>

###122 Best Time to Buy and Sell Stock II

>Say you have an array for which the ith element is the price of a given stock on day i.

>Design an algorithm to find the maximum profit. You may complete **as many transactions** as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).

**Idea:** We are allowed as many transactions. Thus we only need to each neighbor pair, if prices[i] > prices[i-1], we add the difference to our result. We can get the max one pass. 

**dif = Math.max(0, prices[i] - prices[i-1])** 

**max = max + dif** 

**Time complexity**: O(n) 

**Space** : O(1)
```java
	public int maxProfit(int[] prices){
		int max = 0;
		int dif = 0;
		for(int i = 1; i < prices.length; i++){
			dif = Math.max(0, prices[i] - prices[i-1]);
			max = max + dif;
		}
		return max;
	}
```	

<br>
<br>

###123 Best Time to Buy and Sell Stock III

>Say you have an array for which the ith element is the price of a given stock on day i. 
> 
>Design an algorithm to find the maximum profit. You may complete **at most two transactions**.

>Note:
>You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).

**Idea:** We are only allowed  at most two transactions. Thus, we can use two arrays to record the max profit before profits[i], including i, denote as l[i], and max profits after profits[i], including i, denote as r[i]. Then find the max of l[i] + r[i]. 

**Time complexity**: O(n) 

**Space** : O(n)
```java
	public int maxProfit(int[] prices){
		if(prices == null || prices.length <= 1) return 0;
		int[] l = new int[prices.length];
		int[] r = new int[prices.length];
		int max = 0;
		int min = prices[0];
		for(int i = 1; i < prices.length; i++){
			max = Math.max(max, prices[i] - min);
			min = Math.min(min, prices[i]);
			l[i] = max;
		}
		int maxR = prices[prices.length-1];
		max = 0;
		for(int i = prices.length - 2; i >= 0; i--){
			max = Math.max(max, maxR - prices[i]);
			maxR = Math.max(maxR, prices[i]);
			r[i] = max;
		}
		max = 0;
		for(int i = 0; i < prices.length; i++){
			max = Math.max(max, l[i] + r[i]);
		}
		return max;
	}
```	
**Another solution:** 

global[i][j]: denotes max profit, at most j transactions before day i: 

**global[i][j]=max(local[i][j],global[i-1][j])**

local[i][j]: denotes max profit, at most j transactions before day i, and last transaction is saled on day i: 

**local[i][j]=max(global[i-1][j-1]+max(diff,0),local[i-1][j]+diff)**

From above, we know that we can change the two dimensional array to one dimensional to save space. Because we only use two rows in the two dimensional array. 

**Time complexity**: O(n) 

**Space** : O(1) (O(k), but k is 2 in this problem)
```java
	public int maxProfit1(int[] prices){
		return maxProfit(prices, 2);
	}
	public int maxProfit(int[] prices, int k){
		if(prices == null || prices.length <= 1) return 0;
		int[] global = new int[k+1];
		int[] local = new int[k+1];
		for(int i = 1; i < prices.length; i++){
			int dif = prices[i] - prices[i-1];
			for(int j = k; j >= 1; j--){
				local[j] = Math.max(global[j-1] + Math.max(dif, 0), local[j] + dif);
				global[j] = Math.max(local[j], global[j]);
			}
		}
		return global[k];
	}
```


<br>
<br>

###124 Binary Tree Maximum Path Sum

>Given a binary tree, find the maximum path sum.

>The path may start and end at any node in the tree.

<pre>
For example:
Given the below binary tree,

       1
      / \
     2   3
Return 6.

</pre>


**Idea**: In this problem, the path can start and end at any node. Thus we can divide the path into 3 parts: left path, root, right path

In the solution below, we maintain a maxSum, this is same with the general max path problem. And in the recursion part, we calculate the max left path root at a certain node and the max right path at a node, update the maxSum and return the max path of left path part or right path part. 

**Time**:

T(n) = 2T(n/2) + 1. Solve it we get T(n) = O(n)

**Solution**:


```java
public int maxPathSum(TreeNode root) {
    if (root == null) {
        return 0;
    }
    int[] maxSum = new int[1];
    maxSum[0] = root.val;
    maxPathSum(root, maxSum);
    return maxSum[0];
}

public int maxPathSum(TreeNode root, int[] maxSum) {
    if (root == null) {
        return 0;
    }
    int left = Math.max(maxPathSum(root.left, maxSum), 0);
    int right = Math.max(maxPathSum(root.right, maxSum), 0);
    maxSum[0] = Math.max(root.val + left + right, maxSum[0]);
    return root.val + Math.max(left, right);
}
```
<br>
<br>

###126 Word Ladder

>Given two words (start and end), and a dictionary, find the length of shortest transformation sequence from start to end, such that:


Only one letter can be changed at a time
Each intermediate word must exist in the dictionary
For example,

Given:

start = "hit"

end = "cog"

dict = ["hot","dot","dog","lot","log"]

As one shortest transformation is "hit" -> "hot" -> "dot" -> "dog" -> "cog",

return its length 5.

Note:

Return 0 if there is no such transformation sequence.

All words have the same length.

All words contain **only lowercase alphabetic characters**.




**Idea**: This shortest transformation ladder is just like a shortest path in a graph. We teat each string as a graph node. If these two strings only have one different char, then we add an edge to these two nodes. When we come to the end string, we find the shortest path. 

If we use bfs, we can use an additional lenqueue to record the path length of each node. 


**Attention**: 

- 1)Everytime, we visit a string in dict and add an edge, we need to remove it from dict. 
- 2) char arr = start.toCharArray() should be inside the first for while loop. Otherwise, it may change more than one character of the string. 



**Solution**:
```java
	public static int ladderLength(String start, String end, Set<String> dict) {
	        if(dict == null || dict.size() == 0 || start == null || end == null) return 0;
	        Deque<String> queue = new LinkedList<String>();
	        Deque<Integer> qlen = new LinkedList<Integer>();
	        queue.offer(start);
	        qlen.offer(1);
	        while(!queue.isEmpty()){
	            start = queue.pollFirst();
	            int len = qlen.pollFirst();
	            if(start.equals(end)) return len;
	            for(int i = 0; i < start.length(); i++){
	                char[] arr = start.toCharArray();
	                for(arr[i] = 'a'; arr[i] <='z'; arr[i]++){
	                    String s = new String(arr);
	                    if(dict.contains(s)){
	                        queue.addLast(s);
	                        qlen.addLast(len+1);
	                        dict.remove(s);
	                    }
	                }
	            }
	        }
	        return 0;
	    }
    
```

* [126 Word Ladder](#126-word-ladder)
* [127 word Ladder II](#127-word-ladder-ii)

<br>
<br>

###127 Word Ladder II

>Given two words (start and end), and a dictionary, find all shortest transformation sequence(s) from start to end, such that:

<pre>
Only one letter can be changed at a time
Each intermediate word must exist in the dictionary
For example,

Given:
start = "hit"
end = "cog"
dict = ["hot","dot","dog","lot","log"]
Return
  [
    ["hit","hot","dot","dog","cog"],
    ["hit","hot","lot","log","cog"]
  ]
Note:
All words have the same length.
All words contain only lowercase alphabetic characters.
</pre>


<br>
<span style="background-color:#303030 ">


**Idea**: Becuase we need to output all the shortest paths, thus we need to record the parent node in the path. Then build paths based on these parent nodes.

**Attention**:

- 1) we need to remove end from dict if dict contains end, otherwise, we might have duplicates.
- 2) When we find all the path to end, we can break and rebuild the paths.
- 3) We can not remove element immediately when we find an neighbors in dict, because one node might have two or more parents. Thus we need to remove it after we have build the relationships between the node and all its parents. *We can remove it at the beginning of the next while loop*
- 4) when add element to queue, check if queue has alreay contains this element.

</span>

<br>
```java
    public List<List<String>> findLadders(String start, String end, Set<String> dict) {
        List<List<String>> res = new ArrayList<List<String>>();
        if(dict == null || dict.size() == 0 || start == null || end == null) return res;
        /*if start equals end, we can return [[start, end]]*/
        if(start.equals(end)){
            List<String> temp = new ArrayList<String>();
            temp.add(start);
            temp.add(end);
            return res;
        }
        
        /*if dict contains end, remove end from dict, otherwise we might have duplicates */
        dict.remove(end); 
        
        Queue<String> queue = new LinkedList<String> ();
        
        /*store the parent node of each node*/
        Map<String, ArrayList<String>> map = new HashMap<String, ArrayList<String>>();
        queue.offer(start);
        for(String s : dict){
            map.put(s, new ArrayList<String>());
        }
        map.put(end, new ArrayList<String>());
        List<String> cur = new ArrayList<String>();
        
        while(!queue.isEmpty()){
            cur.clear();
            for(int i = 0, size = queue.size(); i < size; i++){
            	String temp = queue.poll();
                cur.add(temp);
                dict.remove(temp);
            }
            for(String s : cur){
                for(int i = 0; i < s.length(); i++){
                    char[] arr = s.toCharArray();
                    for(arr[i] = 'a'; arr[i] <= 'z'; arr[i]++){
                        String temp = new String(arr);
                        /* It's ok not add this sentence. just to jump unnecessary operations*/
                        if(temp.equals(s)) continue;
                        if(temp.equals(end)){
                            map.get(end).add(s);
                        }
                        if(dict.contains(temp)){
                            if(!map.containsKey(temp)){
                                map.put(temp, new ArrayList<String>());
                            }
                            map.get(temp).add(s);
                            if(!queue.contains(temp)) queue.offer(temp);
                        }
                    }
                }
            }
            
            if(map.get(end).size()>0) break;
        }
        
        List<String> path = new ArrayList<String>();
        path.add(end);
        buildPaths(map, res, end, start, path);
        return res;
 	}
 	
 	public void buildPaths(Map<String, ArrayList<String>> map, List<List<String>> res, String end, String start, List<String> path){
 	    if(end.equals(start)){
 	        List<String> apath = new ArrayList<String>(path);
 	        Collections.reverse(apath);
 	        res.add(apath);
 	        return;
 	    }
 	    List<String> pre = map.get(end);
 	    for(String s : pre){
 	        path.add(s);
 	        buildPaths(map, res, s, start, path);
 	        path.remove(path.size()-1);
 	    }
 	}
 	
```



<br>
<br>


###135 Candy

> There are N children standing in a line. Each child is assigned a rating value.

> You are giving candies to these children subjected to the following requirements:

> Each child must have at least one candy.

> Children with a higher rating get more candies than their neighbors.

> What is the minimum candies you must give?

**Idea**: 

- 1) Solution1 : Traverse the array two times, left to right and right to left. In the first traverse, we calculate the min candy for each child based on its left neighbor. In the right to left traverse, we calculate the min candy for each child based on its right neighbor. It's easier to use 2 array and traverse three times. We can reduce it to 1 array and 2 pass. 

**Three pass, two array**

```java

 public static int candy(int[] ratings) {
        if(ratings == null || ratings.length == 0) return 0;
        int[] left = new int[ratings.length];
        left[0] = 1;
        for(int i = 1; i < ratings.length; i++){
            if(ratings[i] > ratings[i-1]) left[i] = left[i-1] +1;
            else left[i] = 1;
        }
        int[] right = new int[ratings.length];
        right[ratings.length - 1] = 1;
        for(int i = ratings.length - 2; i >= 0; i--){
             if(ratings[i] > ratings[i+1]){
                right[i] = right[i+1] + 1;
            }else right[i] = 1;
        }
        int res = 0;
        for(int i = 0; i < ratings.length; i++){
            res += Math.max(left[i], right[i]);
        }
        return res;
    }

```

<br>

**Two pass, one array**

```java

    public static int candy(int[] ratings) {
        if(ratings == null || ratings.length == 0) return 0;
        int[] left = new int[ratings.length];
        left[0] = 1;
        for(int i = 1; i < ratings.length; i++){
            if(ratings[i] > ratings[i-1]) left[i] = left[i-1] +1;
            else left[i] = 1;
        }
        int res = left[ratings.length-1];
        for(int i = ratings.length - 2; i >= 0; i--){
            int right = 1;
            if(ratings[i] > ratings[i+1]){
                right = left[i+1] + 1;
            }
            res += Math.max(right, left[i]);
            left[i] = right;
        }
        return res;
    }

```



<br>

- 2) solution 2: Brute force. O(n ^2 )

```java

    public static int candy(int[] ratings) {
    	if(ratings == null || ratings.length == 0) return 0;
    	
    	int preRating = ratings[0],
    		count = 1,
    		preCandy = 1,
    		lastIncreasingIndex = 0,
    		lastDecreasingIndex = 0,
    		lastIncreasingCandy = 1,
    		changeFlag = 0;
    	for(int i = 1, len = ratings.length; i < len; i++){
    		if(ratings[i] >= preRating){
    			if(changeFlag == 1){				
    				if(ratings[i] == preRating){
        				/*if increasing sequence is longer than deceasing sequence */
        				if(lastIncreasingCandy > lastDecreasingIndex - lastIncreasingIndex +1){
        					count += sumTools(lastDecreasingIndex - lastIncreasingIndex);
        				}else{
            				count -= lastIncreasingCandy;
            				count += sumTools(lastDecreasingIndex - lastIncreasingIndex+1);
        				}
    					count += 1;
    					preCandy = 1;
    				}else{
        				/*if increasing sequence is longer than deceasing sequence */
        				if(lastIncreasingCandy > lastDecreasingIndex - lastIncreasingIndex +1){
        					count += sumTools(lastDecreasingIndex - lastIncreasingIndex);
        				}else{
            				count -= lastIncreasingCandy;
            				count += sumTools(lastDecreasingIndex - lastIncreasingIndex +1);
        				}
    					count += 2;
        				preCandy = 2;
    				}
    				changeFlag = 0;
        			lastIncreasingIndex = i;
        			lastIncreasingCandy = preCandy;
        			preRating = ratings[i];
    				continue;
    			}else{
    				if(ratings[i] == preRating){
    					preCandy = 1;
    				}else{
    					preCandy++;
    				}
        			count += preCandy;
        			preRating = ratings[i];
        			lastIncreasingIndex = i;
        			lastIncreasingCandy = preCandy;
    			}
    			
    		}else{
    			lastDecreasingIndex = i;
    			preRating = ratings[i];
    			changeFlag = 1;
    			continue;
    		}
    	}
    	
    	if(changeFlag == 1){
    		if(lastIncreasingCandy > lastDecreasingIndex - lastIncreasingIndex +1){
				count += sumTools(lastDecreasingIndex - lastIncreasingIndex);
			}else{
				count -= lastIncreasingCandy;
				count += sumTools(lastDecreasingIndex - lastIncreasingIndex +1);
			} 
    	}
        return count;
    }
    
    public static int sumTools(int n){
    	int sum = 0;
    	for(int i = 1; i <= n; i++ ){
    		sum += i;
    	}
    	return sum;
    }

```




<br>
<br>


###138 Copy List With Random Pointer

>A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null. Return a deep copy of the list.
 

**Idea** :

**Solution1:**Copy each node in the list, then divide the list into two lists. For example: 1->2->3, we copy nodes and the list turns to 1->1->2->2->3->3. Then we divide it into two 1->2->3

**Attention**: ***we should copy the random pointer seperatel after we copy all the nodes***. At the beginning, I thought that I can copy the random pointer at the same time and just let it pointer to the same node with the original node, when breaking the list, I change the copy node's random to origin's random's next. It works only when the node that random pointer points to is after to the current pointer. What if it is before the current node? we might not able to find the random's next because when breaking the list we have changed the structure of the list. 

**Solution2**: Use hashmap store old and copy, then copy the random pointer

***Solution1 code***
```java
    public RandomListNode copyRandomList(RandomListNode head) {
        if(head == null) return null;
        RandomListNode temp = head;
        while(temp != null){
            RandomListNode next = temp.next;
            temp.next = new RandomListNode(temp.label);
            temp.next.next = next;
            temp = next;
        }
        temp = head;
        while(temp != null){
            if(temp.random != null){
                temp.next.random = temp.random.next;
            }
            temp = temp.next.next;
        }
        RandomListNode fakeHead = new RandomListNode(-1);
        RandomListNode copy = fakeHead;
        while(head != null){
            RandomListNode next = head.next.next;
            copy.next = head.next;
            copy = copy.next;
            copy.next = null;
            head.next = next;
            head = next;
        }
        return fakeHead.next;
    }
```    
***Solution2 code***
```java
 	public RandomListNode copyRandomList1(RandomListNode head) {
        if(head == null) return null;
        RandomListNode copy = new RandomListNode(-1);
        RandomListNode temp = head;
        HashMap<RandomListNode, RandomListNode> map = new HashMap<RandomListNode, RandomListNode>();
        while(temp != null){
            copy.next = new RandomListNode(temp.label);
            map.put(temp, copy.next);
            copy = copy.next;
            temp = temp.next;
        }
        copy = map.get(head);
        RandomListNode saveHead = copy;
        while(head != null){
            copy.random = map.get(head.random);
            head = head.next;
            copy = copy.next;
        }
        return saveHead;
    }
```


<br>
<br>

###141 Linked List Cycle

>Given a linked list, determine if it has a cycle in it.

Follow up:
Can you solve it without using extra space?

**Idea**: Use two pointers, one pointer move one step each time, the other pointer move two step each time. If they encounter, then a cycle exist.

**Attention**: when check if they encounter, if check if they are null! Otherwise, if(f.equals(s)) will have null pointer. 
```java
    public boolean hasCycle(ListNode head) {
        if(head == null) return false;
        ListNode f = head;
        ListNode s = head;
        while(f != null){
            f = f.next;
            if(f != null) f = f.next;
            s = s.next;
            if(f == null) return false;
            if(f.equals(s)) return true;
        }
        return false;
    }
```


<br>
<br>    

###142 Linked List Cycle II

>Given a linked list, return the node where the cycle begins. If there is no cycle, return null.

Follow up:
Can you solve it without using extra space?

**Idea**: 

- 1) Use the method in [141 Linked List Cycle](#141-linked-list-cycle) to check if cycle exist. 
- 2) when faster and slower encounters, change the faster to head, and move faster and slower one step each time until they encounter. At this time, the faster and slower point to the node where the cycle begins.

**Attention**: when check if they encounter, if check if they are null! Otherwise, if(f.equals(s)) will have null pointer. 
```java
    public ListNode detectCycle(ListNode head) {
        if(head == null) return null;
        ListNode f = head;
        ListNode s = head;
        while(f != null){
            f = f.next;
            if(f != null) f = f.next;
            s = s.next;
            if(f == null) return null;
            if(f.equals(s)) break;
        }
        f = head;
        while(f != null){
            if(f.equals(s)) return s;
            f = f.next;
            s = s.next;
        }
        return null;
    }
```


<br>
<br>

###143 Reorder List

>Given a singly linked list L: L0→L1→…→Ln-1→Ln,
reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→…

You must do this in-place without altering the nodes' values.

For example,
Given {1,2,3,4}, reorder it to {1,4,2,3}.

**Idea**: We can solve this problem in two ways.
- 1) copy a reversed linked list, then insert half of the list into original list.
- 2) Reverse the last half of the list, then insert it into the first half. 

**Attention**: When reverse, remember to set the first node's next to null, otherwise their will have a loop. 


***Solution1 code ***:

```java
    public void reorderList(ListNode head) {
        if (head == null) {
            return;
        }
        ListNode copy = new ListNode(-1);
        int count = 0;
        ListNode temp = head;
        while (temp != null) {
            ListNode current = new ListNode(temp.val);
            current.next = copy;
            copy = current;
            temp = temp.next;
            count++;
        }
        if(count <= 2) {
            return;
        }
        temp = head;
        ListNode next = null;
        ListNode copyNext = null;
        ListNode pre = null;
        for(int i = 0; i < count/2; i++){
            next = temp.next;
            copyNext = copy.next;
            temp.next = copy;
            copy.next = next;
            pre = copy;
            temp = next;
            copy = copyNext;
        }
        if (count % 2 != 0) {
            temp.next = null;
        } else {
            pre.next = null;
        }
    }

```    
***Solution2 code ***:
```java    
  public void reorderList(ListNode head) {
    // write your solution here
    if (head == null || head.next == null || head.next.next == null) {
      return;
    }
    //find the mid node
    ListNode slower = head; //move one step each time
    ListNode faster = head; // move two steps each time
    ListNode pre = null;
    while (faster != null) {
      pre = slower;
      slower = slower.next;
      faster = faster.next;
      if (faster != null) {
        faster = faster.next;
      }
    }
    pre.next = null;
    
    //reverse last half
    slower = reverseList(slower);
    ListNode temp = head;
    while(temp != null && slower != null) {
      ListNode insert = slower;
      ListNode next = temp.next;
      slower = slower.next;
      temp.next = insert;
      insert.next = next;
      temp = temp.next.next;
    }
  }
  
  public ListNode reverseList(ListNode head) {
    if (head == null || head.next == null) {
        return head;
    }
    ListNode pre = null;
    ListNode next = null;
    while (head != null) {
        next = head.next;
        head.next = pre;
        pre = head;
        head = next;
    }
    return pre;
  }
```


<br>

**Related**: Reorder array in place 

> eg : { 1, 2, 3, 4, 5, 6, 7, 8 } → { 1, 5, 2, 6, 3, 7, 4, 8 }

> { 1, 2, 3, 4, 5, 6, 7 } → { 1, 4, 2, 5, 3, 6, 7 }

```java
  public int[] reorder(int[] array) {
    if (array == null || array.length == 0) {
      return array;
    }
    int len = array.length % 2 == 0 ? array.length : array.length - 1;
    for (int i = len / 2; i < len / 2 * 2; i++) {
      int temp = array[i];
      for (int j = i - 1; j > 2 * i - len; j--) {
        array[j + 1] = array[j];
      }
      array[2 * i - len + 1] = temp;
    }
    return array;
  }
```

<br>
<br>


###144 Binary Tree Preorder Traversal


>Given a binary tree, return the preorder traversal of its nodes' values.

<pre>
For example:
Given binary tree {1,#,2,3},
   1
    \
     2
    /
   3
return [1,2,3].

</pre>

Note: Recursive solution is trivial, could you do it iteratively?


**Idea**:

- Solution 1: recursive. list.add(root.val), then recursive to left and right

- Soltuion 2: Iterative. Use stack. If root != null,store root.val in result list and push root to stack, keep go left. Otherwise, pop root, go right

- Solution 3: Morris, without stack. Create links to the successor(use leaf node's left or right null pointer), in the solution below, we use the right pointer. See details on blog [Morris traversal](http://wishyouhappy.github.io/2014/12/17/morris%20traversal-traverse%20a%20binary%20tree%20without%20stack/)


**Solution 1**: Recursive

```java
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<Integer>();
        if (root == null) {
            return res;
        }
        preorderTraversal(root, res);
        return res;
    }
    public void preorderTraversal(TreeNode root, List<Integer> res) {
        if (root == null) {
            return;
        }
        res.add(root.val);
        preorderTraversal(root.left, res);
        preorderTraversal(root.right, res);
    }
```

**Solution 2**: iterative with stack

```java
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<Integer>();
        if (root == null) {
            return res;
        }
        Stack<TreeNode> stack = new Stack<TreeNode>();
        while (root != null || !stack.isEmpty()) {
            if (root != null) {
                res.add(root.val);
                stack.push(root);
                root = root.left;
            } else {
                root = stack.pop();
                root = root.right;
            }
        }
        return res;
    }
```

**Solution 3**: Morris traversal

```java
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<Integer>();
        if (root == null) {
            return res;
        }
        TreeNode pre = null;
        while (root != null) {
            if (root.left == null) {
                res.add(root.val);
                root = root.right;
            } else {
                pre = root.left;
                while (pre.right != null && pre.right != root) {
                    pre = pre.right;
                }
                if (pre.right == null) {
                    pre.right = root;
                    res.add(root.val);
                    root = root.left;
                } else {
                    pre.right = null;
                    root = root.right;
                }
            }
        }
        return res;
    }
```

<br>

**Related**: Search in binary search tree

```java
public TreeNode search(TreeNode root, int key) {
    // Write your solution here.
    if (root == null) {
      return null;
    }
    while (root != null) {
      if (root.key == key) {
        return root;
      } else if (root.key > key) {
        root = root.left;
      } else {
        root = root.right;
      }
    }
    return null;
}

```

<br>

**Related**: Insert in binary search tree

**Idea**:

- if root is null, insert new element as root
- Otherwise search insert position. If insert key greater than parent, insert as right child otherwise, insert as left child


```java
  public TreeNode insert(TreeNode root, int key) {
    // Write your solution here.
    if (root == null) {
      root = new TreeNode(key);
      return root;
    }
    TreeNode temp = root;
    TreeNode pre = null;
    while (temp != null) {
      pre = temp;
      if (temp.key == key) {
        return root;
      } else if (temp.key < key) {
        temp = temp.right;
      } else {
        temp = temp.left;
      }
    }
    if (pre.key > key) {
      pre.left = new TreeNode(key);
    } else {
      pre.right = new TreeNode(key);
    }
    return root;
  }
```

<br>
<br>

###145 Binary Tree Postorder Traversal

>Given a binary tree, return the postorder traversal of its nodes' values.

<pre>
For example:
Given binary tree {1,#,2,3},
   1
    \
     2
    /
   3
return [3,2,1].

</pre>

Note: Recursive solution is trivial, could you do it iteratively?


**Idea**:

- Solution 1: recursive. recursive to left and right, then list.add(root.val)

- Soltuion 2: Iterative. Use stack. If root != null,push root to stack, keep go left. Otherwise, pop root, go right then add root.val

- Solution 3: Morris, without stack. Create links to the successor(use leaf node's left or right null pointer), in the solution below, we use the right pointer. See details on blog [Morris traversal](http://wishyouhappy.github.io/2014/12/17/morris%20traversal-traverse%20a%20binary%20tree%20without%20stack/)

**Solution 1**: recursive

```java
public List<Integer> postorderTraversal(TreeNode root) {
    List<Integer> res = new ArrayList<Integer>();
    if (root == null) {
        return res;
    }
    postorderTraversal(root, res);
    return res;
}
public void postorderTraversal(TreeNode root, List<Integer> res) {
    if (root == null) {
        return;
    }
    postorderTraversal(root.left, res);
    postorderTraversal(root.right, res);
    res.add(root.val);
}
```

*Solution 2**: Iterative, from wiki

```java
public static List<Integer> postorderTraversal(TreeNode root){
    List<Integer> res = new ArrayList<Integer>();
    Stack<TreeNode> stack = new Stack<TreeNode>();
    TreeNode preVisited = null;
    while (root != null || !stack.isEmpty()) {
        if (root != null) {
            stack.push(root);
            root = root.left;
        } else {
            TreeNode top = stack.peek();
            if (top.right != null && preVisited != top.right) {
                root = top.right;
            } else {
                top = stack.pop();
                res.add(top.val);
                preVisited = top;
            }
        }
    }
    return res;
}

```


**Another iterative solution**, store the return status in statck

```java
    public static List<Integer> postorderTraversal(TreeNode root){
        List<Integer> list = new ArrayList<Integer>();
        Stack<TreeNode> stack = new Stack<TreeNode>();
        Stack<Integer> statusStack = new Stack<Integer>();
        int status = 0;
        statusStack.push(0);
        while (root != null || !stack.isEmpty()) {
            if (status == 0) {
                if(root == null) {
                    status = statusStack.pop();
                    continue;
                }
                stack.push(root);
                statusStack.push(1);
                root = root.left;
            } else if(status == 1) {
                root = stack.peek();
                root = root.right;
                statusStack.push(2);
                status = 0;
            } else {
                list.add(stack.pop().val);
                status = statusStack.pop();
            }
        }
        return list;
    }
```


**Solution 3**: Morris

 See details on blog [Morris traversal](http://wishyouhappy.github.io/2014/12/17/morris%20traversal-traverse%20a%20binary%20tree%20without%20stack/)


<br>
<br>


###147 Insertion Sort List	
> Sort a linked list using insertion sort.


**Idea**: It's similar to insertion sort array. The difference is that in array, if we want to insert i into (0....i-1), we can swap form i-1 if array[i] < array[i-1]. But we can not visit a linkedlist by index. What we can do is visit from the first element.

Something we can do to simplify the insert:
 
- 1) first check if current.val >= pre.val. If true, it's already in right place. we can just go to the next element. 
- 2) then check if current.val <= head.val. If true, we can just insert it before the head.
- 3) If it's not eh two cases above, we need to find the right place to insert the element. Because we have eliminate the corner case above, thus we just need to find the insertion spot, then change the relationship of the pointers.

If we add a fakeHead pointer to avoid the null pointer cases, we can have more concise code.

**Time***: O(n^2)

<br>
```java
    public ListNode insertionSortList(ListNode head) {
        if(head == null) return null;
        ListNode fakeHead = new ListNode(-1);
        ListNode cur = head;
        ListNode temp = fakeHead;
        while(cur != null){
            ListNode next = cur.next;
            ListNode pre = fakeHead;
            temp = fakeHead.next;
            while(temp != null && temp.val < cur.val){
                pre = temp;
                temp = temp.next;
            }
            pre.next = cur;
            cur.next = temp;
            cur = next;
        }
        return fakeHead.next;
    }
```

<br>

	/* Actually, in some cases the code below is a little faster then above. 	Because when the element is alreay in the right place, we don't need to find 	from the beginning */
```java	
	 public ListNode insertionSortList(ListNode head) {
	        if(head == null) return null;
	        ListNode cur = head.next;
	        ListNode preCur = head;
	        while(cur != null){
	            ListNode next = cur.next;
	            if(cur.val >= preCur.val){
	                preCur = cur;
	            }else if(cur.val <= head.val){
	                cur.next = head;
	                head = cur;
	                preCur.next = next;
	            }else{
	                ListNode insertPre = head;
	                ListNode temp = head.next;
	                while(temp != null && temp.val < cur.val){
	                    insertPre = temp;
	                    temp = temp.next;
	                }
	                insertPre.next = cur;
	                cur.next = temp;
	                preCur.next = next;
	            }
	            cur = next;
	        }
	        return head;
	    }
```


<br>
<br>

###148 Sort List

> Sort a linked list in O(n log n) time using constant space complexity.

**Idea**: It require us to sort in O(nlgn) time. "Mergesort" and "Quicksort" is the typical O(nlgn) sort algorithm. When use merge sort, similar with mergesort an array, we fisrt need to find the mid of the list. (The typical two pointer method to find the middle). Then sort(left, mid-1), sort(mid , right) and merge the result.


<br>
```java
	   public ListNode sortList(ListNode head){
		    if(head == null || head.next == null) return head;
		    ListNode f = head;
		    ListNode s = head;
		    ListNode pre = null;
		    while(f != null){
		        f = f.next;
		        if(f != null){
		            f = f.next;
		            pre = s;
		            s = s.next;
		        }
		    }
		    pre.next = null;
		    return merge(sortList(s), sortList(head));
		}
		
		public ListNode merge(ListNode l1, ListNode l2){
		    if(l1 == null) return l2;
		    if(l2 == null) return l1;
		    ListNode fakeHead = new ListNode(-1);
		    ListNode temp = fakeHead;
		    while(l1 != null && l2 != null){
		        if(l1.val > l2.val){
		            temp.next = l2;
		            l2 = l2.next;
		        }else{
		            temp.next = l1;
		            l1 = l1.next;
		        }
		        temp = temp.next;
		    }
		    if(l1 != null) temp.next = l1;
		    if(l2 != null) temp.next = l2;
		    return fakeHead.next;
		}
```		


<br>
<br>


153 Find Minimum in Rotated Sorted Array

>Suppose a sorted array is rotated at some pivot unknown to you beforehand.

>(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).

>Find the minimum element.

>You may assume ***no duplicate*** exists in the array.

**Idea**: The idea is same to * [33 Search in Rotated Sorted Array](#33-search-in-rotated-sorted-array). 

Each time we find the increasing interval. For example, if A[mid] > A[l], then the left part must in order. Thus we update the minimum if needed, then jump to the right part. 

Time complexity: O(lgn)


**Java code**:

```java
    public int findMin(int[] nums) {
        if (nums == null || nums.length == 0) {
            return Integer.MIN_VALUE;
        }
        int l = 0;
        int r = nums.length - 1;
        int result = Integer.MAX_VALUE;
        while (l <= r) {
            int mid = l + (r - l) / 2;
            //the left half is in order
            if (nums[mid] >= nums[l]) {
                result = Math.min(result, nums[l]);
                l = mid + 1;
            } else if (nums[mid] < nums[r]) {
            	//can also use  else if (nums[mid] < numd[r])
                result = Math.min(result, nums[mid]);
                r = mid - 1;
            }
        }
        return result;
    }
```



<br>
<br>

154 Find Minimum in Rotated Sorted Array


>Follow up for "Find Minimum in Rotated Sorted Array":
***What if duplicates are allowed?***

>Would this affect the run-time complexity? How and why?
Suppose a sorted array is rotated at some pivot unknown to you beforehand.

>(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).

>Find the minimum element.

>The array may contain duplicates.


**Idea**: Same way to handle duplicates with *[81 Search in Rotated Sorted Array II](#81-search-in-rotated-sorted-array-ii). 

To find the minimum, use the method in 153. 

Each time we find the increasing interval. For example, if A[mid] > A[l], then the left part must in order. Thus we update the minimum if needed, then jump to the right part. 


**Attention**: When nums[mid] = nums[l], we need to check if we have to update minimum with A[l] before l++


**Java Solution**:


```java
    public int findMin(int[] nums) {
        if (nums == null || nums.length == 0) {
            return Integer.MIN_VALUE;
        }
        int l = 0;
        int r = nums.length - 1;
        int result = Integer.MAX_VALUE;
        while (l <= r) {
            int mid = l + (r - l) / 2;
            //the left half is in order
            if (nums[mid] > nums[l]) {
                result = Math.min(result, nums[l]);
                l = mid + 1;
            } else if (nums[mid] < nums[l]) {
                result = Math.min(result, nums[mid]);
                r = mid - 1;
            } else {
                result = Math.min(result, nums[l]);
                l++;
            }
        }
        return result;
    }


```





<br>
<br>


###151-reverse-words-in-a-string

**Idea**:

- 1) First remove spaces at beginning and at end
- 2) use regular expression split words.
- 3) recreate result string

**Solution**:

```java
public String reverseWords(String input) {
    if (input == null || input.length() == 0) {
      return input;
    }
    input = input.trim();
    String[] arr = input.split("\\s+");
    StringBuilder res = new StringBuilder();
    for (int i = arr.length - 1; i >= 0; i--) {
      res.append(arr[i] + " ");
    }
    return res.toString().trim();
}

```

<br>

**Related**: 
<br>
<br>



###155 Min Stack
>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.
<pre>
push(x) -- Push element x onto stack.
pop() -- Removes the element on top of the stack.
top() -- Get the top element.
getMin() -- Retrieve the minimum element in the stack.
</pre>


**Idea**: Memory limits. If we just a corresponding minstack with the same length of the stack, we would exceed the limit on leetcode. What should we do? We just need to keep the current smallest element. Eg: push(1) to stack, we push(1) to minstack. Next time we push(2) to stack, we don't need to push(2) to minstack. Because the min value is still 1. Thus, every time we push an element to stack, we check if element x > minstack.peek(), if true, we don't need to push. When pop, we check if element x == minstack.peek(), if equals, minstack.pop().

**Attention** : Duplicate elements. (less or equal than, push into min stack). Eg: push (0), push(1), push(0), the minstack should have element 0, 0. 


```java

public class Solution {
  private Stack<Integer> stack;
  private Stack<Integer> minStack;
  public Solution() {
    // write your solution here
    stack = new Stack<Integer>();
    minStack = new Stack<Integer>();
  }
  
  public int pop() {
    if (stack.isEmpty()) {
      return -1;
    }
    if (stack.peek() <= minStack.peek()) {
      minStack.pop();
    }
    return stack.pop();
  }
  
  public void push(int element) {
    if (minStack.isEmpty() || minStack.peek() >= element) {
      minStack.push(element);
    } 
    stack.push(element);
  }
  
  public int top() {
    return stack.isEmpty() ? -1 : stack.peek();
  }
  
  public int getMin() {
    return stack.isEmpty() ? -1 : minStack.peek();
  }
}

```

**Related**: Implement queue with two stacks

```java
class Solution
{
  private Stack<Integer> stackOne;
  private Stack<Integer> stackTwo;
  private int size;
  public Solution() {
    // Write your solution here.
    stackOne = new Stack<Integer>();
    stackTwo = new Stack<Integer>();
    size = 0;
  }
  
  public Integer poll() {
    if (!stackTwo.isEmpty()) {
      size--;
      return stackTwo.pop();
    }
    while (!stackOne.isEmpty()) {
      stackTwo.push(stackOne.pop());
    }
    if (!stackTwo.isEmpty()) {
      size--;
      return stackTwo.pop();
    } else {
      return null;
    }
  }
  
  public void offer(int element) {
    stackOne.push(element);
    size++;
  }
  
  public Integer peek() {
    if (!stackTwo.isEmpty()) {
      return stackTwo.peek();
    }
    while (!stackOne.isEmpty()) {
      stackTwo.push(stackOne.pop());
    }
    if (!stackTwo.isEmpty()) {
      return stackTwo.peek();
    } else {
      return null;
    }
  }
  
  public int size() {
    return size;
  }
  
  public boolean isEmpty() {
    return size == 0;
  }
}
```
 		
    
### 156 Binary Tree Upside Down

> Given a binary tree where all the right nodes are either leaf nodes with a sibling (a left node that shares a same parent node) or empty, flip it upside down and turn it into a tree where the original right nodes turned into left leaf nodes. Return the new root.

<pre>
For example:
Given a binary tree {1,2,3,4,5},
    1
   / \
  2   3
 / \
4   5

return the root of the binary tree [4,5,2,#,#,3,1].
   4
  / \
 5   2
    / \
   3   1  				   
   
</pre>

**Idea:** 

The structure of the original tree: 

* 1) right child doesn't have children
* 2) If right child exist, left child must exist. 

Structure of result tree:

* 1) Right child turn to left child: p.left = parent.right

* 2) Parant becomes right child: p.right = parent 

* 3) Left child becomes root. 

**Solution**: Iterative

```java
public TreeNode upsideDownBinaryTree(TreeNode root){
	TreeNode parent = null;
    TreeNode rightChild = null;
    TreeNode leftChild = null;
	while (root != null) {
		leftChild = root.left;
		root.left = rightChild; //  Right child turn to left child
		rightChild = root.right;
		root.right = parent;   //Parant becomes right child
		parent = root;
		root = leftChild;  //Left child becomes root
	}
	return parent;	
}	

```

**Solution**: recursive

**Note**: In this method, after change the tree, we need to set root.left = null and root.right = null. Otherwise, there will be a cycle.

```java
public TreeNode UpsideDownBinaryTree(TreeNode root) {  
    if (root == null) {
        return null;
    }  
    TreeNode parent = root;
    TreeNode left = root.left;
    TreeNode right = root.right;  
    if (left != null) {  
        TreeNode ret = upsideDownBinaryTree(left);  
        left.left = right;  
        left.right = parent;  
        root.left = null;
        root.right = null;
        return ret;  
    } 
 
    return root;  
}   

```
<br>
<br>


### 157 Read N Characters Given Read4 

> The API: int read4(char *buf) reads 4 characters at a time from a file.
> 
> The return value is the actual number of characters read. For example, it returns 3 if there is only 3 characters left in the file.

> By using the read4 API, implement the function int read(char *buf, int n) that reads n characters from the file.
> 
> Note:The read function will only be called once for each test case.

**Idea:**Iterative call read4 before end of file or each n, store and copy it to the destination buf. 

**Ambiguity:**What if n exceeds the buf's length? 
```java
	/* read 4 characters each time, return the exact number of characters read. */
	int read(char[] buf);
	public int read(char[] buf, int n){
		char[] buffer = new char[4];
		int count = 0;
		int current = 0;
		int needAdd = 0;
		while(true){
			current = read(buffer);
			if(current == 0 || n == count) return count;
			needAdd = Math.min(n-count, current);
			for(int i = 0; i < needAdd; i++){
				buf[count++] =  buffer[i];
			}
		}
	}
```	


<br>
<br>

	

### 158 Read N Characters Given Read4 II - Call multiple times. 

> The API: int read4(char *buf) reads 4 characters at a time from a file.

> The return value is the actual number of characters read. For example, it returns 3 if there is only 3 characters left in the file.

> By using the read4 API, implement the function int read(char *buf, int n) that reads n characters from the file.

> Note:
> The read function may be called multiple times.


**Idea:** Because the read function maybe called multiple times, so at the next call, there might be some data remain in the read4 buffer due to the up amount data of n at each readN bytes call. So we need to keep track of the state of read 4 buffer. If there remains data at read4 buffer at the call, we need start from that position instead of call read4 function. 

```java
	/* read 4 characters each time, return the exact number of characters read. */
	int read(char[] buf);
	int read4Ptr = 0;
	int read4Count = 0;
	char[] buffer = new char[4];
	public int read(char[] buf, int n){	
		int count = 0;
		while(true){
			if(read4Ptr == 0){
				read4Count = read(buffer);
			}
			if(read4Count == 0 || n == count) return count;
			while(count < n && read4Ptr < read4Count){
				buf[count++] =  buffer[read4Ptr++];
			}
			read4Ptr = read4Ptr%read4Count;
			
		}
	}
```	




<br>
<br>


### 159 Longest String with At Most Two Distinct Characters
> Given a string, find longest substring T that contains at most 2 distinct characters.For example, Given s = “eceba”,T is "ece" which its length is 3.

**Idea**: Using a slide window keep track of the substring with at most 2 distinct characters. Each time we encounter the third distinct character, we first calculate the length of the substring, then we move the start position of our slide window to the position that contains only the third character, the first character or the third character, the second character. 

**Example:** Assume the string is accacccbac....., when we encounter "b" at index 7, we calculate the length of substring accaccc and do related operations, then we move the start position of slide window to index 4, then keep going... 

**Solution && time complexity:**	Time complexity: O(n), map contains only two elements. Here, we can use two variables to replace the hashmap, if we extend the problem to k characters, then hashmap maybe more convenient 

```java
	public String subString(String s){
		int start = 0; // start of longest substring
		int end = 0;   // end of longest substring
		int j = 0;     // start of slide window
		int max = 0;
		Map<Character, Integer> map = new HashMap<Character, Integer>();
		for(int i = 0; i < s.length(); i++){
			//check: contains <= 2 characters && substring ends at the end 
			if(i == s.length()-1 && map.size() <= 2 && map.containsKey(s.charAt(i))){
				if(end == 0) return s;
				else{
					if(max < s.length() - j){
						start = j;
						end = s.length()-1;	
					}
				}
			}
			if(map.size() == 2 && !map.containsKey(s.charAt(i))){
				if(max < i - j){
					max = i - j ;
					start = j;
					end = i-1;
				}
				j = s.length();
				char needToRemove = ' ';
				for(char c : map.keySet()){
					if(j > map.get(c)){
						j = map.get(c);
						needToRemove = c;
					}
				}
				j++;
				map.remove(needToRemove);
			}
				map.put(s.charAt(i), i);
		}
		return s.substring(start, end+1);
	
	
```	

**Another way**: This is **not as fast as** the method above. If we encounter the third different element, we can find back from this element and reset the start window to make it contains only two different elements.

```java
	public String subStr(String s){
		if(s == null || s.length() == 0) return s;
		Map<Character, Integer> map = new HashMap<Character, Integer>();
		int start = 0;
		int max = 0;
		int end = 0;
		int j = 0;
		for(int i = 0; i < s.length(); i++){
			if(i == s.length()-1 && map.size() <= 2 && map.containsKey(s.charAt(i))){
				if(end == 0) return s;
				else{
					if(max < s.length() - j){
						start = j;
						end = s.length()-1;	
					}
				}
			}
			if(!map.containsKey(s.charAt(i)) && map.size() == 2){
				if(i - j > max){
					start = j;
					end = i-1;
					max = i-j;
				}
				int temp = i-1;
				char c = s.charAt(temp);
				while(temp >= 0 && s.charAt(temp) == c) temp--;
				j = temp + 1;
				map.remove(s.charAt(temp));
			}
			map.put(s.charAt(i), i);
		}
		return j == 0 ? s : s.substring(start, end+1);
		
	}

```
**Extention:** Find the longest substring contains at most k unique elements. Idea is much similar with k = 2. When we encounter the k+1 character, we need to calculate the length of string do related operations and move slide window, let it contains only k-1 different characters, add the k+1 character, and keep going.  

**Time Complexity:** O(k * n)

```java
	public String subString(String s, int k){
		int start = 0; // start of longest substring
		int end = 0;   // end of longest substring
		int j = 0;     // start of slide window
		int max = 0;
		Map<Character, Integer> map = new HashMap<Character, Integer>();
		for(int i = 0; i < s.length(); i++){
			//check: contains <= 2 characters && substring ends at the end 
			if(i == s.length()-1 && map.size() <= k && map.containsKey(s.charAt(i))){
				if(end == 0) return s;
				else{
					if(max < s.length() - j){
						start = j;
						end = s.length()-1;	
					}
				}
			}
			if(map.size() == k && !map.containsKey(s.charAt(i))){
				if(max < i - j){
					max = i - j ;
					start = j;
					end = i-1;
				}
				j = s.length();
				char needToRemove = ' ';
				for(char c : map.keySet()){
					if(j > map.get(c)){
						j = map.get(c);
						needToRemove = c;
					}
				}
				j++;
				map.remove(needToRemove);
			}
				map.put(s.charAt(i), i);
		}
		return s.substring(start, end+1);
	}
```




<br>
**Related**: longest substring without repeating characters.

**Time complexity**: O(2 * n) = O(n)

```java
  public int lengthOfLongestSubstring(String s) {
    if (s == null || s.length() == 0) {
      return 0;
    }
    int res = 0;
    int start = 0;
    int current = 0;
    Set<Character> set = new HashSet<Character>();
    while (current < s.length()) {
      char c = s.charAt(current);
      if (!set.contains(c)) {
        set.add(c);
      } else {
        res = Math.max(res, current - start);
        while (s.charAt(start) != c) {
          set.remove(s.charAt(start++));
        }
        start++;
      }
      current++;
    }
    res = Math.max(res, current - start);
    return res;
  }

```

<br>
<br>


###160 Intersection of Two Linked Lists
>Write a program to find the node at which the intersection of two singly linked lists begins.


<pre>
For example, the following two linked lists:

A:          a1 → a2
                   ↘
                     c1 → c2 → c3
                   ↗            
B:     b1 → b2 → b3

begin to intersect at node c1.

</pre>


Notes:

If the two linked lists have no intersection at all, return null.

The linked lists must retain their original structure after the function returns.

You may assume there are no cycles anywhere in the entire linked structure.

Your code should preferably run in O(n) time and use only O(1) memory.


<br>

**Idea**: 

Solustion1: 

We can get the length of two linkedlist, assume len1 > len2. We move head1 move len1-len2 steps, then compare each node in list1 and list2, until two lists have the same nodes. 

Solution2: We don't need to calculae the length of list1 and list2. Use two pointers p1 p2, when one pointer reaches the end, assume it's p1, we change p1  to head2. Then continues until p2 reach to the end. By this time, p1 is pointer to len2 -len1 of list2, we let p2 points to head1. So we can continue to compare until we encounter same nodes. 


**Attention**: Null pointer! We need to take care of null pointer for all linkedlist problems.

Solution1 :
```java
	 public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
	       if(headA == null || headB == null) return null;
	       int lenA = 0;
	       int lenB = 0;
	       ListNode temp = headA;
	       while(temp != null){
	           lenA++;
	           temp = temp.next;
	       }
	       temp = headB;
	       while(temp != null){
	           temp = temp.next;
	           lenB++;
	       }
	       int diff = Math.abs(lenA - lenB);
	       if(lenA > lenB){
	           while(diff > 0) {
	               headA = headA.next;
	               diff--;
	           }
	       }else{
	           while(diff > 0){
	               headB = headB.next;
	               diff--;
	           }
	       }
	       while(headA != null && headB != null && !headA.equals(headB)){
	           headA = headA.next;
	           headB = headB.next;
	       }
	       return headA;
	 }
```
Solution2:
```java
	 public ListNode getIntersectionNode2(ListNode headA, ListNode headB) {
	       if(headA == null || headB == null) return null;
	       ListNode tempA = headA;
	       ListNode tempB = headB;
	       while(tempA != null && tempB != null){
	           tempA = tempA.next;
	           tempB = tempB.next;
	       }
	       tempA = tempA == null ? headB : tempA;
	       tempB = tempB == null? headA : tempB;
	       while(tempA != null && tempB != null){
	           tempA = tempA.next;
	           tempB = tempB.next;
	       }
	      tempA = tempA == null ? headB : tempA;
	      tempB = tempB == null ? headA : tempB;
	      while(tempA != null && tempB != null && !tempA.equals(tempB)){
	          tempA = tempA.next;
	          tempB = tempB.next;
	      }
	      return tempA;
	 }
```


<br>
<br>



###162 Find Peak Element


>A peak element is an element that is greater than its neighbors.

>Given an input array where num[i] ≠ num[i+1], find a peak element and return its index.

>The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.

>You may imagine that num[-1] = num[n] = -∞.

>For example, in array [1, 2, 3, 1], 3 is a peak element and your function should return the index number 2.


**Idea**: Since there is no duplicate, and num[-1] = num[n] = -inf, thus the peak must exist. We can eaisly solve this problem in brute force in O(n) time. Can we improve it? 

Sure, use **binary search!.**

Since we only need to return one of the peaks, thus if we encounter an element which satisfies that num[i-1] < num[i], num[i] > num[i+1], then we can return. 

Then how to change window in binary search?
We move to the side that has has peeks. We can check if num[i-1] > num[i], if it is true, then we move to the left, otherwise, we move to the right.

Look at the following picture:

![peak](https://wishyouhappy.github.io/pictures/peakelement.png)

Suppose in the above three cases, 5 is the mid.

- case 1: return 5, because 5 is a peak
- case 2: num[mid -1] > num[mid], thus there must exist a peak on the left side. Why? If 7 is larger than the element on the left side of it, then 7 is a peak, otherwise, the element on the left side of 7 might be a peak. Because we know that there is a -inf on the leftmost.
- case 3: num[mid - 1] < num[mid], then we move to the right part. Because the element on the right side of 5 must be larger than 5. Otherwise, 5 is a peak.

**Java code **: 


**Binary search**: TIME : O(lgn)


```java
    public int findPeakElement(int[] nums) {
        if (nums == null || nums.length == 0) {
            return -1;
        }
        int l = 0;
        int r = nums.length - 1;
        while (l <= r) {
            int mid = l + (r - l) / 2;
            if ((mid == 0 || nums[mid] > nums[mid - 1]) && (mid == nums.length -1 || nums[mid] > nums[mid + 1])) {
                return mid;
            } else if (mid > 0 && nums[mid] < nums[mid - 1]) {
                r = mid - 1;
            } else {
                l = mid + 1;
            }
        }
        return l;
    }

```

**Brute force**: Time complexity: O(n)
```java
    public int findPeakElement1(int[] num) {
        if(num == null || num.length == 0) return -1;
        if(num.length == 1) return 0;
        for(int i = 0; i < num.length-1; i++){
        	if(i == 0){
        		if(num[i] > num[i+1]) return i;
        	}else{
        		if(num[i] > num[i+1] && num[i] > num[i-1]) return i;
        	}
        }
        if(num[num.length-1] > num[num.length-2]) return num.length -1;
        return -1;
    }

```



<br>
<br>



###166 Fraction to Recurring Decimal

>Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.
	
>If the fractional part is repeating, enclose the repeating part in parentheses.

	For example,

	Given numerator = 1, denominator = 2, return "0.5".
	Given numerator = 2, denominator = 1, return "2".
	Given numerator = 2, denominator = 3, return "0.(6)".

<br>

**Idea**: Just do the divide like what we normally do in math. 

For example, 3/7 

- quotient = 0, remainer = 3 , string = 0.
- **3 * 10/7** quotient = 4, remainder = 2; string = 0.4
- 2 * 10/ 7 quotient = 2, remainder = 6; string = 0.42
- 6 * 10/7 quotient = 8, remainder = 4; string = 0.428
- 4 * 10 /7 quotient = 5, remainder = 5; string = 0.4285
- 5 * 10/7 quotient = 7, remainder = 1, string = 0.42857
- 1 * 10/7 quotient = 1, remainder = 3, string = 0.428571
- **3 * 10/7**

Thus, we know the result is 0.(428571)

In order to know when the recuisive begins, we need to record the remainder at each iteration.

**Attention**

- 1)We need to do abs for both numbers, otherwise, there might be unnecessary "-" in the result string
- 2)abs(Integer.MIN_VALUE)
- 3)use hashmap to record the position of each remainder.


<br>
```java
    public String fractionToDecimal(int numerator, int denominator) {
        if(denominator == 0 || numerator == 0) return "0";
        StringBuilder res = new StringBuilder();
        Map<Long, Integer> map = new HashMap<Long, Integer>();
        boolean positive = ((numerator ^ denominator) >>> 31) == 0;
        if(!positive) res.append("-");
        long num = Math.abs((long)numerator);
        long den = Math.abs((long)denominator);
        res.append(num/den);
        if(num % den == 0) return res.toString();
        res.append(".");
        long mod = num % den;
        while(mod != 0){
            if(map.containsKey(mod)){
                res.insert(map.get(mod), "(");
                res.append(")");
                return res.toString();
            }
            map.put(mod, res.length());
            mod = mod * 10;
            long divide = mod/den;
            mod = mod % den;
            res.append(divide);
        }
        return res.toString();
    }

```



<br>

<br>


###167 Two Sum II Input array is sorted

>Given an array of integers that is already **sorted in ascending order**, find two numbers such that they add up to a specific target number.

>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are **not zero-based**.
You may assume that each input would have exactly one solution.

	Input: numbers={2, 7, 11, 15}, target=9
	Output: index1=1, index2=2

<br>

**Idea**: We can solve this problem use the second method in * [1 Two Sum](#1-two-sum). Just use two pointers, one at the beginning, one at the ending. Compare num[l] + num[r] and target. If the former is larger, then r--, if the latter is larger, l++.

```java
	public int[] twoSum(int[] numbers, int target){
		int[] res = new int[2];
		if(numbers == null || numbers.length <= 1) return res;
		int l = 0;
		int r = numbers.length -1;
		while(l < r){
			if(numbers[l] + numbers[r] == target){
				res[0] = l+1;
				res[1] = r+1;
				return res;
			}else if(numbers[l] + numbers[r] > target) r--;
			else l++;
		}
		return res;
	}

```


<br>

<br>


###170 Two Sum III Data Structure Design

>Design and implement a TwoSum class. It should support the following operations: add and find.

>add - Add the number to an internal data structure.

>find - Find if there exists any pair of numbers which sum is equal to the value.

	For example,
	add(1); add(3); add(5);
	find(4) -> true
	find(7) -> false
	
<br>

**Idea**: How to design the structure is based on our needs. Remember in * [1 Two Sum](#1-two-sum) , the first method we use hashmap to record each number, and check if sum - number exist. If we do this the same way in this problem, we can use hashmap to record each number when add, and find the number use the method in * [1 Two Sum](#1-two-sum). 

**Time complexity** : add O(1) find O(n)

**Space**: O(n)

***What if we want to find sum in O(1)?***

We need to record the all possible sum when add new numbers. Then the time complexity would change to O(n). Also, we need a set to record the possible sum. So we need to increase the space. 
```java
	public class TwoSum{
		private Map<Integer, Integer> map = new HashMap<Integer, Integer>();
		public void add(int number){
			if(map.containsKey(number)) map.put(number, map.get(number)+1);
			else map.put(number, 1);
		}
		
		public boolean find(int value){
			for(Integer i : map.keySet()){
				int remain = value -i;
				if(map.containsKey(remain)){
					if(remain == i && map.get(remain) < 2) continue;
					else return true;
				}
			}
			return false;
		}
	}
	
```



<br>

<br>

### 171 Excel Sheet Column Number

> Given a column title as appear in an Excel sheet, return its corresponding column number.
>
> For example:
>
> ```
>   A -> 1
>   B -> 2
>   C -> 3
>   ...
>   Z -> 26
>   AA -> 27
>   AB -> 28 
> ```

**Analysis:** 

for example: CABD

`C * 26 ^ 3 + A * 26 ^ 2 + B * 26 ^ 1 + D * 26 ^ 0`

which is

`3 * 26 ^ 3 + 1 * 26 ^ 2 + 2 * 26 ^ 1 + 4`

The following code takes O(N) time and O(1) space.

``` C
int titleToNumber(char *s) {
    int i = 0, val = 0, x = 1;
    
    if (s[0] == 0) { return 0; } // if empty string
    for (; s[i+1] != 0; i ++); // find the end of string
    
    for (; i >= 0; i --) {
        val += x * (s[i] - 'A' + 1);
        x *= 26; // if we use something like pow(26, length - i) it 
                 // will cause extra calculation and takes more time.
    }
    
    return val;
}
```

<br>
<br>

###173 Binary Search Tree Iterator

>Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.

>Calling next() will return the next smallest number in the BST.

>Note: next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree.

**Idea**:

- 1) Here we maintain a stack, from top to bottom is the smallest to largest. Because we use the stack data structure, thus we visit the tree in the following order: right -> root -> left. In this way, the top element in the stack would be the smallest element. 

However, the space would be O(n). So how could we solve it in O(h) space? 

- 2) O(h) is the height of the tree, thus we can store an path of root to leaf element in stack. Because we need to return the next smallest element each time, thus we need to traverse the tree inorder. And each time we return the next successor

In this method, we fist store the left path of the tree in stack. When right child is not empty, we need to store the left path of its right child in stack until stack is empty. 


**Solution 1**: O(n) space, unqualified

```java
public class BinarySearchTreeIterator {
    Stack<Integer> stack; 
    public BSTIterator(TreeNode root) {
        stack = new Stack<Integer>();
        inorderReverse(stack, root);
    }

    /** @return whether we have a next smallest number */
    public boolean hasNext() {
        return !stack.isEmpty();
    }

    /** @return the next smallest number */
    public int next() {
        if (hasNext()) {
            return stack.pop();
        }
        return -1;
    }
    
    private void inorderReverse(Stack<Integer> stack, TreeNode root) {
        if (root == null) {
            return;
        }
        inorderReverse(stack, root.right);
        stack.push(root.val);
        inorderReverse(stack, root.left);
    }
}
```

<br>

**Solution 2**:

```java
public class BSTIterator {
    Stack<TreeNode> stack; 
    public BSTIterator(TreeNode root) {
        stack = new Stack<TreeNode>();
        while(root != null) {
            stack.push(root);
            root = root.left;
        }
    }

    /** @return whether we have a next smallest number */
    public boolean hasNext() {
        return !stack.isEmpty();
    }

    /** @return the next smallest number */
    public int next() {
        if (stack.isEmpty()) {
            return -1;
        }
        TreeNode cur = stack.pop();
        int res = cur.val;
        if (cur.right != null) {
            cur = cur.right;
            while(cur != null) {
                stack.push(cur);
                cur = cur.left;
            }
        }
        return res;
    }
}

```
<br>
<br>
	
### 188 Best Time to Buy and Sell Stock IV

> Say you have an array for which the ith element is the price of a given stock on day i.

>Design an algorithm to find the maximum profit. You may complete **at most k transactions**.

>Note:

>You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).

**First try:** Use the idea in [Best time to buy and sale stock iii](#123-best-time-to-buy-and-sell-stock-iii).
global[i][j]: denotes max profit, at most j transactions before day i:

 **global[i][j]=max(local[i][j],global[i-1][j])**

local[i][j]: denotes max profit, at most j transactions before day i, and last transaction is saled on day i: 

**local[i][j]=max(global[i-1][j-1]+max(diff,0),local[i-1][j]+diff)**

**Time complexity**: O(k * n)

**Space** : O(k)

Looks good, right? But we'll get out of memory error. Because in one test case, k = 100000. 

```java
	public int maxProfit(int k, int[] prices){
		if(prices == null || prices.length <= 1) return 0;
		int[] global = new int[k+1];
		int[] local = new int[k+1];
		for(int i = 1; i < prices.length; i++){
			int dif = prices[i] - prices[i-1];
			for(int j = k; j >= 1; j--){
				local[j] = Math.max(global[j-1] + Math.max(dif, 0), local[j] + dif);
				global[j] = Math.max(local[j], global[j]);
			}
		}
		return global[k];
	}
```
**Solution:**



<br>
<br>


###189 Rotate Array

>Rotate an array of n elements to the right by k steps.

For example, with n = 7 and k = 3, the array [1,2,3,4,5,6,7] is rotated to [5,6,7,1,2,3,4].


Note:
Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.

**Idea**

- 1)Solution1:  In place. Reverse the array three times. (0, n-1) (0, k-1), (k-n-1)
- 2)Solution2:  Use an extra array, and copy to the right place.

<br>
**Solution1**:
```java
   public void rotate(int[] nums, int k) {
       if(nums == null || nums.length == 0 || k <= 0) return;
       k = k % nums.length;
       reverse(nums, 0, nums.length-1);
       reverse(nums, 0, k-1);
       reverse(nums, k, nums.length-1);
    }
    
    public void reverse(int[] nums, int left, int right){
        while(left < right){
            int temp = nums[left];
            nums[left] = nums[right];
            nums[right] = temp;
            left++;
            right--;
        }
    }
```    
**Solution 2**:
```java
    public void rotate1(int[] nums, int k) {
        if(nums == null || nums.length == 0 || k <= 0) return;
        int[] result = new int[nums.length];
        k = k % nums.length;
        for(int i = 0; i < k; i++){
            result[i] = nums[nums.length -k + i];
        }
        for(int i = k; i < nums.length; i++){
            result[i] = nums[i-k];
        }
        for(int i = 0; i < nums.length; i++){
            nums[i] = result[i];
        }
    }
```

###190 Reverse Bits

>Reverse bits of a given 32 bits unsigned integer.

>For example, given input 43261596 (represented in binary as 00000010100101000001111010011100), return 964176192 (represented in binary as 00111001011110000010100101000000).

>Follow up:

>If this function is called many times, how would you optimize it?

>Related problem: Reverse Integer


**Idea**: Like reverse a string, we swap each bit i with 32 -i -1 for 1/2 of the total bit length. 

```java

    public int reverseBits(int n) {
        if(n == 0) return 0;
        for(int i = 0; i < 16; i++){
        	n = swap(n, i, 32-i-1);
        }
        return n;
    }
    
    public int swap(int n,int i, int j){
    	int bitI = (n >> i) & 1;
    	int bitJ = (n >> j) & 1;
    	if((bitI ^ bitJ) != 0){
    		n = n ^ ((1 << i) | (1 << j));
    	}
    	return n;
    }

```

**Another solution in c++**: If the binary of number  a is  10001111 we can represent it as 2 ^ 7 + 2 ^ 3 + 2 ^2 + 2 ^ 1 + 2 ^ 0. Thus we use mod 2 and * 2 to reserve this number. Because in java int is not unsigned, so use this method in java have sign problem.

```c++

	uint32_t reverseBits(uint32_t n) {
        if(n == 0) return 0;
        int res = 0;
        for(int i = 0; i < 32; i++){
            int mod = n % 2;
            n = n >> 1;
            res = (res << 1) + mod;
        }
        return res;
    }


```



<br>

<br>


###191 Number of 1 Bits

>Write a function that takes an unsigned integer and returns the number of ’1' bits it has (also known as the Hamming weight).

>For example, the 32-bit integer ’11' has binary representation 00000000000000000000000000001011, so the function should return 3.


**Idea**: There are three ways to deal with this problem.

- 1) n & 1, if result is 1, count ++, n >>>= 1, till n = 0; ** Remember use >>>**
- 2) use n = n & n-1 to remove the rightmost 1. **Time complexity is O(number od 1s)**
- 3) use left shift. 



**Solution1 : Java code**:



```java


    public int hammingWeight(int n) {
        if(n == 0) return 0;
        int res = 0;
        while(n != 0){
            if((n & 1) != 0) res++;
            n = n >>> 1;
        }
        return res;
    }

```

**Solution 2: c++ code**:

```c++

    int hammingWeight(uint32_t n) {
          int res = 0;
          while(n > 0){
        	  n &= n-1;
        	  res++;
          }
          return res;
    }

```

**Solution 3: c++ code**:

```c++

    int hammingWeight(uint32_t n) {
      int res = 0;
      unsigned int flag = 1;
      while(flag){
         if(n&flag){
            res++;
        }
        flag = flag << 1;
      }
      return res;
    }

```


<br>
<br>

###198 House Robber


>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.

>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.


**Idea**: It's an one dimensional dp problem, like the **Best time to buy and sell stocks. We need to find the maximum nonadjacent sum. Thus, for each room our choice is either rob or not rob, based on the previous room, and we need to mantain the max money on the current. If we want to rob this room, the condition is that we don't rob the previous room. Thus robYes = robNo + room[i]. And if we don't rob this room, then we can choose the max from previous robYes and robNo. See details on the following code.

 

**Solution 1 **:


```java

    public int rob(int[] num) {
        if(num == null || num.length == 0) return 0;
        int robYes = 0;
        int robNo = 0;
        for(int money : num){
            int temp = robNo;
            robNo = Math.max(robYes, robNo);
            robYes = temp + money;
        }
        return Math.max(robYes, robNo);
    }


```



**Solution 2**:

```java

    public int rob(int[] num) {
        if(num == null || num.length == 0) return 0;
        int even = 0;
        int odd = 0;
        for(int i = 0; i < num.length; i++){
            if(i % 2 == 0){
                even += num[i];
                even = Math.max(even, odd);
            }else{
                odd += num[i];
                odd = Math.max(even, odd);
            }
        }
        return Math.max(odd, even);
    }

```


<br>
<br>



###199 Binary Tree Right Side View


>Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.

<pre>

For example:
Given the following binary tree,
   1         
 /   \
2     3         
 \     \
  5     4      
You should return [1, 3, 4].

</pre>

**Idea**: This problem is similar to the **breadth first search** of a binary search tree. If you can figure out this, the problem is easy. We use a queue, more precisely a deque to store element of each level. Then each time we store the rightmost element in each level to the result list. 


**Java code**:


```java

public List<Integer> rightSideView(TreeNode root) {
    List<Integer> res = new ArrayList<Integer>();
    if (root == null) {
        return res;
    }
    Deque<TreeNode> deque = new LinkedList<TreeNode>();
    deque.offer(root);
    while (!deque.isEmpty()) {
        TreeNode cur = null;
        for (int i = 0, size = deque.size(); i < size; i++) {
            cur = deque.pollLast();
            if (cur.right != null) {
                deque.addFirst(cur.right);
            }
            if (cur.left != null) {
                deque.addFirst(cur.left);
            }
            if(i == 0){
                res.add(cur.val);
            } 
        }
    }
    return res;
}

```

<br>
<br>


###200 Number of Islands

>Given a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.

<pre>
Example 1:

11110
11010
11000
00000
Answer: 1

Example 2:

11000
11000
00100
00011
Answer: 3


</pre>


**Idea**: Basically, the idea is similar to flood fill or bfs/dfs of graph. Each time we visited a land, we marked it as visited, then go north/west/south/east. When dfs ends, that means we have visited every land of a certain island. In the same way, we can count the number of all islands.


**Java code**:

```java
public int numIslands(char[][] grid) {
        if(grid == null || grid.length == 0 || grid[0].length == 0) return 0;
        boolean[][] visited = new boolean[grid.length][grid[0].length];
        int res = 0;
        for(int i = 0; i < grid.length; i++){
            for(int j = 0; j < grid[0].length; j++){
                if(grid[i][j] == '1' && visited[i][j] == false){
                    dfs(visited, grid, i, j);
                    res++;
                }
            }
        }
        return res;
    }
    
    public void dfs(boolean[][] visited, char[][] grid, int i, int j){
        if(i < 0 || i >= grid.length || j < 0 || j >= grid[0].length)
            return;
        if(visited[i][j] == true || grid[i][j] == '0')
            return;
        visited[i][j] = true;
        dfs(visited, grid, i-1, j);
        dfs(visited, grid, i, j-1);
        dfs(visited, grid, i+1, j);
        dfs(visited, grid, i, j+1);
    }

```



<br>
<br>


###201 Bitwise AND of Numbers Range

>Given a range [m, n] where 0 <= m <= n <= 2147483647, return the bitwise AND of all numbers in this range, inclusive.

>For example, given the range [5, 7], you should return 4.

**Idea**: what we need to do is to  find the similar bits of of m and n on the left side. For eample, if n = 111, m = 101, then the similar part on the left side is 1, then the result is 100. Then we left shift 1 by 2 we can get the result.


**Java code**:


```java


    public int rangeBitwiseAnd(int m, int n) {
        int count = 0;
        while(m != n){
            m >>= 1;
            n >>= 1;
            count++;
        }
        return m << count;
    }

```

<br>
<br>

###202 Happy Number

>Write an algorithm to determine if a number is "happy".

>A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.

<pre>

Example: 19 is a happy number

1^2 + 9^2 = 82
8^2 + 2^2 = 68
6^2 + 8^2 = 100
1^2 + 0^2 + 0^2 = 1

</pre>


**Idea**:If it is not a happy number, then it will have a circle, that is, when we continue calculate, we will return to a certain value. So we need to save the history number. When we find that a number has existed before, then it is not a happy number. 

**Java code**:

```java

    public boolean isHappy(int n) {
        if(n <= 0) return false;
        Set<Integer> set = new HashSet<Integer>();
        set.add(n);
        while(n != 1){
            int temp = 0;
            while(n != 0){
                temp += (n%10) * (n%10);
                n = n/10;
            }
            if(set.contains(temp)) return false;
            set.add(temp);
            n = temp;
        }
        return true;
    }

```

In python, we can use the string convertion for this problem:

``` python
class Solution:
    # @param {integer} n
    # @return {boolean}
    def isHappy(self, n):
        m = n
        mem = set()
        while m not in mem:
            mem.add(m)
            m = sum([int(x) ** 2 for x in str(m)])
            if m == 1:
                return True
        return False
```

<br>
<br>


### 203 Remove Linked List Elements

> Remove all elements from a linked list of integers that have value val.
>
> Example
> Given: `1 --> 2 --> 6 --> 3 --> 4 --> 5 --> 6, val = 6`
> Return: `1 --> 2 --> 3 --> 4 --> 5`

The `head` of this problem contains value. If it doesn't contains the value,
declaration of `p` and `q` to `p, q = head, head->next`.

Becareful if:
- The node is `head`
- The node is `tail`, which means `.next = None`
- How to move the pointers ahead.

**Java code**:

```java

    public ListNode removeElements(ListNode head, int val) {
        if(head == null) return head;
        ListNode fakeHead = new ListNode(-1);
        fakeHead.next = head;
        ListNode pre = fakeHead;
        while(head != null){
            if(head.val == val){
                pre.next = head.next;
                head = pre.next;
            }else{
                pre = head;
                head = head.next;
            }
        }
        return fakeHead.next;
    }

```
**python**:

``` python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    # @param {ListNode} head
    # @param {integer} val
    # @return {ListNode}
    def removeElements(self, head, val):
        if not head:
            return None
            
        p, q = None, head
            
        while q is not None:
            if q.val == val:
                if p is None:  # q is head  
                    head = q.next
                else:
                    p.next = q.next
                q = q.next
            else:
                p, q = q, q.next
                
        return head
```


###204 Count Primes

>Description:Count the number of prime numbers less than a non-negative number, n

**Idea**: The straight forward way is that we check each number, if it is prime, resut++.

So at first try code like this:

```java 

 public int countPrimes1(int n) {
        if(n <= 2) {
            return 0;
        }
        boolean[] prime = new boolean[n];
        for(int i = 2; i <= n/2; i++ ) {
            // if i is prime
            if(!prime[i]){
                for(int j = i+i; j < n; j += i) {
                    prime[j] = true;
                }
            }
        }
        int res = 1;
        for(int i = 3; i < n; i++){
            if(!prime[i]){
                res++;
            }
        }
        return res;
    }


```


***There are a few places can be modified.***

1) the outer loop, i can be changed to sqrt(n)

2) when count the primes in the last loop, i can be changed to i+2

3) the inside loop, i can be changed to i*i

then the changed code is below:


```java

    public int countPrimes(int n) {
        if(n <= 2) {
            return 0;
        }
        boolean[] prime = new boolean[n];
        for(int i = 2, sqr = (int)Math.sqrt(n); i <= sqr; i++ ) {
            // if i is prime
            if(!prime[i]){
                for(int j = i*i; j < n; j += i) {
                    prime[j] = true;
                }
            }
        }
        int res = 1;
        for(int i = 3; i < n; i += 2){
            if(!prime[i]){
                res++;
            }
        }
        return res;
    }

```

From the suggestions of friends, I realized that I can use bitset to save space.  If you are not familiar with bitset like me, check this [link](https://docs.oracle.com/javase/7/docs/api/java/util/BitSet.html) The code is below:


```java


 public int countPrimes(int n) {
        if(n <= 2) {
            return 0;
        }
        BitSet set = new BitSet();
        for(int i = 2, sqr = (int)Math.sqrt(n); i <= sqr; i++ ) {
            // if i is prime
            if(!set.get(i)){
                for(int j = i*i; j < n; j += i) {
                    set.set(j);
                }
            }
        }
        set.set(0);
        set.set(1);
        return n - set.cardinality();
    }


```
<br>

<br>


###205 Isomorphic Strings

>Given two strings s and t, determine if they are isomorphic.

>Two strings are isomorphic if the characters in s can be replaced to get t.

>All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.

>For example,

>Given "egg", "add", return true.

>Given "foo", "bar", return false.

>Given "paper", "title", return true.

>Note:
>You may assume both s and t have the same length.


**Idea**:

- method 1: Use one hashmap, check their map relation. Since **we need to use the containsvalue, it takes O(n)**, thus the worst case time complexity is O(n ^ 2)

- method 2: Use two hashmap, store the map relation of two string. Time: O(n). We need more space. 

- method 3: if we only consider Ascii, then we can use array to replace hashmap in method 2.



**Java code**:

*Method 1*:

```java

    public boolean isIsomorphic(String s, String t) {
        Map<Character, Character> map = new HashMap<Character, Character>();
        for(int i = 0; i < s.length(); i++) {
           char cs = s.charAt(i);
           char ct = t.charAt(i);
           if(!map.containsKey(cs)) {
               if(map.containsValue(ct)) {
                   return false;
               }
               map.put(cs, ct);
           } else {
               if(map.get(cs) != ct) {
                   return false;
               }
           }
        }
        return true;
    }

```

*Method 2*:

```java

    public boolean isIsomorphic(String s, String t) {
        Map<Character, Character> maps = new HashMap<Character, Character>();
        Map<Character, Character> mapt =  new HashMap<Character, Character>();
        for(int i = 0; i < s.length(); i++) {
           char cs = s.charAt(i);
           char ct = t.charAt(i);
           maps.putIfAbsent(cs, ct);
           mapt.putIfAbsent(ct, cs);
           if(maps.get(cs) != ct || mapt.get(ct) != cs) {
               return false;
           }
        }
        return true;
    }

```


*Method 3*:


```java


    public boolean isIsomorphic2(String s, String t) {
        int[] sArr = new int[256];
        int[] tArr = new int[256];
        for(int i = 0; i < s.length(); i++) {
            if(sArr[s.charAt(i)] != tArr[t.charAt(i)]) {
                return false;
            }
            sArr[s.charAt(i)] = i+1;
            tArr[t.charAt(i)] = i+1;
        }
        return true;
    }

```

<br>
<br>

###206 Reverse Linked List

> Reverse a singly linked list.


**Idea**: Really straight forward. Let the next node pointer to the previous node until to the end of the list. Just need to take care of the null pointer. 

```java

    public ListNode reverseList(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        ListNode pre = null;
        ListNode next = null;
        while (head != null) {
            next = head.next;
            head.next = pre;
            pre = head;
            head = next;
        }
        return pre;
    }

```

<br>
<br>

###207 Course Schedule

>There are a total of n courses you have to take, labeled from 0 to n - 1.

>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]

>Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?

>For example:

>2, [[1,0]]
There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible.

>2, [[1,0],[0,1]]
There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.

>Note:
The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented.

**Idea**: 

- 1) solution 1: This problem is a typical example of topological sort. We can firt create the adjacent matrix, then do topological sort to check if all courses are finished. 

- 2) solution 2: For each edge we can use a stack to check if there is a cycle. If cycle exist, then we can not finish all the courses. 


**Java Solution**:

```java
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        if (prerequisites == null || prerequisites.length == 0 || numCourses <= 0) {
            return true;
        }
        int[][] adj = new int[numCourses][numCourses];
        int[] inDegree = new int[numCourses];
        for (int i = 0; i < prerequisites.length; i++) {
            int in = prerequisites[i][1];
            int out = prerequisites[i][0];
            if (adj[in][out] == 0) {
                inDegree[out]++;
            }
            adj[in][out] = 1;
        }
        
        Queue<Integer> zeroDegrees = new LinkedList<Integer>();
        for (int i = 0; i < numCourses; i++) {
            if (inDegree[i] == 0) {
                zeroDegrees.offer(i);
            }
        }
        
        int count = 0;
        while (!zeroDegrees.isEmpty()) {
            int temp = zeroDegrees.poll();
            count++;
            for (int i = 0; i < numCourses; i++) {
                if (adj[temp][i] == 1) {
                    inDegree[i]--;
                    if (inDegree[i] == 0) {
                        zeroDegrees.offer(i);
                    }
                }
            }

        }
        
        return count == numCourses;
    }

```

<br>
<br>
<br>



###208 Implement Trie Prefix Tree

>Implement a trie with insert, search, and startsWith methods.

>Note:You may assume that all inputs are consist of lowercase letters a-z.

**Idea**: If you are not familiar with Trie, look at my blog [Trie](http://wishyouhappy.github.io/2015/05/27/Trie/)

**Solution1**: the most original and simple method

```java
class TrieNode {
    // Initialize your data structure here.
    public TrieNode[] edges;
    public boolean isLeaf; //check if a trienode is a leaf node
    public TrieNode() {
        // all possible sons
        edges = new TrieNode[26];
    }
}

public class Trie {
    private TrieNode root;

    public Trie() {
        root = new TrieNode();
    }

    // Inserts a word into the trie.
    public void insert(String word) {
        if (word == null || word.length() == 0) {
            return;
        }
        root = insert(root, word, 0);
    }
    
    public TrieNode insert(TrieNode node, String word, int len) {
        if (node == null) {
            node = new TrieNode();
        }
        if (len == word.length()) {
            node.isLeaf = true;
            return node;
        }
        int pos = word.charAt(len) - 'a';
        node.edges[pos] = insert(node.edges[pos], word, len + 1);
        return node;
    }

    // Returns if the word is in the trie.
    public boolean search(String word) {
       TrieNode temp = searchHelper(root, word, 0);
       return temp == null ? false : temp.isLeaf;    
    }

    // Returns if there is any word in the trie
    // that starts with the given prefix.
    public boolean startsWith(String prefix) {
        TrieNode temp = searchHelper(root, prefix, 0);
        return temp == null ? false : true;
    }
    
    public TrieNode searchHelper(TrieNode node, String word, int len) {
        if (node == null) {
            return null;
        }
        if (len == word.length()) {
            return node;
        }
        int pos = word.charAt(len) - 'a';
        return searchHelper(node.edges[pos], word, len + 1);
    }
}
```


**Solution2**: using hashmap

```java
class TrieNode {
    // Initialize your data structure here.
    public Map<Character, TrieNode> edges;
    public boolean isLeaf; //check if a trienode is a leaf node
    public TrieNode() {
        edges = new HashMap<Character, TrieNode>(); // all possible sons
    }
}

public class Trie {
    private TrieNode root;

    public Trie() {
        root = new TrieNode();
    }

    // Inserts a word into the trie.
   public void insert(String word) {
        Map<Character, TrieNode> edges = root.edges;
        for(int i=0; i<word.length(); i++){
            char c = word.charAt(i);
            TrieNode current = null;
            if(edges.containsKey(c)){
                current = edges.get(c);
            }else{
                current = new TrieNode();
                edges.put(c, current);
            }
            edges = current.edges;
            if (i == word.length() - 1) {
                current.isLeaf = true;
            }
        }
    }

    // Returns if the word is in the trie.
    public boolean search(String word) {
        TrieNode res = searchHelper(word);
        return res == null ? false : res.isLeaf;
    }


    // Returns if there is any word in the trie
    // that starts with the given prefix.
    public boolean startsWith(String prefix) {
       TrieNode res = searchHelper(prefix);
       return res == null ? false : true;
    }
    
    private TrieNode searchHelper(String word) {
        Map<Character, TrieNode> edges = root.edges;
        TrieNode res = null;
        for (int i = 0; i < word.length(); i++) {
            char c = word.charAt(i);
            if (edges.containsKey(c)) {
                res = edges.get(c);
                edges = res.edges;
            } else {
                return null;
            }
        }
        return res;
    }
    
}
```





<br>
<br>

###209 Minimum Size Subarray Sum

> Given an array of n positive integers and a positive integer s, find the minimal length of a subarray of which the sum ≥ s. If there isn't one, return 0 instead.

>For example, given the array [2,3,1,2,4,3] and s = 7,
>the subarray [4,3] has the minimal length under the problem constraint.**Subarray should be contiguous**.

**More practice: If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log n).**

**Idea**:  

- solution 1 : Sliding window. Use two pointers to record the beginning and the end of the subarray. If current sum >= s then update the min length of subarray and move the left pointer of the sliding window one step right. Otherwise, move the right pointer one step right and update the current sum. Time complexity is O(n)

- solution 2: nlgn solution. We can use binary search obtain lgn but the array should be sorted. Since the subarray should be contiguous,
thus we shouldn't sort the array. Then how could we implement the nlgn solution? 

**We need to get the minimum size subarray sum, we can sum the elements before i, then we can get a sorted array and apply binary search**
See details in the code below. 


**Solution 1**: O(n) time complexity

```java
    public int minSubArrayLen(int s, int[] nums) {
        if (nums == null || nums.length == 0 || s == 0) {
            return 0;
        }
        int start = 0;
        int end = 0;
        int res = Integer.MAX_VALUE;
        int sum = nums[0];
        while (end < nums.length  && start <= end) {
            if (sum < s) {
                end++;
                if (end < nums.length) {
                    sum += nums[end];
                }
            }
            if (sum >= s) {
                res = Math.min(end - start + 1, res);
                sum -= nums[start++];
            }
        }
        return res == Integer.MAX_VALUE ? 0 : res;
    }
```

**Solution 2**: O(nlgn) time complexity

```java
    public int minSubArrayLen(int s, int[] nums) {
        if (nums == null || nums.length == 0 || s == 0) {
            return 0;
        }
        int[] sums = new int[nums.length];
        sums[0] = nums[0];
        for (int i = 1; i < nums.length; i++) {
            sums[i] = sums[i-1] + nums[i];
        }
        if (sums[sums.length - 1] < s) {
            return 0;
        }
        int res = Integer.MAX_VALUE;
        for (int i = 0; i < nums.length; i++) {
            int l = i;
            int r = nums.length - 1;
            while (l <= r) {
                int mid = l + (r - l) / 2;
                if (sums[mid] - sums[i] + nums[i] >= s) {
                    res = Math.min(res, mid - i + 1);
                    r = mid - 1;
                } else {
                    l = mid + 1;
                }
            }
        }
        return res == Integer.MAX_VALUE ? 0 : res;
    }
```


<br>
<br>

###210 Course Schedule II 

>There are a total of n courses you have to take, labeled from 0 to n - 1.

Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]

Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses.

There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array.

For example:

2, [[1,0]]
There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1]

4, [[1,0],[2,0],[3,1],[3,2]]
There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. So one correct course order is [0,1,2,3]. Another correct ordering is[0,2,1,3].

Note:
The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented.


<br>

**Idea**: same method with Course Schedule I. Use topological sort

**Accept solution**: Time complexity: O(V + E)

```java
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        if (numCourses <= 0) {
            return null;
        }
        int[] res = new int[numCourses];
        if (prerequisites == null || prerequisites.length == 0) {
            for (int i = 0; i < numCourses; i++) {
                res[i] = i;
            }
            return res;
        }
        int[] inDegree = new int[numCourses];
        Map<Integer, List<Integer>> map = new HashMap<Integer, List<Integer>>();
        for (int i = 0; i < prerequisites.length; i++) {
            int key = prerequisites[i][1];
            int val = prerequisites[i][0];
            if (!map.containsKey(key)) {
               map.put(key, new ArrayList<Integer>());
            }
            map.get(key).add(val);
            inDegree[val]++;
        }
        
       
        Queue<Integer> zeroDegrees = new LinkedList<Integer>();
        for (int i = 0; i < numCourses; i++) {
            if (inDegree[i] == 0) {
                zeroDegrees.offer(i);
            }
        }
        
        int count = 0;
        while (!zeroDegrees.isEmpty()) {
            int temp = zeroDegrees.poll();
            res[count++] = temp;
            if (map.get(temp) != null) {
                for (Integer i: map.get(temp)) {
                    if (inDegree[i] >= 1) {
                        inDegree[i]--;
                        if (inDegree[i] == 0) {
                            zeroDegrees.offer(i);
                        }
                    }
                }
            }
        }
        
        return count == numCourses ? res : new int[0];
    }
```

**Here is an memory limit exceeded solution**:

```java
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        if (numCourses <= 0) {
            return null;
        }
        int[] res = new int[numCourses];
        if (prerequisites == null || prerequisites.length == 0) {
            for (int i = 0; i < numCourses; i++) {
                res[i] = i;
            }
            return res;
        }
        int[][] adj = new int[numCourses][numCourses];
        int[] inDegree = new int[numCourses];
        for (int i = 0; i < prerequisites.length; i++) {
            int in = prerequisites[i][1];
            int out = prerequisites[i][0];
            if (adj[in][out] == 0) {
                inDegree[out]++;
            }
            adj[in][out] = 1;
        }
        
       
        Queue<Integer> zeroDegrees = new LinkedList<Integer>();
        for (int i = 0; i < numCourses; i++) {
            if (inDegree[i] == 0) {
                zeroDegrees.offer(i);
            }
        }
        
        int count = 0;
        while (!zeroDegrees.isEmpty()) {
            int temp = zeroDegrees.poll();
            res[count++] = temp;
            
            for (int i = 0; i < numCourses; i++) {
                if (adj[temp][i] == 1) {
                    inDegree[i]--;
                    if (inDegree[i] == 0) {
                        zeroDegrees.offer(i);
                    }
                }
            }

        }
        
        return count == numCourses ? res : new int[0];
    }
```






###222 Count Complete Tree Nodes

>Given a complete binary tree, count the number of nodes.

>Definition of a complete binary tree from Wikipedia:

>In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.

**Idea**: 

A O(n) solution is pretty straight forward. Here we discuss a O(logn * logn) solution

Look at the following picture: 

![completetree](https://wishyouhappy.github.io/pictures/completetree.png)

For a complete tree, it's easier to find the height of a tree or subtree. We can divide the count work into two parts. COunt the nodes in the left subtree and count the node in the right subtree, then sum them. 

How can we determine how many nodes to add?

In the figure above, we can first check if height of subtree root at 2 is equal tp height of subtree rooted at 3. There are two cases:

- 1) If it doesn't equal, then we know that right subtree's last level is empty. So we add 2 ^ (height of right subtree) - 1 + 1(parent). And go to the left subtree. **Note that in this case, the right subtree is full, but its height is 1 smaller than the height of the left subtree. 

- 2) What if they equal, then we know that left subtree is full. So we add 2 ^ (height of left subtree) - 1 + 1(parent). And go to the right subtree. 

Let's go over the above figure. 

- 1) count = 0; root = 1; height(2) = 3, height(3) = 2. Thus height(2) != height(3). It's case 1, so count += 2 ^ 2 - 1 + 1 = 4. root = root.left = 2;

- 2) count = 4; root = 2, height(4) = height(5) = 2. Thus it's case 2. So count += 2 ^ 2 - 1 + 1 = 8. root = root.right = 5

- 3) count = 8; root = 5, height(1) = height(2) = 1. Thus it's case 2. So count += 2 ^ 1 - 1 + 1 = 10. root = root.right = 2

- 4) count = 10; root = 2, height(left) = height(right) = 0. It's case 2. so count += 2 ^ 0 - 1 + 1 = 11. root = root.right = null.

- 5) count = 11; root = null. Stop, return 11. 

**Solution**:

```java
public int countNodes(TreeNode root) {
    if (root == null) {
        return 0;
    }
    int res = 0;
    int h = getHeight(root);
    while (root != null) {
        //if left subtree is full
        if (getHeight(root.right) == h - 1) {
            res += 1 << (h - 1);
            root = root.right;
        } else {
            //if missing nodes begins at left subtree.
            res += 1 << (h - 2);
            root = root.left;
        }
        h--;
    }
    return res;
}
public int getHeight(TreeNode root) {
    return root == null ? 0 : 1 + getHeight(root.left);
}

```


<br>

**Related**: Check if a binary tree is complete?

**Idea**: Use level order traversal, once we find a node does not have both left chil and right child, then the remian nodes in the queue must be leaf node. 



**Solution**:


```java
  public boolean isCompleted(TreeNode root) {
    if (root == null) {
      return true;
    }
    Queue<TreeNode> queue = new LinkedList<TreeNode>();
    queue.offer(root);
    boolean isFull = true;
    while (!queue.isEmpty()) {
      TreeNode cur = queue.poll();
      if (cur.left != null) {
        if (!isFull) {
          return false;
        }
        queue.offer(cur.left);
      } else {
        isFull = false;
      }
      if (cur.right != null) {
        if (!isFull) {
          return false;
        }
        queue.offer(cur.right);
      } else {
        isFull = false;
      }
    }
    return true;
  }
```

<br>
<br>

###216 Combination Sum III

> Find all possible combinations of k numbers that add up to a number n, given that only numbers from **1 to 9** can be used and each combination should be a **unique set of numbers**.

>Ensure that numbers within the set are **sorted in ascending order**.

<pre>

Example 1:

Input: k = 3, n = 7

Output:

[[1,2,4]]

Example 2:

Input: k = 3, n = 9

Output:

[[1,2,6], [1,3,5], [2,3,4]]

</pre>


**Idea**: This problem is the combination of [40 Combination Sum II](https://github.com/wishyouhappy/leetcode#40-combination-sum-ii) and [77 Combinations](https://github.com/wishyouhappy/leetcode#77-combinations). In the recursion termination condition, we need to take care of bothe the sum and number of elements. 


**Solution**:


```java
    public List<List<Integer>> combinationSum3(int k, int n) {
        List<List<Integer>> res = new ArrayList<List<Integer>>();
        if (k * 9 < n) {
            return res;
        }
        combinationSum3(k, n, 1, res, new ArrayList<Integer>(), 0);
        return res;
    }
    
    public void combinationSum3(int k, int n, int start, List<List<Integer>> res, List<Integer> item, int sum) {
        if (item.size() == k && sum == n) {
            res.add(new ArrayList<Integer>(item));
            return;
        } 
        if (sum >= n || item.size()>= k) {
            return;
        }
        for (int i = start; i <= 9; i++) {
            item.add(i);
            combinationSum3(k, n, i + 1, res, item, sum + i);
            item.remove(item.size() - 1);
        }
       
    }
```
<br>
<br>


##Similar questions from other sources.

###1 Search a 2D Matrix II

> Write an efficient algorithm that searches for a value in an n x m table (two-dimensional array). This table is sorted along the rows and columns — that is,

> Integers in each row are sorted from left to right.

> Integers in each column are sorted from up to bottom.

<pre>
eg:


1 4 7
2 5 8
3 6 9

</pre>


**Idea**:

**Solution 1**: We can use the idea in solution 1 of * [74 Search a 2D Matrix](https://github.com/wishyouhappy/leetcode#74-search-a-2d-matrix). We search from the upright, each time we can ignore one row or one column. Thus the overall time complexity if O(m+n)

**Solution 2**: Use divide and conquer to solve this problem. For each element in the matrix,if we treat it as a center element, we can divide the matrix into 4 submatrix. There are three ways to apply partition, row-based, column-based and diagonal. 

Considering the three cases int he following picture:

![matrix](https://wishyouhappy.github.io/pictures/matrix.png)

- 1) column-based: we search from the middle column,  if we need to find 10, then we first search on the hightlighted column, we find that 10 is between 6-11, then we search from the upright and bottomleft sub-matrix

- 2) row-based: we search from the middle row, if we need to find 8, then we first search on the hightlighted row, we find that 8 is between 6-10, then we search from the upright and bottomleft sub-matrix

- 3) diagonal: **note that if you want to use diagonal method, the matrix need to have a square matrix**. if we need to find 10, then we first search on the hightlighted column, we find that 10 is between 7-13, then we search from the upright and bottomleft sub-matrix


**Solution 3**: Improve the method in solution 2. We can apply binary search to three ways described above. 

** Java Solution**:

**Solution 1**: Time complexity: O(m + n)

```java 
	 public boolean searchMatrix(int[][] matrix, int target) {
		 if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
			 return false;
		 }
		 int i = 0;
		 int j = matrix[0].length - 1;
		 int row = matrix.length;
		 while(i < row && j >= 0) {
			 if (matrix[i][j] == target) {
				 return true;
			 } else if (matrix[i][j] > target) {
				 j--;
			 } else {
				 i++;
			 }
		 }
		 return false;
	 }
```


**Solution 2**: Time complexity O(nlgn)

1) In the code below, we apply search on the diagonal direction.**matrix must be square**

```java

	 public boolean searchMatrix1(int[][] matrix, int target) {
		 return helper(matrix, target, 0, matrix[0].length - 1, 0, matrix.length - 1);
	 }
	 
	 /* l r u b stands for left, right, top, bottom.*/ 
	 public boolean searchMatrix1(int[][] matrix, int target, int l, int r, int t, int b) {
		 if (l > r || t > b) {
			 return false;
		 }
		 int currentRow = t;
		 int currentCol = l;
		 while(currentRow <= b && currentCol <= r && matrix[currentRow][currentCol] <= target) {
			 if (matrix[currentRow][currentCol] == target) {
				 return true;
			 }
			 currentRow++;
			 currentCol++;
		 }
		 return helper(matrix, target, l, currentCol - 1, currentRow, b) || helper(matrix, target,currentCol, r, t, currentRow - 1);
		 
	 }

```


2) row-based

```java
	 public boolean searchMatrix(int[][] matrix, int target) {
		 return helper(matrix, target, 0, matrix[0].length - 1, 0, matrix.length - 1);
	 }
	 
	 /* l r u b stands for left, right, top, bottom.*/ 
	 public boolean searchMatrix(int[][] matrix, int target, int l, int r, int t, int b) {
		 if (l > r || t > b) {
			 return false;
		 }
		 int midRow = t + (b - t) / 2;
		 int currentCol = l;
		 while(currentCol <= r && matrix[midRow][currentCol] <= target) {
			 if (matrix[midRow][currentCol] == target) {
				 return true;
			 }
			 currentCol++;
		 }
		 return helper(matrix, target, l, currentCol - 1, midRow + 1, b) || helper(matrix, target,currentCol, r, t, midRow - 1);
		 
	 }


```


**Solution 3**: Time complexity:O(n)

Take row-based as an example

```java
	 public boolean searchMatrix(int[][] matrix, int target) {
		 return helper(matrix, target, 0, matrix[0].length - 1, 0, matrix.length - 1);
	 }
	 
	 /* l r u b stands for left, right, top, bottom.*/ 
	 public boolean searchMatrix(int[][] matrix, int target, int l, int r, int t, int b) {
		 if (l > r || t > b) {
			 return false;
		 }
		 int midRow = t + (b - t) / 2;
		 int currentCol = l;
		 int right = r;
		 while(currentCol <= r && matrix[midRow][currentCol] <= target) {
			 int mid = currentCol + (right - currentCol) / 2;
			 if (matrix[midRow][mid] == target) {
				 return true;
			 } else if (matrix[midRow][mid] > target) {
				 right = mid - 1;
			 } else {
				 currentCol = mid + 1;
			 }
		 }
		 return helper(matrix, target, l, currentCol - 1, midRow + 1, b) || helper(matrix, target,currentCol, r, t, midRow - 1);
		 
	 }

```



###2 First Bad Version

>*From lintcode*

> The code base version is an integer start from 1 to n. One day, someone committed a bad version in the code case, so it caused this version and the following versions are all failed in the unit tests. Find the first bad version.

>You can call isBadVersion to help you determine which version is the first bad one. The details interface can be found in the code's annotation part.

>Example
Given n=5:

>Call isBadVersion(3), get false;

>Call isBadVersion(5), get true;

>Call isBadVersion(4), get true;

>Here we are 100% sure that the 4th version is the first bad version.

>Note
Please read the annotation in code area to get the correct way to call isBadVersion in different language. For example, Java is VersionControl.isBadVersion(v)

>Challenge
You should call isBadVersion as few as possible.


**Idea**: Since the bad version causes it's later version fail to the test, thus if version i is ok, then versions after i must be ok. Thus, we can use binary search to search the first bad version. 

**Code**:

```java

/**
 * public class VersionControl {
 *     public static boolean isBadVersion(int k);
 * }
 * you can use VersionControl.isBadVersion(k) to judge wether 
 * the kth code version is bad or not.
*/
class Solution {
    /**
     * @param n: An integers.
     * @return: An integer which is the first bad version.
     */
    public int findFirstBadVersion(int n) {
        // write your code here
        if (n <= 0) {
            return -1;
        }
        
        int l = 1;
        int r = n;
        while (l <= r) {
            int mid = l + (r - l) / 2;
            if (VersionControl.isBadVersion(mid)) {
                r = mid - 1;
            } else {
                l = mid + 1;
            }
        }
        return l;
    }


```

<br>
<br>


###3 Compare Strings

> Compare two strings A and B, determine whether A contains all of the characters in B.

> The characters in string A and B are all Upper Case letters.

<pre>
Example
For A = "ABCD", B = "ACD", return true.

For A = "ABCD", B = "AABC", return false.

**"ABCDE", "DB" return true**

</pre>

Note
**The characters of B in A are not necessary continuous or ordered.**


**Idea**: 
- The question does not require that the appear sequence in A and B sould be the same, thus we need fisrt sort tehe string before we compare. 
- When compare, since it does not require the characters should be continuous in A, thus for each begin index in A, we need to walk through the end to check if B exists. Here is a example solution below in O(n^2) time. 


**Solution**:

```java
public class Solution {
    /**
     * @param A : A string includes Upper Case letters
     * @param B : A string includes Upper Case letter
     * @return :  if string A contains all of the characters in B return true else return false
     */
    public boolean compareStrings(String A, String B) {
        // write your code here
        if (A == null || B == null) {
            return false;
        }
        if (B.length() == 0) {
            return true;
        }
        char[] arrA = A.toCharArray();
        char[] arrB = B.toCharArray();
        Arrays.sort(arrA);
        Arrays.sort(arrB);
        
        for (int i = 0; i <= A.length() - B.length(); i++) {
            int temp = 0;
            int j = 0;
            while (j < B.length() && i + temp < A.length()) {
                if (arrA[i + temp] == arrB[j]) {
                    temp++;
                    j++;
                } else {
                    temp++;
                }
            }
            if (j > B.length() - 1) {
                return true;
            }
        }
        return false;
    }
}
```

<br>
<br>



###4 Longest Common Substring

>Given two strings, find the longest common substring. Return the length of it. From lintcode

>Example, Given A = "ABCD", B = "CBCE", return 2.

Note: The characters in substring should occur continuously in original string. This is different with subsequence.

Challenge O(n x m) time and memory.

**Idea**: 
The most straight forward way to solve this problem takes O(n^3) time, we compare from the begining of two string, when not equal, update the max, move the pointer of the second string to the next character. The time complexity is bad. 

Generally, there are two ways to solve the longest common substring problem. 

- Dynamic programming

- **suffix tree**

Using dynamix programming we can get the result in O(m * n) time, m, n is the length of the two strings.

Using suffix tree we can reduce the time complexity to O(m + n). 

Below is the solution of dynamic programming.

Want to know more about the solution of suffix tree, click on this two links: [longest common substring](http://algs4.cs.princeton.edu/63suffix/LongestCommonSubstring.java.html) , [suffix array](http://algs4.cs.princeton.edu/63suffix/SuffixArray.java.html)

**Solution**:

```java
public class Solution {
    /**
     * @param A, B: Two string.
     * @return: the length of the longest common substring.
     */
    public int longestCommonSubstring(String A, String B) {
        // write your code here
        if (A == null || B == null || A.length() == 0 || B.length() == 0) {
            return 0;
        }
        int maxLen = Math.max(A.length(), B.length());
        int[][] dp = new int[maxLen+1][maxLen+1];
        int res = 0;
        for (int i = 0; i < A.length(); i++) {
            for (int j = 0; j < B.length(); j++) {
                if (A.charAt(i) == B.charAt(j)) {
                    dp[i+1][j+1] = dp[i][j] + 1;
                    res = Math.max(res, dp[i+1][j+1]);
                } else {
                    dp[i][j] = 0;
                }
            }
        }
        return res;
    }
}
```

<br>
<br>



###5 Insert in Sorted Linked List

**Idea**: We need to find insert position, then add the element into the linkedlist

- 1) if  head is null, return new ListNode as head
- 2) if insert value <= head.value, add element at the beginning, return new added list element
- 3) find insert position, insert element 



```java
  public ListNode insert(ListNode head, int value) {
    // write your solution here
    ListNode newNode = new ListNode(value);
    if (head == null) {
      head = newNode;
      return head;
    }
    //find insert position
    ListNode temp = head;
    ListNode pre = null;
    while(temp != null && temp.value < value) {
      pre = temp;
      temp = temp.next;
    }
    if (head.value >= value) {
      newNode.next = head;
      return newNode;
    }
    pre.next = newNode;
    newNode.next = temp;
    return head;
}
```


<br>
<br>


###6 Is Bipartite

>Suppose a graph is repensented as list, check if this graph is bipartite. If you are not familiar with bipartite, click on this link: [bipartite](http://en.wikipedia.org/wiki/Bipartite_graph).

**Idea**: In bipartite graph, we can divide the graph into two groups and inside each group, there is no edge between nodes in that group. 

Let's give an example, suppose group red and blue, if node 1 is in group green, if node 2 is neighbor of node 1, then node 2 must in group red. Thus we can traverse the graph to check if this condition is always true.

**Some notes**:

- 1) In graph traversal, unlike tree traversal, we need to record if a node is visited or not

- 2) In this problem, we also need to record the group information of each node. Let's use the above example: if node 1 is in group green, if node 2 is neighbor of node 1, then node 2 must in group red. And if node 2 has neighbor node 3, and node3 is red, then the graph is not a bipartite. 


**Solution**:

```java
/**
 * public class GraphNode {
 *   public int key;
 *   public List<GraphNode> neighbors;
 *   public GraphNode(int key) {
 *     this.key = key;
 *     this.neighbors = new ArrayList<GraphNode>();
 *   }
 * }
 */
public class Solution {
  public boolean isBipartite(List<GraphNode> graph) {
    if (graph == null) {
      return true;
    }
    Map<GraphNode, Integer> map = new HashMap<GraphNode, Integer>();
    for (GraphNode n : graph) {
      if (map.containsKey(n)) {
        continue;
      }
      Queue<GraphNode> queue = new LinkedList<GraphNode>();
      queue.offer(n);
      map.put(n, 0);
      while (!queue.isEmpty()) {
        GraphNode cur = queue.poll();
        List<GraphNode> neighbors = cur.neighbors;
        int reverseColor = map.get(cur) == 0 ? 1 : 0;
        for (int i = 0; i < neighbors.size(); i++){
          GraphNode neighbor = neighbors.get(i);
          if (!map.containsKey(neighbor)) {
            map.put(neighbor, reverseColor);
            queue.offer(neighbor);
          } else if (map.get(neighbor) != reverseColor) {
              return false;
          }
        }
      }
    }
   
    return true;
  }
}
```

<br>
<br>
###7 Lowest Common Ancestor

>Given two nodes in a binary tree, find their lowest common ancestor.

**Idea**: Use recursion

1) base case : root == null, root == one or root == two
2) expect from left child : left child returns one or two
   expect from right child : right child returns one or two.
3) In current level: 
    a. if left child returns one or two and right child returns one or two, indicates that we have found the lowest common ancester, returns root.
    b. if one side returns one or two, return the not null one.
 


```java
  public TreeNode lowestCommonAncestor(TreeNode root,
      TreeNode one, TreeNode two) {
    if (root == null) {
      return null;
    }
    if (root == one || root == two) {
      return root;
    }
    TreeNode left = lowestCommonAncestor(root.left, one, two);
    TreeNode right = lowestCommonAncestor(root.right, one, two);
    if (left != null && right != null) {
      return root;
    }
    return left == null ? right : left;
  }
```




